<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Skila.ai | Ballistic Trajectory Lab</title>
    <link href="https://fonts.googleapis.com/css2?family=Teko:wght@300;600&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Included but using Canvas 2D for specific stylized look requested -->
    <style>
        :root {
            --neon-blue: #00f3ff;
            --neon-pink: #bc13fe;
            --grid-color: rgba(0, 243, 255, 0.1);
            --hud-bg: rgba(10, 10, 20, 0.85);
        }

        body {
            margin: 0;
            overflow: hidden;
            background: #050510;
            font-family: 'Teko', sans-serif;
            color: #fff;
        }

        /* HUD LAYOUT */
        #game-ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        .top-bar {
            width: 100%;
            padding: 20px 40px;
            display: flex;
            justify-content: space-between;
            align-items: start;
            background: linear-gradient(to bottom, #000, transparent);
        }

        .data-readout {
            text-align: right;
        }

        .data-row {
            font-size: 24px;
            color: var(--neon-blue);
            text-shadow: 0 0 10px var(--neon-blue);
            letter-spacing: 2px;
        }

        .data-label {
            font-size: 14px;
            color: #666;
            letter-spacing: 1px;
        }

        .controls-panel {
            pointer-events: auto;
            align-self: flex-start;
            margin-left: 40px;
            margin-bottom: 40px;
            background: var(--hud-bg);
            border: 1px solid #333;
            border-left: 4px solid var(--neon-pink);
            padding: 30px;
            width: 350px;
            backdrop-filter: blur(10px);
            clip-path: polygon(0 0, 100% 0, 100% 90%, 90% 100%, 0 100%);
        }

        h2 {
            font-size: 32px;
            color: #fff;
            margin: 0 0 20px 0;
            border-bottom: 1px solid #333;
            padding-bottom: 5px;
        }

        .control-group {
            margin-bottom: 25px;
        }

        .control-label {
            display: flex;
            justify-content: space-between;
            font-size: 18px;
            color: #aaa;
            margin-bottom: 8px;
        }

        .value-disp {
            color: var(--neon-pink);
            font-weight: bold;
        }

        input[type=range] {
            -webkit-appearance: none;
            width: 100%;
            background: transparent;
        }

        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 16px;
            width: 16px;
            border-radius: 50%;
            background: var(--neon-pink);
            cursor: pointer;
            margin-top: -6px;
            box-shadow: 0 0 10px var(--neon-pink);
        }

        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            cursor: pointer;
            background: #333;
            border-radius: 2px;
        }

        .planet-selector {
            display: flex;
            gap: 5px;
            margin-top: 10px;
        }

        .planet-btn {
            flex: 1;
            padding: 10px;
            background: #222;
            border: 1px solid #444;
            color: #888;
            cursor: pointer;
            text-align: center;
            font-size: 16px;
            transition: all 0.3s;
        }

        .planet-btn:hover {
            background: #333;
        }

        .planet-btn.active {
            background: var(--neon-blue);
            color: #000;
            border-color: var(--neon-blue);
            box-shadow: 0 0 15px var(--neon-blue);
        }

        .main-btn {
            width: 100%;
            padding: 15px;
            background: transparent;
            border: 2px solid var(--neon-pink);
            color: var(--neon-pink);
            font-family: 'Teko', sans-serif;
            font-size: 28px;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 2px;
            transition: all 0.2s;
            position: relative;
            overflow: hidden;
        }

        .main-btn:hover {
            background: var(--neon-pink);
            color: #000;
            box-shadow: 0 0 30px var(--neon-pink);
        }

        .main-btn:active {
            transform: scale(0.98);
        }

        #history-log {
            position: absolute;
            bottom: 40px;
            right: 40px;
            width: 250px;
            pointer-events: none;
            opacity: 0.7;
            font-size: 14px;
            text-align: right;
        }

        .log-entry {
            color: #888;
            border-bottom: 1px solid #222;
            padding: 2px 0;
        }

        .log-entry span {
            color: var(--neon-blue);
        }
    </style>
</head>

<body>
    <canvas id="canvas"></canvas>

    <div id="game-ui">
        <div class="top-bar">
            <div>
                <h1 style="font-size: 40px; color: #fff; line-height: 1;">BALLISTIC <span
                        style="color:var(--neon-blue)">RANGE</span></h1>
                <div style="font-size: 16px; color: #666; letter-spacing: 3px;">KINEMATIC VECTOR SIMULATOR v9.0</div>
            </div>

            <div class="data-readout">
                <div class="data-row" id="disp-time">0.00 s</div>
                <div class="data-label">FLIGHT TIME</div>

                <div class="data-row" id="disp-dist" style="color:var(--neon-pink); margin-top:10px;">0.0 m</div>
                <div class="data-label">DISTANCE</div>

                <div class="data-row" id="disp-height" style="color:#0f0; margin-top:10px;">0.0 m</div>
                <div class="data-label">MAX HEIGHT</div>
            </div>
        </div>

        <div class="controls-panel">
            <h2>CONTROLS</h2>

            <div class="control-group">
                <div class="control-label"><span>LAUNCH ANGLE</span><span class="value-disp" id="val-angle">45°</span>
                </div>
                <input type="range" id="inp-angle" min="0" max="90" value="45">
            </div>

            <div class="control-group">
                <div class="control-label"><span>VELOCITY (Vo)</span><span class="value-disp" id="val-power">80
                        m/s</span></div>
                <input type="range" id="inp-power" min="10" max="150" value="80">
            </div>

            <div class="control-group">
                <div class="control-label"><span>WIND</span><span class="value-disp" id="val-wind">0 m/s</span></div>
                <input type="range" id="inp-wind" min="-20" max="20" value="0">
            </div>

            <div class="control-group">
                <div class="control-label"><span>GRAVITY</span></div>
                <div class="planet-selector">
                    <div class="planet-btn" onclick="setG(1.6)">MOON</div>
                    <div class="planet-btn active" onclick="setG(9.8)">EARTH</div>
                    <div class="planet-btn" onclick="setG(24.8)">JUPITER</div>
                </div>
            </div>

            <button class="main-btn" onclick="fire()">FIRE CANNON</button>
            <button class="main-btn" onclick="clearTracks()"
                style="margin-top:10px; border-color:#444; color:#888; font-size:20px; padding:5px;">CLEAR
                TRACES</button>
        </div>

        <div id="history-log">
            <div style="color:#fff; border-bottom:1px solid #444; margin-bottom:5px;">LAUNCH HISTORY</div>
            <div id="log-list"></div>
        </div>
    </div>

    <script>
        /**
         * BALLISTICS ENGINE
         * High-fidelity projectile physics with wind resistance approximation
         * and precise vector rendering.
         */

        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        // --- CONSTANTS & CONFIG ---
        let WIDTH, HEIGHT;
        const GROUND_Y_OFFSET = 100; // Pixels from bottom
        const METER_SCALE = 5; // 1 meter = 5 pixels

        // Physics Vars
        let GRAVITY = 9.8;
        let ANGLE = 45; // Degrees
        let POWER = 80; // m/s
        let WIND = 0; // m/s

        // State
        let PROJECTILES = []; // { x, y, vx, vy, t, active, history, color }
        let EXPLOSIONS = []; // { x, y, age, maxAge }
        let SHOTS_FIRED = 0;

        let PREDICT_POINTS = [];

        // UI Refs
        const uiAngle = document.getElementById('val-angle');
        const uiPower = document.getElementById('val-power');
        const uiWind = document.getElementById('val-wind');
        const inpAngle = document.getElementById('inp-angle');
        const inpPower = document.getElementById('inp-power');
        const inpWind = document.getElementById('inp-wind');

        const dTime = document.getElementById('disp-time');
        const dDist = document.getElementById('disp-dist');
        const dHeight = document.getElementById('disp-height');
        const logList = document.getElementById('log-list');

        // --- INITIALIZATION ---
        function init() {
            resize();
            bindInputs();
            calcPrediction();
            loop();
        }

        function resize() {
            WIDTH = canvas.width = window.innerWidth;
            HEIGHT = canvas.height = window.innerHeight;
            calcPrediction();
        }
        window.addEventListener('resize', resize);

        function bindInputs() {
            inpAngle.addEventListener('input', e => {
                ANGLE = parseInt(e.target.value);
                uiAngle.innerText = ANGLE + "°";
                calcPrediction();
            });
            inpPower.addEventListener('input', e => {
                POWER = parseInt(e.target.value);
                uiPower.innerText = POWER + " m/s";
                calcPrediction();
            });
            inpWind.addEventListener('input', e => {
                WIND = parseInt(e.target.value);
                uiWind.innerText = WIND + " m/s";
                calcPrediction();
            });
        }

        window.setG = (g) => {
            GRAVITY = g;
            document.querySelectorAll('.planet-btn').forEach(b => b.classList.remove('active'));
            event.target.classList.add('active');
            calcPrediction();
        };

        window.clearTracks = () => {
            PROJECTILES = [];
            EXPLOSIONS = [];
            document.getElementById('log-list').innerHTML = "";
            dTime.innerText = "0.00 s";
            dDist.innerText = "0.0 m";
            dHeight.innerText = "0.0 m";
        };

        // --- PHYSICS CORE ---

        function fire() {
            // Spawn Projectile
            const rad = ANGLE * Math.PI / 180;
            const vx = Math.cos(rad) * POWER;
            const vy = Math.sin(rad) * POWER; // Up is positive in Math, Canvas Y is down. 
            // We will calculate in Cartesian (Y up) and map to Screen (Y down)

            SHOTS_FIRED++;
            const hue = (SHOTS_FIRED * 40) % 360;

            PROJECTILES.push({
                x: 0,
                y: 0, // Origin calc relative to cannon mouth
                vx: vx,
                vy: vy,
                t: 0,
                active: true,
                history: [],
                color: `hsl(${hue}, 100%, 60%)`,
                maxH: 0
            });

            // Camera shake effect trigger?
        }

        // Accurate Analytic Prediction (ignoring wind for simplicity or iterative for wind)
        // With Wind, analytic is complex. We'll use simulation for prediction line.
        function calcPrediction() {
            PREDICT_POINTS = [];
            const dt = 0.1;
            let simT = 0;

            const rad = ANGLE * Math.PI / 180;
            let sx = 0; let sy = 0;
            let svx = Math.cos(rad) * POWER;
            let svy = Math.sin(rad) * POWER;

            // Simulate 500 steps or until ground
            for (let i = 0; i < 1000; i++) {
                PREDICT_POINTS.push({ x: sx, y: sy });

                // Update
                svx += WIND * 0.1 * dt; // Simple wind drag accel (fake)
                svy -= GRAVITY * dt;

                sx += svx * dt;
                sy += svy * dt;

                simT += dt;
                if (sy < 0) break; // Check Hit Ground (Y < 0) matches simple model
            }
        }

        function updatePhysics() {
            const dt = 1 / 60; // Fixed time step

            // Update Projectiles
            PROJECTILES.forEach(p => {
                if (!p.active) return;

                // Save history every 5 frames
                if (Math.floor(p.t * 60) % 5 === 0) {
                    p.history.push({ x: p.x, y: p.y });
                }

                // Physics
                // Wind Effect: Acts as acceleration towards wind speed
                // F_drag = C * (V - V_wind)^2 ... Simplified:
                p.vx += (WIND * 0.5) * dt;

                // Gravity
                p.vy -= GRAVITY * dt;

                // Pos
                p.x += p.vx * dt;
                p.y += p.vy * dt;
                p.t += dt;

                if (p.y > p.maxH) p.maxH = p.y;

                // Update UI based on active
                dTime.innerText = p.t.toFixed(2) + " s";
                dDist.innerText = p.x.toFixed(1) + " m";
                dHeight.innerText = p.maxH.toFixed(1) + " m";

                // Ground Hit
                if (p.y < 0) {
                    p.active = false;
                    p.y = 0;
                    createExplosion(p.x, 0, p.color);
                    logHit(p);
                }
            });

            // Update Explosions
            for (let i = EXPLOSIONS.length - 1; i >= 0; i--) {
                EXPLOSIONS[i].age++;
                if (EXPLOSIONS[i].age > EXPLOSIONS[i].maxAge) EXPLOSIONS.splice(i, 1);
            }
        }

        function logHit(p) {
            const div = document.createElement('div');
            div.className = "log-entry";
            div.innerHTML = `Dist: <span>${p.x.toFixed(1)}m</span> | Time: ${p.t.toFixed(1)}s`;
            logList.prepend(div);
            if (logList.children.length > 5) logList.lastChild.remove();
        }

        function createExplosion(x, y, color) {
            EXPLOSIONS.push({
                x: x, y: y, color: color,
                age: 0, maxAge: 60,
                particles: Array.from({ length: 20 }, () => ({
                    vx: (Math.random() - 0.5) * 10,
                    vy: Math.random() * 10,
                    x: 0, y: 0
                }))
            });
        }

        // --- RENDERING ---

        // Coordinate Translation
        // World: (0,0) is Cannon Mouth. Y is UP.
        // Screen: Cannon Mouth at (100, HEIGHT - 100).
        function worldToScreen(x, y) {
            const sx = 100 + x * METER_SCALE;
            const sy = (HEIGHT - GROUND_Y_OFFSET) - y * METER_SCALE;
            return { x: sx, y: sy };
        }

        function render() {
            // 1. Clear & Background
            ctx.fillStyle = '#050510';
            ctx.fillRect(0, 0, WIDTH, HEIGHT);

            // 2. Draw Grid (Tron Floor)
            drawGrid();

            // 3. Draw Cannon
            drawCannon();

            // 4. Draw Prediction
            drawPrediction();

            // 5. Draw Projectiles
            PROJECTILES.forEach(p => {
                const pos = worldToScreen(p.x, p.y);

                // Trail
                if (p.history.length > 1) {
                    ctx.beginPath();
                    ctx.strokeStyle = p.color;
                    ctx.lineWidth = 3;
                    // Fade trail
                    p.history.forEach((h, i) => {
                        const hp = worldToScreen(h.x, h.y);
                        if (i === 0) ctx.moveTo(hp.x, hp.y);
                        else ctx.lineTo(hp.x, hp.y);
                    });
                    ctx.stroke();
                }

                if (p.active) {
                    // Ball
                    ctx.shadowBlur = 15; ctx.shadowColor = p.color;
                    ctx.fillStyle = '#fff';
                    ctx.beginPath(); ctx.arc(pos.x, pos.y, 6, 0, Math.PI * 2); ctx.fill();
                    ctx.shadowBlur = 0;

                    // Vectors
                    // Velocity Vector (Green)
                    // Draw Component Arrows
                    const vScale = 2; // Scale for visual
                    ctx.strokeStyle = '#0f0'; ctx.lineWidth = 2;
                    // V_y
                    drawArrow(pos.x, pos.y, pos.x, pos.y - p.vy * vScale); // Screen Y up is negative
                    // V_x
                    ctx.strokeStyle = '#0cf'; // Blueish
                    drawArrow(pos.x, pos.y, pos.x + p.vx * vScale, pos.y);
                }
            });

            // 6. Explosions
            EXPLOSIONS.forEach(e => {
                const pos = worldToScreen(e.x, e.y);
                e.particles.forEach(part => {
                    part.x += part.vx; part.y += part.vy; part.vy -= 0.5; // gravity

                    ctx.globalAlpha = 1 - (e.age / e.maxAge);
                    ctx.fillStyle = e.color;
                    ctx.beginPath();
                    ctx.arc(pos.x + part.x, pos.y - part.y, 4, 0, Math.PI * 2);
                    // Note: part.y is in Screen space offset, so minus
                    ctx.fill();
                });
                ctx.globalAlpha = 1;

                // Shockwave
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 2;
                ctx.globalAlpha = 1 - (e.age / e.maxAge);
                ctx.beginPath();
                ctx.ellipse(pos.x, pos.y, e.age * 5, e.age * 2, 0, 0, Math.PI * 2);
                ctx.stroke();
                ctx.globalAlpha = 1;
            });
        }

        function drawGrid() {
            // Infinite Floor Logic
            const horizonY = HEIGHT - GROUND_Y_OFFSET;

            // Ground Plane
            // We want a grid that moves or stays static? Static is easier for scale.
            ctx.strokeStyle = 'rgba(0, 243, 255, 0.2)';
            ctx.lineWidth = 1;

            // Vertical lines every 10 meters
            for (let m = 0; m < 500; m += 10) {
                const s = worldToScreen(m, 0);
                if (s.x > WIDTH) break;
                ctx.beginPath(); ctx.moveTo(s.x, horizonY); ctx.lineTo(s.x, horizonY + 20); ctx.stroke();

                // Numbers
                ctx.fillStyle = 'rgba(0, 243, 255, 0.5)';
                ctx.font = '12px Teko'; ctx.textAlign = 'center';
                ctx.fillText(m + "m", s.x, horizonY + 35);
            }

            // Horizontal ground line
            ctx.beginPath(); ctx.moveTo(0, horizonY); ctx.lineTo(WIDTH, horizonY); ctx.stroke();
        }

        function drawCannon() {
            const center = worldToScreen(0, 0);

            ctx.save();
            ctx.translate(center.x, center.y);

            // Base Mount
            ctx.fillStyle = '#222';
            ctx.beginPath(); ctx.arc(0, 0, 20, Math.PI, 0); ctx.fill();

            // Barrel Rotation
            ctx.rotate(-ANGLE * Math.PI / 180); // Negative for Screen CCW

            // Barrel
            ctx.fillStyle = '#333';
            ctx.fillRect(0, -10, 60, 20);

            // Neon accent
            ctx.fillStyle = 'var(--neon-pink)';
            ctx.fillRect(10, -2, 40, 4);

            ctx.restore();
        }

        function drawPrediction() {
            if (PREDICT_POINTS.length < 2) return;

            ctx.beginPath();
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);

            PREDICT_POINTS.forEach((p, i) => {
                const s = worldToScreen(p.x, p.y);
                if (i === 0) ctx.moveTo(s.x, s.y);
                else ctx.lineTo(s.x, s.y);
            });

            ctx.stroke();
            ctx.setLineDash([]);
        }

        function drawArrow(fromX, fromY, toX, toY) {
            const headlen = 10;
            const dx = toX - fromX;
            const dy = toY - fromY;
            const angle = Math.atan2(dy, dx);

            ctx.beginPath();
            ctx.moveTo(fromX, fromY);
            ctx.lineTo(toX, toY);
            ctx.lineTo(toX - headlen * Math.cos(angle - Math.PI / 6), toY - headlen * Math.sin(angle - Math.PI / 6));
            ctx.moveTo(toX, toY);
            ctx.lineTo(toX - headlen * Math.cos(angle + Math.PI / 6), toY - headlen * Math.sin(angle + Math.PI / 6));
            ctx.stroke();
        }

        // --- LOOP ---
        function loop() {
            updatePhysics();
            render();
            requestAnimationFrame(loop);
        }

        init();

    </script>
</body>

</html>