<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Skila.ai | Calculus Lab</title>
    <!-- FONTS -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link
        href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap"
        rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body,
        html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #F8FAFC;
            /* Math Paper */
            font-family: 'Inter', sans-serif;
            user-select: none;
        }

        #graph-canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* UI */
        .ui-layer {
            position: absolute;
            inset: 0;
            pointer-events: none;
        }

        /* HUD */
        .hud-panel {
            position: absolute;
            top: 40px;
            left: 40px;
            width: 320px;
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(12px);
            border: 1px solid #E2E8F0;
            border-radius: 16px;
            padding: 24px;
            pointer-events: auto;
            box-shadow: 0 10px 40px -10px rgba(15, 23, 42, 0.05);
        }

        .math-eq {
            font-family: 'JetBrains Mono', monospace;
            font-size: 18px;
            color: #1E293B;
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 20px;
            background: #F1F5F9;
            padding: 12px;
            border-radius: 8px;
        }

        .var {
            color: #2563EB;
            font-weight: 700;
        }

        .op {
            color: #64748B;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            font-size: 13px;
        }

        .stat-label {
            color: #64748B;
            font-weight: 500;
        }

        .stat-val {
            font-family: 'JetBrains Mono';
            font-weight: 700;
            color: #0F172A;
        }

        /* Slope Indicator */
        .slope-box {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 24px;
            height: 24px;
            border-radius: 4px;
            margin-left: 8px;
            color: white;
            font-size: 12px;
            transition: all 0.2s;
        }

        /* ZOOM LENS */
        .zoom-lens {
            position: absolute;
            top: 40px;
            right: 40px;
            width: 240px;
            height: 240px;
            border-radius: 50%;
            border: 4px solid #CBD5E1;
            background: white;
            overflow: hidden;
            box-shadow: 0 20px 50px rgba(0, 0, 0, 0.1);
            pointer-events: auto;
        }

        .lens-canvas {
            width: 100%;
            height: 100%;
        }

        .lens-label {
            position: absolute;
            bottom: 20px;
            left: 0;
            width: 100%;
            text-align: center;
            font-size: 10px;
            font-weight: 700;
            text-transform: uppercase;
            color: #94A3B8;
            letter-spacing: 1px;
        }

        /* CONTROLS */
        .controls {
            position: absolute;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 16px;
            pointer-events: auto;
        }

        .btn-tool {
            background: white;
            border: 1px solid #E2E8F0;
            padding: 12px 24px;
            border-radius: 99px;
            font-size: 13px;
            font-weight: 600;
            color: #475569;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.05);
            display: flex;
            align-items: center;
            gap: 8px;
            transition: all 0.2s;
            cursor: pointer;
        }

        .btn-tool:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
            color: #2563EB;
        }

        .btn-tool.active {
            background: #2563EB;
            color: white;
            border-color: #2563EB;
        }
    </style>
</head>

<body>

    <canvas id="graph-canvas"></canvas>

    <div class="ui-layer">

        <!-- HUD -->
        <div class="hud-panel">
            <div class="math-eq">
                <span>f(x) = </span>
                <span class="var">x³</span>
                <span class="op"> - </span>
                <span class="var">2x</span>
                <span class="op"> + </span>
                <span class="var">sin(x)</span>
            </div>

            <div class="stat-row">
                <span class="stat-label">Position (x, y)</span>
                <span class="stat-val" id="pos-val">(1.20, 0.85)</span>
            </div>

            <div class="stat-row">
                <span class="stat-label">Derivative (m)</span>
                <div class="flex items-center">
                    <span class="stat-val" id="slope-val">2.45</span>
                    <div id="slope-icon" class="slope-box bg-emerald-500">↗</div>
                </div>
            </div>

            <div class="mt-4 pt-4 border-t border-slate-100">
                <div class="stat-row">
                    <span class="stat-label text-xs">Tangent Eq</span>
                    <span class="stat-val text-xs text-pink-500" id="tan-eq">y = 2.45x - 1.2</span>
                </div>
            </div>
        </div>

        <!-- Zoom Lens -->
        <div class="zoom-lens">
            <canvas id="lens-canvas" class="lens-canvas"></canvas>
            <div class="lens-label">50x Linearization</div>
        </div>

        <!-- Toolbar -->
        <div class="controls">
            <button class="btn-tool active" id="btn-drag" onclick="setMode('drag')">
                <i class="fas fa-hand-pointer"></i> Drag Point
            </button>
            <button class="btn-tool" id="btn-surf" onclick="setMode('surf')">
                <i class="fas fa-snowboarding"></i> Slope Surfer
            </button>
        </div>

    </div>

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

    <script>
        /**
         * SKILA.ai - The Derivative Engine
         * - Coordinate Mapping System (Math <-> Canvas)
         * - Real-time Difference Quotient
         * - Linearization Zoom
         */

        const canvas = document.getElementById('graph-canvas');
        const ctx = canvas.getContext('2d');

        const lensCvs = document.getElementById('lens-canvas');
        const lensCtx = lensCvs.getContext('2d');

        let width, height;
        let time = 0;

        // --- MATH STATE ---
        const GRAPH = {
            scaleX: 80, // Pixels per unit
            scaleY: 80,
            offsetX: 0,
            offsetY: 0, // Center
            pointX: 1.0, // Current X position of P
            surferV: 0,  // Velocity for surfer
            mode: 'drag' // 'drag' or 'surf'
        };

        // The Function: f(x) = 0.5x^3 - 1.5x + 0.2*sin(time + x)
        function f(x) {
            // Add slight animation to coefficients for "breathing" effect
            const t = time * 0.05;
            return 0.3 * Math.pow(x, 3) - 1.2 * x + 0.3 * Math.sin(x * 2 + t);
        }

        // The Derivative (Numerical)
        function df(x) {
            const h = 0.0001;
            return (f(x + h) - f(x)) / h;
        }

        // --- COORDINATE SYSTEM ---
        function toCanvas(x, y) {
            return {
                x: width / 2 + x * GRAPH.scaleX,
                y: height / 2 - y * GRAPH.scaleY // Y flip
            };
        }
        function toMath(cx, cy) {
            return {
                x: (cx - width / 2) / GRAPH.scaleX,
                y: (height / 2 - cy) / GRAPH.scaleY
            };
        }

        // --- RENDERERS ---

        function drawGrid(ctx, w, h, scale, offX, offY) {
            ctx.lineWidth = 1;
            ctx.strokeStyle = '#E2E8F0'; // Light grid

            // Vertical
            const startX = (w / 2) % scale;
            for (let x = startX; x < w; x += scale) {
                ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, h); ctx.stroke();
            }
            // Horizontal
            const startY = (h / 2) % scale;
            for (let y = startY; y < h; y += scale) {
                ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(w, y); ctx.stroke();
            }

            // Axes
            ctx.strokeStyle = '#94A3B8'; // Darker axes
            ctx.lineWidth = 2;
            ctx.beginPath(); ctx.moveTo(0, h / 2); ctx.lineTo(w, h / 2); ctx.stroke(); // X Axis
            ctx.beginPath(); ctx.moveTo(w / 2, 0); ctx.lineTo(w / 2, h); ctx.stroke(); // Y Axis
        }

        function drawCurve(ctx, w, h, scaleX, scaleY) {
            ctx.beginPath();
            ctx.lineWidth = 4;
            ctx.strokeStyle = '#2563EB'; // Electric Blue

            // Iterate visible range
            const startMathX = - w / 2 / scaleX;
            const endMathX = w / 2 / scaleX;
            const step = 0.05;

            let first = true;
            for (let x = startMathX; x <= endMathX; x += step) {
                const y = f(x);
                const pos = toCanvas(x, y);
                if (first) { ctx.moveTo(pos.x, pos.y); first = false; }
                else ctx.lineTo(pos.x, pos.y);
            }
            ctx.stroke();

            // Fill area (Integral visualizer hint)
            ctx.lineTo(toCanvas(endMathX, 0).x, height / 2);
            ctx.lineTo(toCanvas(startMathX, 0).x, height / 2);
            ctx.fillStyle = 'rgba(37, 99, 235, 0.05)';
            ctx.fill();
        }

        function drawTangent(ctx, x) {
            const y = f(x);
            const m = df(x);
            const pos = toCanvas(x, y);

            // Tangent Line: y - y1 = m(x - x1)
            // Draw long line
            const len = 1000;
            // Vector (1, m) normalized? 
            // Better: just mathematical project

            // Left point
            const xL = x - 5;
            const yL = y + m * (xL - x);
            const pL = toCanvas(xL, yL);

            // Right point
            const xR = x + 5;
            const yR = y + m * (xR - x);
            const pR = toCanvas(xR, yR);

            ctx.beginPath();
            ctx.moveTo(pL.x, pL.y);
            ctx.lineTo(pR.x, pR.y);
            ctx.strokeStyle = '#EC4899'; // Neon Pink
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]); // Dashed for infinite feel
            ctx.stroke();
            ctx.setLineDash([]);

            // The Point P
            ctx.beginPath();
            ctx.arc(pos.x, pos.y, 8, 0, Math.PI * 2);
            ctx.fillStyle = 'white';
            ctx.fill();
            ctx.strokeStyle = '#2563EB';
            ctx.lineWidth = 3;
            ctx.stroke();

            // Surfer Mode
            if (GRAPH.mode === 'surf') {
                ctx.font = '20px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('⛷️', pos.x, pos.y - 15);
            }
        }

        // --- ZOOM LENS RENDER ---
        function renderLens() {
            const w = lensCvs.width;
            const h = lensCvs.height;
            const lCtx = lensCtx;

            lCtx.clearRect(0, 0, w, h);
            lCtx.fillStyle = '#F8FAFC';
            lCtx.fillRect(0, 0, w, h);

            // Draw extremely zoomed in view of curve at P
            const cx = w / 2;
            const cy = h / 2;

            // Zoom factor
            const zoom = 50;
            const scaleX = GRAPH.scaleX * zoom;
            const scaleY = GRAPH.scaleY * zoom;

            // Draw Grid in Lens
            lCtx.strokeStyle = 'rgba(226, 232, 240, 0.5)';
            lCtx.lineWidth = 1;
            lCtx.beginPath();
            for (let i = 0; i < w; i += 20) { lCtx.moveTo(i, 0); lCtx.lineTo(i, h); }
            for (let i = 0; i < h; i += 20) { lCtx.moveTo(0, i); lCtx.lineTo(w, i); }
            lCtx.stroke();

            // Local curve segment
            // We want (0,0) of lens to be P(x, y)
            // So for a given lens pixel lx, ly -> math coords?

            lCtx.beginPath();
            lCtx.strokeStyle = '#2563EB'; // Blue Curve
            lCtx.lineWidth = 8; // Really thick to show "line"

            const range = 4 / zoom; // Math range visible in lens
            const startX = GRAPH.pointX - range;
            const endX = GRAPH.pointX + range;
            const step = range / 20;

            const pY = f(GRAPH.pointX); // Center Y math

            // Mapping lens math to lens pixel
            // lensX = (mx - px) * scaleX + cx
            // lensY = cy - (my - py) * scaleY

            let first = true;
            for (let mx = startX; mx <= endX; mx += step / 2) {
                const my = f(mx);
                const lx = (mx - GRAPH.pointX) * scaleX + cx;
                const ly = cy - (my - pY) * scaleY;

                if (first) { lCtx.moveTo(lx, ly); first = false; }
                else lCtx.lineTo(lx, ly);
            }
            lCtx.stroke();

            // Draw Tangent in Lens (Pink)
            // It should perfectly overlap if "Linearization" works
            lCtx.beginPath();
            lCtx.strokeStyle = 'rgba(236, 72, 153, 0.5)'; // Transparent Pink
            lCtx.lineWidth = 4;
            const m = df(GRAPH.pointX);

            // Draw line through center with slope m
            // dy = - m * dx (canvas y coords are flipped)
            // At lx = 0 (left edge), dx = -cw/2/scaleX

            const dx = w / scaleX; // Math range width
            // Simple: Point 1 (left), Point 2 (right)
            const lx1 = 0;
            const mathX1 = GRAPH.pointX - (cx / scaleX);
            // Linear approx: y = pY + m(x - px)
            const mathY1 = pY + m * (mathX1 - GRAPH.pointX);
            const ly1 = cy - (mathY1 - pY) * scaleY;

            const lx2 = w;
            const mathX2 = GRAPH.pointX + (w - cx) / scaleX;
            const mathY2 = pY + m * (mathX2 - GRAPH.pointX);
            const ly2 = cy - (mathY2 - pY) * scaleY;

            lCtx.moveTo(lx1, ly1);
            lCtx.lineTo(lx2, ly2);
            lCtx.stroke();
        }


        // --- MAIN LOOP ---
        function loop() {
            // Update Canvas Size
            if (canvas.width !== window.innerWidth) {
                width = canvas.width = window.innerWidth;
                height = canvas.height = window.innerHeight;
            }

            // Update Physics
            if (GRAPH.mode === 'surf') {
                const slope = df(GRAPH.pointX);
                // Gravity accelerates down slope (negative gradient)
                const g = -0.01;
                const force = slope * g; // If slope + (uphill), force - (push back)
                // Actually skier wants to go down. 
                // If slope is +, needs to push left (-x).
                // Force = - slope * gravity_constant

                GRAPH.surferV += -slope * 0.005;
                GRAPH.surferV *= 0.95; // Friction
                GRAPH.pointX += GRAPH.surferV;

                // Bounds
                if (GRAPH.pointX > 8) { GRAPH.pointX = -8; GRAPH.surferV = 0; }
                if (GRAPH.pointX < -8) { GRAPH.pointX = 8; GRAPH.surferV = 0; }
            }

            ctx.clearRect(0, 0, width, height);

            drawGrid(ctx, width, height, GRAPH.scaleX, 0, 0);
            drawCurve(ctx, width, height, GRAPH.scaleX, GRAPH.scaleY);
            drawTangent(ctx, GRAPH.pointX);

            renderLens();

            // UI Updates
            updateHUD();

            time += 1;
            requestAnimationFrame(loop);
        }

        function updateHUD() {
            const x = GRAPH.pointX;
            const y = f(x);
            const m = df(x);

            document.getElementById('pos-val').innerText = `(${x.toFixed(2)}, ${y.toFixed(2)})`;
            document.getElementById('slope-val').innerText = m.toFixed(2);
            const eq = `y = ${m.toFixed(2)}x ${y - m * x >= 0 ? '+' : ''} ${(y - m * x).toFixed(2)}`;
            document.getElementById('tan-eq').innerText = eq;

            const icon = document.getElementById('slope-icon');
            if (m > 0.1) { icon.innerText = '↗'; icon.className = 'slope-box bg-emerald-500'; }
            else if (m < -0.1) { icon.innerText = '↘'; icon.className = 'slope-box bg-rose-500'; }
            else { icon.innerText = '→'; icon.className = 'slope-box bg-slate-400'; }
        }

        // --- INTERACTION ---
        let isDragging = false;

        window.setMode = (m) => {
            GRAPH.mode = m;
            document.querySelectorAll('.btn-tool').forEach(b => b.classList.remove('active'));
            if (m === 'drag') document.getElementById('btn-drag').classList.add('active');
            else document.getElementById('btn-surf').classList.add('active');
        }

        canvas.addEventListener('mousedown', e => {
            if (GRAPH.mode === 'drag') {
                isDragging = true;
                handleDrag(e);
            }
        });
        window.addEventListener('mousemove', e => {
            if (isDragging) handleDrag(e);
        });
        window.addEventListener('mouseup', () => isDragging = false);

        function handleDrag(e) {
            const m = toMath(e.clientX, e.clientY);
            GRAPH.pointX = m.x;
        }

        // Init Lens Canvas
        lensCvs.width = 240; lensCvs.height = 240;

        loop();

    </script>
</body>

</html>