<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Skila.ai | Optometry Lab</title>
    <!-- FONTS -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link
        href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;800&family=JetBrains+Mono:wght@400;600&display=swap"
        rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body,
        html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #F8FAFC;
            /* Clean Slate */
            font-family: 'Inter', sans-serif;
            user-select: none;
        }

        #sim-canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* UI OVERLAY */
        .ui-layer {
            position: absolute;
            inset: 0;
            pointer-events: none;
        }

        /* HUD PANEL */
        .hud-panel {
            position: absolute;
            top: 40px;
            right: 40px;
            width: 280px;
            pointer-events: auto;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .glass-card {
            background: rgba(255, 255, 255, 0.8);
            backdrop-filter: blur(16px);
            border: 1px solid rgba(255, 255, 255, 0.5);
            box-shadow: 0 10px 40px -10px rgba(0, 0, 0, 0.1);
            border-radius: 16px;
            padding: 20px;
            transition: transform 0.2s;
        }

        .metric {
            display: flex;
            justify-content: space-between;
            align-items: baseline;
            margin-bottom: 8px;
        }

        .metric-label {
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: #64748B;
            font-weight: 600;
        }

        .metric-val {
            font-family: 'JetBrains Mono', monospace;
            font-size: 16px;
            color: #0F172A;
            font-weight: 700;
        }

        /* PIP VIEW (The "Brain") */
        .pip-view {
            position: absolute;
            bottom: 40px;
            right: 40px;
            width: 240px;
            height: 160px;
            background: #000;
            border-radius: 12px;
            border: 4px solid #E2E8F0;
            box-shadow: 0 20px 50px rgba(0, 0, 0, 0.2);
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: auto;
        }

        .pip-label {
            position: absolute;
            top: 10px;
            left: 10px;
            color: rgba(255, 255, 255, 0.5);
            font-size: 10px;
            font-weight: 700;
            text-transform: uppercase;
        }

        .vision-target {
            font-size: 60px;
            color: #F59E0B;
            transition: filter 0.1s;
            /* Real-time blur */
            font-family: serif;
        }

        /* CONTROLS */
        .controls {
            position: absolute;
            bottom: 40px;
            left: 40px;
            pointer-events: auto;
            display: flex;
            gap: 12px;
        }

        .btn-mode {
            background: white;
            border: 1px solid #E2E8F0;
            padding: 10px 20px;
            border-radius: 99px;
            font-size: 12px;
            font-weight: 600;
            color: #475569;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .btn-mode:hover {
            transform: translateY(-2px);
        }

        .btn-mode.active {
            background: #0F172A;
            color: white;
            border-color: #0F172A;
        }

        .lens-toggle {
            position: absolute;
            top: 50%;
            left: 40px;
            transform: translateY(-50%);
            display: flex;
            flex-direction: column;
            gap: 8px;
            pointer-events: auto;
        }

        .btn-lens {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            border: 1px solid #CBD5E1;
            background: white;
            color: #64748B;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
        }

        .btn-lens:hover {
            transform: scale(1.1);
            color: #0EA5E9;
            border-color: #0EA5E9;
        }

        .btn-lens.active {
            background: #0EA5E9;
            color: white;
            border-color: #0EA5E9;
        }

        /* Draggable Candle Hint */
        .drag-hint {
            position: absolute;
            color: #94A3B8;
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            pointer-events: none;
            opacity: 0.6;
            margin-top: 60px;
        }
    </style>
</head>

<body>

    <canvas id="sim-canvas"></canvas>

    <div class="ui-layer">

        <!-- Stats -->
        <div class="hud-panel">
            <div class="glass-card">
                <div class="flex items-center gap-3 mb-4">
                    <div class="w-8 h-8 rounded-lg bg-indigo-50 flex items-center justify-center text-indigo-500">
                        <i class="fas fa-eye"></i>
                    </div>
                    <div>
                        <div class="text-[10px] text-slate-400 font-bold uppercase">Optometry HUD</div>
                        <div class="text-sm font-bold text-slate-800">Visual System</div>
                    </div>
                </div>

                <div class="metric">
                    <span class="metric-label">Accommodation</span>
                    <span class="metric-val text-blue-600" id="power-val">12.5 D</span>
                </div>
                <!-- Bar -->
                <div class="h-1 w-full bg-slate-100 rounded-full overflow-hidden mb-4">
                    <div id="acc-bar" class="h-full bg-blue-500 w-1/2 transition-all duration-100"></div>
                </div>

                <div class="metric">
                    <span class="metric-label">Object Dist.</span>
                    <span class="metric-val" id="dist-val">2.0 m</span>
                </div>

                <div class="metric">
                    <span class="metric-label">Diagnosis</span>
                    <span class="metric-val text-emerald-600" id="diag-val">Emmetropia</span>
                </div>
            </div>
        </div>

        <!-- PIP Vision -->
        <div class="pip-view">
            <div class="pip-label">Retinal Feed</div>
            <div id="vision-target" class="vision-target">A</div>
        </div>

        <!-- Condition Controls -->
        <div class="controls">
            <button class="btn-mode active" onclick="setCondition('normal')">Normal</button>
            <button class="btn-mode" onclick="setCondition('myopia')">Myopia (Short)</button>
            <button class="btn-mode" onclick="setCondition('hyperopia')">Hyperopia (Long)</button>
        </div>

        <!-- Corrective Lenses -->
        <div class="lens-toggle">
            <button class="btn-lens" onclick="toggleLens('minus')" title="Concave (Minus)">
                <i class="fas fa-minus"></i>
            </button>
            <button class="btn-lens" onclick="toggleLens('plus')" title="Convex (Plus)">
                <i class="fas fa-plus"></i>
            </button>
        </div>

    </div>

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

    <script>
        /**
         * SKILA.ai - Bio-Optical Simulation
         * - Ray Tracing Engine (Approximated geometric optics)
         * - Lens Accommodation Logic
         * - Vision Blur Simulation
         */

        const canvas = document.getElementById('sim-canvas');
        const ctx = canvas.getContext('2d');

        let width, height;
        let cx, cy;

        // --- STATE ---
        const SIM = {
            condition: 'normal', // normal, myopia, hyperopia
            lensType: null, // null, minus, plus
            objectX: 200,    // Draggable
            eyeL: 300,       // Eyeball Length (Axial Length)
            lensPower: 0,    // Dynamic
            isDragging: false
        };

        // --- OPTICAL CONFIG ---
        const OPTICS = {
            focalLengthNormal: 300,  // Match the visual eye length
            corneaPower: 1.5,        // Static Ray bend
            accommodationRange: 200, // How much the lens can squeeze
        };

        // Object (Source)
        const OBJ = {
            x: 100, y: 0, // y relative to center
            size: 40
        };

        function resize() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
            cx = width * 0.6; // Eye Center X
            cy = height / 2;
            OBJ.y = cy;
            // Limit Object
            if (OBJ.x > cx - 200) OBJ.x = cx - 200;
        }

        // --- RENDER GEOMETRY ---

        function drawEye() {
            ctx.lineJoin = 'round';
            ctx.lineCap = 'round';

            // 1. SCLERA (Outer Shell)
            // Shape depends on condition (Myopia = Long, Hyperopia = Short)
            let eyeLen = SIM.eyeL;
            if (SIM.condition === 'myopia') eyeLen = 380;
            if (SIM.condition === 'hyperopia') eyeLen = 220;

            const eyeH = 240; // Height of eye

            ctx.beginPath();
            // Cornea Bulge
            ctx.arc(cx - 130, cy, 140, 2.5, 3.78); // Front arc
            // Top/Bottom/Back
            ctx.quadraticCurveTo(cx + eyeLen, cy - eyeH / 1.5, cx + eyeLen, cy); // Top to Back
            ctx.quadraticCurveTo(cx + eyeLen, cy + eyeH / 1.5, cx - 130, cy + 80); // Back to Bottom

            ctx.fillStyle = 'white';
            ctx.strokeStyle = '#E2E8F0';
            ctx.lineWidth = 4;
            ctx.shadowBlur = 30; ctx.shadowColor = 'rgba(0,0,0,0.05)';
            ctx.fill(); ctx.stroke();
            ctx.shadowBlur = 0;

            // Retina Wall (The receptor)
            // It's the back inner curve
            const retinaX = cx + eyeLen - 20;
            const focusError = calculateFocusError(retinaX);

            // Draw Retina Sensor
            ctx.beginPath();
            ctx.arc(retinaX - 400, cy, 400, -0.3, 0.3); // Slight curve
            ctx.lineWidth = 8;
            ctx.strokeStyle = '#1E293B';
            ctx.stroke();

            // Glow if focused
            if (Math.abs(focusError) < 20) {
                ctx.strokeStyle = '#F59E0B'; // Gold hit
                ctx.lineWidth = 4;
                ctx.shadowColor = '#F59E0B'; ctx.shadowBlur = 20;
                ctx.stroke(); ctx.shadowBlur = 0;
            }

            // 2. INTERNAL STRUCTURES
            // Iris / Ciliary
            const irisY = 90;
            ctx.fillStyle = '#64748B';
            // Top Iris
            ctx.beginPath(); ctx.moveTo(cx - 100, cy - 120); ctx.lineTo(cx - 100, cy - 50); ctx.lineWidth = 10; ctx.stroke();
            // Bottom Iris
            ctx.beginPath(); ctx.moveTo(cx - 100, cy + 120); ctx.lineTo(cx - 100, cy + 50); ctx.stroke();

            // 3. CRYSTALLINE LENS (Dynamic Shape)
            // Accommodation: Closer object = Thicker Lens
            const dist = (cx - 100) - OBJ.x;
            const normDist = Math.max(0, Math.min(1, dist / 800)); // 0 (Close) to 1 (Far)

            // Lens curvature
            // Far = Flat (Thin)
            // Close = Round (Thick)
            const lensThick = 20 + (1 - normDist) * 30; // 20 to 50
            const lensH = 100;

            SIM.lensPower = (1 - normDist) * 100; // For UI

            ctx.beginPath();
            ctx.ellipse(cx - 80, cy, lensThick, lensH / 2, 0, 0, Math.PI * 2);

            // Lens Material
            const grad = ctx.createRadialGradient(cx - 80, cy - 20, 0, cx - 80, cy, 60);
            grad.addColorStop(0, 'rgba(255,255,255,0.9)');
            grad.addColorStop(1, 'rgba(200, 240, 255, 0.6)');
            ctx.fillStyle = grad;
            ctx.strokeStyle = '#BAE6FD';
            ctx.lineWidth = 2;
            ctx.fill(); ctx.stroke();

            // 4. CORRECTIVE LENS (Optional)
            if (SIM.lensType) {
                drawCorrectiveLens(SIM.lensType);
            }

            return retinaX;
        }

        function drawCorrectiveLens(type) {
            const lx = cx - 200;
            ctx.fillStyle = 'rgba(200, 230, 255, 0.3)';
            ctx.strokeStyle = '#38BDF8';
            ctx.lineWidth = 2;

            ctx.beginPath();
            if (type === 'minus') { // Concave (Myopia fix)
                ctx.moveTo(lx, cy - 60);
                ctx.quadraticCurveTo(lx + 10, cy, lx, cy + 60);
                ctx.lineTo(lx - 10, cy + 60);
                ctx.quadraticCurveTo(lx, cy, lx - 10, cy - 60);
            } else { // Convex (Hyperopia fix)
                ctx.moveTo(lx, cy - 60);
                ctx.quadraticCurveTo(lx - 20, cy, lx, cy + 60);
                ctx.lineTo(lx + 10, cy + 60);
                ctx.quadraticCurveTo(lx + 30, cy, lx + 10, cy - 60);
            }
            ctx.closePath();
            ctx.fill(); ctx.stroke();
        }

        function drawRays(retinaX) {
            // 1. Ray Casting Source
            const rays = 12;
            const spread = 40; // Height of object source

            ctx.strokeStyle = '#F59E0B'; // Laser Amber
            ctx.lineWidth = 2;

            // Physics Calc
            // Ideal focal point calculation
            // F = 1/P.  We approximate geometric intersection.

            // Accommodation attempts to focus on Retina
            // Ideal focus distance determined by Lens Thickness logic
            // But if Myopia/Hyperopia, the eye length mismatches correct focus

            // Calculate Converge Point
            let convergeX = cx + 280; // Default Emmetropia

            // Accommodation Offset (Object Closeness pulls focus back)
            // Lens works harder to keep it at 280.
            const objDist = (cx - 100) - OBJ.x; // e.g. 500

            // Physics: 1/f = 1/do + 1/di
            // We simulate: The Lens changes f to keep di constant (at retina).
            // But it has limits.

            let focusShift = 0;
            // If Corrective Lens
            if (SIM.lensType === 'minus') convergeX += 60; // Pushes focus back
            if (SIM.lensType === 'plus') convergeX -= 60; // Pulls focus forward

            // Conditions
            let actualRetina = retinaX;
            // The convergeX represents where the rays crossover.

            // Accomodation Logic:
            // We assume the lens is perfect at putting image at "Normal Retina" (cx + 300)
            // UNLESS object is too close for limit.

            if (objDist < 100) {
                // Too close, lens maxed out. Focus falls BEHIND retina?
                // Actually close object -> Focus pushes BeHIND retina if lens can't curve enough.
                convergeX += (100 - objDist) * 2;
            }

            // Draw Rays
            ctx.globalCompositeOperation = 'screen';
            ctx.shadowColor = '#F59E0B'; ctx.shadowBlur = 10;

            for (let i = 0; i <= rays; i++) {
                const ky = (i / rays - 0.5) * OBJ.size * 2; // Source Y spread
                const sy = OBJ.y + ky;

                ctx.beginPath();
                ctx.moveTo(OBJ.x, sy);

                // Hit Lens plane (approx)
                const lensX = cx - 100;
                // Hit height at lens (simple similar triangles)
                // Actually we just draw straigth to lens surface
                const ly = cy + ky * 0.5; // Convergence begins? No, parallel rays?
                // Let's model simpler: Rays diverge from Object

                // Intersect Lens Surface
                // We fake the midpoint bend for visual clarity
                const bendY = cy + (sy - cy) * 0.2; // Refracted height at lens center

                ctx.lineTo(cx - 80, bendY); // Hit Lens

                // To Focal Point
                ctx.lineTo(convergeX, cy); // Converge

                // Continue past
                ctx.lineTo(convergeX + (convergeX - (cx - 80)), cy - (bendY - cy));

                ctx.stroke();
            }

            ctx.shadowBlur = 0;
            ctx.globalCompositeOperation = 'source-over';

            // Return "Blur" factor
            // Distance between Converge Point and Actual Retina
            return Math.abs(convergeX - actualRetina);
        }

        // --- OBJECT ---
        function drawObject() {
            ctx.fillStyle = '#F59E0B';
            ctx.font = '40px Serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText("A", OBJ.x, OBJ.y);

            // Drag handle
            ctx.beginPath();
            ctx.arc(OBJ.x, OBJ.y, 30, 0, Math.PI * 2);
            ctx.strokeStyle = SIM.isDragging ? 'white' : 'rgba(255,255,255,0.2)';
            ctx.lineWidth = 1;
            ctx.setLineDash([4, 4]);
            ctx.stroke();
            ctx.setLineDash([]);

            // Candle flame effect (Particle source)
            ctx.fillStyle = 'rgba(245, 158, 11, 0.2)';
            ctx.beginPath(); ctx.arc(OBJ.x, OBJ.y, 40 + Math.sin(Date.now() / 200) * 5, 0, Math.PI * 2); ctx.fill();
        }

        function calculateFocusError(retinaX) {
            // Helper to determine blur amount
            // Based on ray intersection
            return 0; // Handled in draw loop
        }

        // --- LOOP ---
        function loop() {
            ctx.clearRect(0, 0, width, height);

            // Draw Object
            drawObject();

            // Draw Eye
            const retinaX = drawEye();

            // Draw Rays & Get Blur
            const blurDist = drawRays(retinaX);

            // Update UI
            updateHUD(blurDist);

            requestAnimationFrame(loop);
        }

        function updateHUD(blur) {
            // Update Power Bar
            const elem = document.getElementById('acc-bar');
            elem.style.width = `${SIM.lensPower}%`;
            document.getElementById('power-val').innerText = (10 + (SIM.lensPower / 10)).toFixed(1) + " D";

            // Object Dist
            const m = ((cx - 100 - OBJ.x) / 100).toFixed(1);
            document.getElementById('dist-val').innerText = m + " m";

            // Diagnosis
            const d = document.getElementById('diag-val');
            if (SIM.condition === 'normal') { d.innerText = "Emmetropia (Ideal)"; d.className = "metric-val text-emerald-500"; }
            if (SIM.condition === 'myopia') { d.innerText = "Myopia (Long)"; d.className = "metric-val text-rose-500"; }
            if (SIM.condition === 'hyperopia') { d.innerText = "Hyperopia (Short)"; d.className = "metric-val text-indigo-500"; }

            // Update Vision PIP Blur
            const v = document.getElementById('vision-target');
            // Blur px
            const bPx = Math.min(20, blur * 0.1);
            v.style.filter = `blur(${bPx}px)`;

            if (bPx < 2) v.style.color = '#10B981'; // Green when sharp
            else v.style.color = '#F59E0B';
        }


        // --- INPUT ---
        window.addEventListener('mousedown', e => {
            const dx = e.clientX - OBJ.x;
            const dy = e.clientY - OBJ.y;
            if (dx * dx + dy * dy < 1600) SIM.isDragging = true;
        });
        window.addEventListener('mousemove', e => {
            if (SIM.isDragging) {
                OBJ.x = e.clientX;
                if (OBJ.x > cx - 150) OBJ.x = cx - 150; // Min dist
                if (OBJ.x < 50) OBJ.x = 50; // Max dist
            }
        });
        window.addEventListener('mouseup', () => SIM.isDragging = false);
        window.addEventListener('resize', resize);

        // API
        window.setCondition = (c) => {
            SIM.condition = c;
            // Reset Lenses
            SIM.lensType = null;
            document.querySelectorAll('.btn-mode').forEach(b => b.classList.remove('active'));
            event.target.classList.add('active');
            updateLensUI();
        };

        window.toggleLens = (pc) => {
            if (SIM.lensType === pc) SIM.lensType = null;
            else SIM.lensType = pc;
            updateLensUI();
        };

        function updateLensUI() {
            document.querySelectorAll('.btn-lens').forEach(b => b.classList.remove('active'));
            if (SIM.lensType === 'minus') document.querySelector('.btn-lens[onclick*="minus"]').classList.add('active');
            if (SIM.lensType === 'plus') document.querySelector('.btn-lens[onclick*="plus"]').classList.add('active');
        }

        // Init
        resize();
        loop();

    </script>
</body>

</html>