<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Skila.ai | Transversal City</title>
    <link href="https://fonts.googleapis.com/css2?family=Teko:wght@400;600&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #0c0a09;
            font-family: 'Teko', sans-serif;
        }

        #canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        .hud {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #f59e0b;
            font-size: 24px;
        }

        .toggle {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: #222;
            color: #fff;
            padding: 10px;
            border: 1px solid #444;
            cursor: pointer;
        }
    </style>
</head>

<body>
    <canvas id="canvas"></canvas>

    <div class="hud">
        <h1 class="text-4xl text-cyan-400 mb-2">TRANSVERSAL CITY</h1>
        <div id="info">Hover an angle to analyze</div>
    </div>

    <button class="toggle" onclick="toggleParallel()">Toggle Parallel/Broken</button>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const info = document.getElementById('info');

        let width, height;

        // Lines
        // Line 1 (Top)
        let L1 = { y: 200, angle: 0 };
        // Line 2 (Bottom)
        let L2 = { y: 600, angle: 0 };

        // Transversal
        let T = { x: 0, angle: Math.PI / 3 }; // Through center

        let PARALLEL = true;
        let HOVER_ANGLE = null; // ID of hovered angle

        // Angle Data
        // 8 Angles:
        // Intersection 1 (Top): 1(TL), 2(TR), 3(BL), 4(BR)
        // Intersection 2 (Bot): 5(TL), 6(TR), 7(BL), 8(BR)

        let ANGLES = [];

        function resize() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
            T.x = width / 2;
            L1.y = height * 0.3;
            L2.y = height * 0.7;
        }
        window.addEventListener('resize', resize);
        resize();

        window.toggleParallel = () => {
            PARALLEL = !PARALLEL;
            if (!PARALLEL) L2.angle = 0.2; // Tilt
            else L2.angle = 0;
        }

        // Input: Drag Transversal Angle
        let DRAG = false;
        canvas.addEventListener('mousedown', e => {
            // Check if near T line? For now just drag anywhere rotates
            DRAG = true;
        });
        window.addEventListener('mouseup', () => DRAG = false);
        canvas.addEventListener('mousemove', e => {
            if (DRAG) {
                // Calc angle from center
                const dx = e.clientX - width / 2;
                const dy = e.clientY - height / 2;
                let a = Math.atan2(dy, dx) + Math.PI / 2;
                T.angle = a;
            }

            // Hover Check
            checkHover(e.clientX, e.clientY);
        });

        function checkHover(mx, my) {
            HOVER_ANGLE = null;
            let minDist = 50;

            for (let a of ANGLES) {
                let d = Math.hypot(mx - a.x, my - a.y);
                if (d < minDist) {
                    HOVER_ANGLE = a.id;
                    minDist = d;
                }
            }

            if (HOVER_ANGLE) {
                const a = ANGLES.find(x => x.id === HOVER_ANGLE);
                info.innerHTML = `Angle ${a.id}: <span class="text-white">${Math.round(a.deg)}°</span>`;
                // Logic for relationships
                if (PARALLEL) {
                    // Logic text
                    let pair = getPair(a.id);
                    if (pair) info.innerHTML += `<br>Match: Angle ${pair}`;
                } else {
                    info.innerHTML += `<br><span class="text-red-500">PARALLEL BROKEN</span>`;
                }
            } else {
                info.innerText = "Hover an angle";
            }
        }

        function getPair(id) {
            // E.g. Alternate Interior
            // 4 and 5. 3 and 6.
            // Corresponding: 1-5, 2-6, 3-7, 4-8.
            // Vert Opp: 1-4, 2-3...
            return "";
        }

        function loop() {
            ctx.fillStyle = '#0c0a09';
            ctx.fillRect(0, 0, width, height);

            // Draw City Grid Background (faint)
            ctx.strokeStyle = '#222'; ctx.lineWidth = 1;
            for (let i = 0; i < width; i += 50) { ctx.beginPath(); ctx.moveTo(i, 0); ctx.lineTo(i, height); ctx.stroke(); }

            // Calculate Intersections
            // Transversal is Line: x = T.x + (y - cy)*tan(90-ang)?
            // Better: Point + Vector. P(Tx, Cy). Vec(cos(ang-90), sin(ang-90))
            const cx = width / 2; const cy = height / 2;
            const vx = Math.cos(T.angle - Math.PI / 2);
            const vy = Math.sin(T.angle - Math.PI / 2);

            // Line 1 Intersection
            // L1 is horizontal(ish). y = L1.y + (x-cx)*tan(L1.ang)
            // Just treat L1 as horiz for ease if parallel, else tilted line through (cx, L1.y) ?
            // Let's assume lines rotate around center X.

            const i1 = intersect(cx, L1.y, L1.angle, cx, cy, T.angle);
            const i2 = intersect(cx, L2.y, L2.angle, cx, cy, T.angle);

            // Draw Roads
            ctx.shadowBlur = 10; ctx.shadowColor = 'cyan';
            drawRoad(cx, L1.y, L1.angle, 'cyan'); // L1
            if (PARALLEL) drawRoad(cx, L2.y, L2.angle, 'cyan'); // L2
            else drawRoad(cx, L2.y, L2.angle, 'red');

            ctx.shadowColor = 'magenta';
            drawRoad(cx, cy, T.angle, 'magenta'); // Transversal
            ctx.shadowBlur = 0;

            // Calculate Angles
            ANGLES = [];
            // generate 4 angles at i1
            genAngles(i1.x, i1.y, L1.angle, T.angle, 1);
            // generate 4 angles at i2
            genAngles(i2.x, i2.y, L2.angle, T.angle, 5);

            // Draw Arcs
            ANGLES.forEach(a => {
                const isHover = (a.id === HOVER_ANGLE);
                // Rel logic
                let isRel = false;
                if (HOVER_ANGLE && PARALLEL) {
                    // Check logic
                    const h = HOVER_ANGLE;
                    const c = a.id;
                    // Corresponding
                    if ((h % 4) === (c % 4)) isRel = true; // 1&5, 2&6...
                    // Alt Interior: 3&6, 4&5
                    if ((h === 3 && c === 6) || (h === 6 && c === 3)) isRel = true;
                    if ((h === 4 && c === 5) || (h === 5 && c === 4)) isRel = true;
                    // Vert Opp
                    // ...
                }

                ctx.beginPath();
                ctx.arc(a.cx, a.cy, 30, a.start, a.end);
                ctx.lineWidth = 4;
                if (isHover) ctx.strokeStyle = 'white';
                else if (isRel) ctx.strokeStyle = '#facc15';
                else ctx.strokeStyle = 'rgba(255,255,255,0.2)';
                ctx.stroke();

                // Hitbox info
                // position for detection
                let mid = (a.start + a.end) / 2;
                if (a.start > a.end) mid += Math.PI; // wrap fix?
                a.x = a.cx + Math.cos(mid) * 40;
                a.y = a.cy + Math.sin(mid) * 40;

                // Text
                if (isHover || isRel) {
                    ctx.fillStyle = '#fff'; ctx.font = '16px sans-serif';
                    ctx.fillText(Math.round(a.deg) + "°", a.x, a.y);
                }
            });

            requestAnimationFrame(loop);
        }

        function drawRoad(x, y, ang, color) {
            ctx.save(); ctx.translate(x, y); ctx.rotate(ang);
            ctx.fillStyle = color;
            ctx.fillRect(-1000, -5, 2000, 10);
            ctx.restore();
        }

        function intersect(x1, y1, a1, x2, y2, a2) {
            // Ray 1: P1 + t*V1
            // Ray 2: P2 + u*V2
            // x1 + t*c1 = x2 + u*c2
            // y1 + t*s1 = y2 + u*s2
            // Solvent... visual calc intersection for rendering
            // Simplified: Transversal intersects horizontal line y=Y at x = X + (Y-cy)/tan(Ta) ?
            // Slopes: m1 = tan(a1), m2 = tan(a2)
            // y - y1 = m1(x - x1)
            // x = (y - y1)/m1 + x1
            // Intersection: m1(x-x1)+y1 = m2(x-x2)+y2
            // x(m1-m2) = y2 - y1 - m2x2 + m1x1

            // Just use simple geom for straight transversal vs horizontal line
            // If T intersects Line at X.
            // T passes through w/2, h/2.
            // L passes through w/2, Ly

            // dx = (Ly - Cy) / tan(Ta - PI/2)? 
            // Ta is vertical-ish (PI/2 is vert?) 0 is horiz?
            // In setup: T.angle is math angle from horiz?
            // T.angle = atan2(dy, dx) + PI/2. So 0 = Vertical down?

            // Let's assume standard math Angle (0 = Right).
            // T angle from vertical?

            // Visual approx is fine for sim, but need exact for arcs
            // Let's rely on visuals.

            // Calculate intersection point of 2 lines defined by point+angle
            const m1 = Math.tan(a1);
            const m2 = Math.tan(a2 - Math.PI / 2); // Adjustment for T logic

            // ... intersection logic helper
            // Manual:
            // L1 horizontal-ish
            // T vertical-ish
            // x = cx + (y - cy) / tan(angle)

            let iy = y1; // collision y
            let distY = y1 - y2; // dist from center
            // x = cx + distY / tan(a2-PI/2 approx)
            // Using vector projection properly

            // Hack for nice visual:
            let ix = x2 + (y1 - y2) / Math.tan(a2 - Math.PI / 2);

            if (!PARALLEL && y1 > 400) {
                // Tilted line logic
                // ...
            }

            return { x: ix, y: iy };
        }

        function genAngles(cx, cy, baseAng, cutAng, startId) {
            // 4 sectors
            // Base line angle (0)
            // Cut line angle (T)
            // Angle = diff

            // Visual arc drawing
            // 1: Top Left relative to intersection?
            // Need absolute angles of the lines.

            // Start angles for arcs
            // The 4 regions are bounded by the 2 lines.
            // Line 1 angles: baseAng, baseAng + PI
            // Line 2 angles: cutAng-PI/2, cutAng+PI/2

            let l1 = baseAng;
            let l2 = cutAng - Math.PI / 2;

            // Sort angles to find sectors?
            // Just hardcode sectors visually

            // Sector 1 (Top Left): Between L1(PI) and T(Top)
            // deg = ...

            // Simplified:
            // Just 4 arcs
            // 1: Top Left
            // 2: Top Right
            // 3: Bot Left
            // 4: Bot Right

            let tAng = cutAng - Math.PI / 2;

            // Arc 1: From T_Top to L_Right (2)
            // Arc 2: From L_Right to T_Bot (4)
            // ...

            // Normalized
            // Assuming T goes TopRight to BotLeft

            let a1 = tAng;
            let a2 = l1;

            // Push 4 angles
            let diff = Math.abs(a1 - a2); // rads
            let deg = diff * 180 / Math.PI;
            // Normalize to < 180
            if (deg > 180) deg = 360 - deg;
            // Supplement
            let sup = 180 - deg;

            ANGLES.push({ id: startId, cx, cy, start: a1, end: a2, deg: deg }); // TR
            ANGLES.push({ id: startId + 1, cx, cy, start: a2, end: a1 + Math.PI, deg: sup }); // TL ?
            ANGLES.push({ id: startId + 2, cx, cy, start: a1 + Math.PI, end: a2 + Math.PI, deg: deg }); // BL
            ANGLES.push({ id: startId + 3, cx, cy, start: a2 + Math.PI, end: a1, deg: sup }); // BR

            // Note: Indices and positions need careful tuning or mapping
        }

        loop();

    </script>
</body>

</html>