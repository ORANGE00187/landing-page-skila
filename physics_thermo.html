<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Maxwell-Boltzmann: Statistical Mechanics Engine</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Share+Tech+Mono&family=Inter:wght@400;800&display=swap');

        :root {
            --bg: #050505;
            --panel: rgba(20, 25, 30, 0.9);
            --accent: #ffae00;
            --text: #a0a0a0;
        }

        body {
            margin: 0;
            overflow: hidden;
            background: var(--bg);
            font-family: 'Share Tech Mono', monospace;
            color: var(--text);
            user-select: none;
        }

        canvas {
            display: block;
        }

        #boot-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: #000;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            z-index: 99;
            transition: opacity 0.5s;
        }

        .boot-text {
            font-size: 24px;
            color: #fff;
            letter-spacing: 2px;
        }

        .boot-sub {
            color: #555;
            font-size: 12px;
            margin-top: 10px;
        }
    </style>
</head>

<body>

    <div id="boot-screen">
        <div class="boot-text">MAXWELL-BOLTZMANN ENGINE</div>
        <div class="boot-sub">INITIALIZING MICRO-STATE PARTITIONS...</div>
    </div>

    <canvas id="sim-canvas"></canvas>

    <!-- 
      THE ENGINE
      100% VANILLA JS. NO LIBRARIES.
    -->
    <script>
        /**
         * ====================================================================
         *  MAXWELL-BOLTZMANN ENGINE v1.0
         *  (c) 2025 Antigravity Dev
         *  
         *  Modules:
         *  1. MathLib (Vector2, Utils)
         *  2. SpatialGrid (Collision Optimization)
         *  3. PhysicsKernel (Particle Logic, Thermodynamics)
         *  4. StatsEngine (Histogram, Entropy Calc)
         *  5. UIEngine (Custom Canvas Controls)
         *  6. Renderer (Visuals)
         * ====================================================================
         */

        // CONFIGULATION
        const CONFIG = {
            particleCount: 1500,
            radius: 3,
            baseMass: 1,
            maxSpeed: 15,
            gridSize: 20, // Bucket size
            gravity: 0.15,
            viscosity: 0.999 // Air resistance
        };

        // ============================================
        // 1. MATH LIBRARY
        // ============================================

        class Vec2 {
            constructor(x = 0, y = 0) { this.x = x; this.y = y; }
            add(v) { return new Vec2(this.x + v.x, this.y + v.y); }
            sub(v) { return new Vec2(this.x - v.x, this.y - v.y); }
            mul(s) { return new Vec2(this.x * s, this.y * s); }
            div(s) { return new Vec2(this.x / s, this.y / s); }
            mag() { return Math.sqrt(this.x * this.x + this.y * this.y); }
            norm() { const m = this.mag(); return m === 0 ? new Vec2() : this.div(m); }
            distSq(v) { return (this.x - v.x) ** 2 + (this.y - v.y) ** 2; }
            dot(v) { return this.x * v.x + this.y * v.y; }
            clone() { return new Vec2(this.x, this.y); }
        }

        const Utils = {
            clamp: (v, min, max) => Math.max(min, Math.min(max, v)),
            rand: (min, max) => Math.random() * (max - min) + min,
            lerp: (a, b, t) => a + (b - a) * t,
            // Turbo Colormap (Fast approximation)
            percToColor: (t) => {
                // t: 0.0 (Cold/Blue) -> 1.0 (Hot/Red)
                // Turbo-ish gradient: Blue -> Cyan -> Green -> Yellow -> Red
                t = Utils.clamp(t, 0, 1);
                // 5 Stops
                const colors = [
                    [10, 10, 255],   // Deep Blue
                    [0, 255, 255],   // Cyan
                    [0, 255, 100],   // Green
                    [255, 255, 0],   // Yellow
                    [255, 50, 0]     // Red
                ];

                const idx = t * (colors.length - 1);
                const i = Math.floor(idx);
                const f = idx - i;

                if (isNaN(i)) return 'rgb(255,255,255)'; // Failsafe
                if (i < 0) return `rgb(${colors[0].join(',')})`;
                if (i >= colors.length - 1) return `rgb(${colors[colors.length - 1].join(',')})`;

                const c1 = colors[i];
                const c2 = colors[i + 1] || colors[colors.length - 1];

                const r = c1[0] + (c2[0] - c1[0]) * f;
                const g = c1[1] + (c2[1] - c1[1]) * f;
                const b = c1[2] + (c2[2] - c1[2]) * f;
                return `rgb(${Math.floor(r)},${Math.floor(g)},${Math.floor(b)})`;
            }
        };

        // ============================================
        // 2. SPATIAL PARTITIONING (HASH GRID)
        // ============================================

        class SpatialHash {
            constructor(cellSize) {
                this.cellSize = cellSize;
                this.cells = new Map();
            }

            key(x, y) {
                const cx = Math.floor(x / this.cellSize);
                const cy = Math.floor(y / this.cellSize);
                return `${cx},${cy}`;
            }

            clear() {
                this.cells.clear();
            }

            add(particle) {
                const k = this.key(particle.pos.x, particle.pos.y);
                if (!this.cells.has(k)) this.cells.set(k, []);
                this.cells.get(k).push(particle);
            }

            // Get nearby particles (9 cells)
            getNearby(particle) {
                const neighbors = [];
                const cx = Math.floor(particle.pos.x / this.cellSize);
                const cy = Math.floor(particle.pos.y / this.cellSize);

                for (let x = -1; x <= 1; x++) {
                    for (let y = -1; y <= 1; y++) {
                        const k = `${cx + x},${cy + y}`;
                        if (this.cells.has(k)) {
                            const siblings = this.cells.get(k);
                            for (let s of siblings) neighbors.push(s);
                        }
                    }
                }
                return neighbors;
            }
        }

        // ============================================
        // 3. PHYSICS KERNEL
        // ============================================

        class Particle {
            constructor(x, y) {
                this.pos = new Vec2(x, y);
                this.vel = new Vec2(Utils.rand(-2, 2), Utils.rand(-2, 2));
                this.radius = CONFIG.radius; // radius variance?
                this.mass = CONFIG.baseMass;
                this.color = '#fff';
            }

            update(dt, width, height, engineState) {
                // Apply Gravity if Active
                if (engineState.gravity) {
                    this.vel.y += CONFIG.gravity;
                }

                // Interaction Tools
                if (engineState.interaction.active) {
                    const tool = engineState.interaction;
                    const dist = this.pos.distSq(tool.pos);
                    const rangeSq = 100 * 100;
                    if (dist < rangeSq) {
                        const dir = this.pos.sub(tool.pos).norm();
                        if (tool.type === 'heat') {
                            this.vel = this.vel.add(dir.mul(0.8)); // Repel/Excite
                        } else if (tool.type === 'cryo') {
                            this.vel = this.vel.mul(0.90); // Dampen
                        }
                    }
                }

                // Move
                this.pos = this.pos.add(this.vel.mul(dt));

                // Walls
                // Chamber Logic: Mid-Screen Wall with Door
                // Door: Center hole of 100px ??
                const centerWallX = width / 2;
                const doorSize = 100;
                const doorY = height / 2;

                // Are we hitting the outer bounds?
                if (this.pos.x < this.radius) { this.pos.x = this.radius; this.vel.x *= -1; }
                if (this.pos.x > width - this.radius) { this.pos.x = width - this.radius; this.vel.x *= -1; }
                if (this.pos.y < this.radius) { this.pos.y = this.radius; this.vel.y *= -1; }
                if (this.pos.y > height - this.radius) { this.pos.y = height - this.radius; this.vel.y *= -0.8; } // Floor friction

                // The Partition Wall
                const midDist = Math.abs(this.pos.x - centerWallX);
                if (midDist < this.radius + 5) {
                    // Check if inside Door
                    const inDoor = Math.abs(this.pos.y - doorY) < doorSize / 2;

                    // MAXWELL'S DEMON LOGIC
                    if (inDoor && engineState.demonMode) {
                        // Left Chamber is COLD, Right is HOT
                        const isHot = this.vel.mag() > 5;
                        const onLeft = this.pos.x < centerWallX;

                        let allowPass = false;
                        if (onLeft && isHot && this.vel.x > 0) allowPass = true; // Let Hot go Right
                        if (!onLeft && !isHot && this.vel.x < 0) allowPass = true; // Let Cold go Left

                        if (!allowPass) {
                            // Bounce back
                            this.vel.x *= -1;
                        }
                    } else if (!inDoor) {
                        // Hit solid wall part
                        if (this.pos.x < centerWallX) this.pos.x = centerWallX - this.radius;
                        else this.pos.x = centerWallX + this.radius;
                        this.vel.x *= -1;
                    }
                }

                // Color update based on KE speed
                const speed = this.vel.mag();
                const t = speed / CONFIG.maxSpeed;
                this.color = Utils.percToColor(t);

                // Global Viscosity
                //this.vel = this.vel.mul(CONFIG.viscosity);
            }
        }

        class PhysicsEngine {
            constructor() {
                this.particles = [];
                this.grid = new SpatialHash(CONFIG.gridSize);
                this.state = {
                    gravity: false,
                    demonMode: false,
                    interaction: { active: false, type: null, pos: new Vec2() },
                    avgEnergy: 0,
                    entropy: 0
                };
            }

            init(width, height) {
                this.particles = [];
                for (let i = 0; i < CONFIG.particleCount; i++) {
                    // Spawn random side
                    const x = Math.random() < 0.5 ? Utils.rand(20, width / 2 - 20) : Utils.rand(width / 2 + 20, width - 20);
                    this.particles.push(new Particle(x, Utils.rand(20, height - 20)));
                }
            }

            update(width, height) {
                this.grid.clear();
                let totalKE = 0;

                // 1. Move & Grid Sort
                for (let p of this.particles) {
                    p.update(1.0, width, height, this.state); // dt = 1
                    this.grid.add(p);
                    totalKE += 0.5 * p.mass * p.vel.mag() ** 2;
                }

                this.state.avgEnergy = totalKE / this.particles.length;

                // 2. Resolve Collisions (Spatial Hash)
                for (let p1 of this.particles) {
                    const neighbors = this.grid.getNearby(p1);
                    for (let p2 of neighbors) {
                        if (p1 === p2) continue;

                        // Check Collision
                        let dSq = p1.pos.distSq(p2.pos);
                        const rSum = p1.radius + p2.radius;

                        if (dSq < rSum * rSum) {
                            // Resolve Overlap
                            let dist = Math.sqrt(dSq);

                            // NaN Safety: Exact overlap handling
                            if (dist < 0.0001) {
                                p2.pos.x += 0.1; // Jitter to separate
                                dSq = p1.pos.distSq(p2.pos);
                                dist = Math.sqrt(dSq);
                            }

                            const overlap = rSum - dist;
                            const norm = p2.pos.sub(p1.pos).div(dist);

                            // Separate
                            const separation = norm.mul(overlap * 0.5);
                            p1.pos = p1.pos.sub(separation);
                            p2.pos = p2.pos.add(separation);

                            // Elastic Collision Response
                            // v1' = v1 - (2m2/(m1+m2)) * dot(v1-v2, r1-r2)/|r1-r2|^2 * (r1-r2)
                            const v1 = p1.vel;
                            const v2 = p2.vel;
                            const x1mx2 = p1.pos.sub(p2.pos);
                            const x2mx1 = p2.pos.sub(p1.pos);

                            const dot1 = v1.sub(v2).dot(x1mx2);
                            const dot2 = v2.sub(v1).dot(x2mx1);

                            // Avoid divide by zero
                            const safeDSq = dSq < 0.0001 ? 0.0001 : dSq;

                            p1.vel = v1.sub(x1mx2.mul(dot1 / safeDSq));
                            p2.vel = v2.sub(x2mx1.mul(dot2 / safeDSq));
                        }
                    }
                }
            }
        }

        // ============================================
        // 4. STATS ENGINE & UI MAPPER
        // ============================================

        class StatsEngine {
            constructor() {
                this.bins = new Array(20).fill(0);
                this.history = [];
            }

            update(particles) {
                this.bins.fill(0);
                for (let p of particles) {
                    const s = p.vel.mag();
                    const i = Math.min(this.bins.length - 1, Math.floor(s / (CONFIG.maxSpeed / this.bins.length)));
                    this.bins[i]++;
                }

                // Track "Entropy" approx (based on sorted-ness of chambers)
                // Low Entropy = Hot on one side, Cold on other
                // High Entropy = Mixed
                let leftKE = 0, rightKE = 0;
                let leftCount = 0, rightCount = 0;
                const mid = window.innerWidth / 2;

                particles.forEach(p => {
                    const ke = p.vel.mag() ** 2;
                    if (p.pos.x < mid) { leftKE += ke; leftCount++; }
                    else { rightKE += ke; rightCount++; }
                });

                const avgL = leftCount ? leftKE / leftCount : 0;
                const avgR = rightCount ? rightKE / rightCount : 0;
                const diff = Math.abs(avgL - avgR); // Higher diff = Lower disorder?
                const entropy = 1.0 - Utils.clamp(diff / 20, 0, 1);

                this.history.push(entropy);
                if (this.history.length > 200) this.history.shift();
            }
        }

        // ============================================
        // 5. UI ENGINE (CUSTOM CANVAS CONTROLS)
        // ============================================

        class UIEngine {
            constructor(width, height) {
                this.components = [];
            }

            addButton(x, y, w, h, label, onClick, isActiveRef) {
                this.components.push({
                    type: 'button',
                    rect: { x, y, w, h },
                    label: label,
                    click: onClick,
                    isActive: isActiveRef,
                    hover: false
                });
            }

            handleMouse(x, y, down) {
                let hit = false;
                for (let c of this.components) {
                    if (x > c.rect.x && x < c.rect.x + c.rect.w && y > c.rect.y && y < c.rect.y + c.rect.h) {
                        c.hover = true;
                        if (down && c.click) c.click();
                        hit = true;
                    } else {
                        c.hover = false;
                    }
                }
                return hit;
            }

            draw(ctx) {
                ctx.font = '12px "Share Tech Mono"';

                for (let c of this.components) {
                    const active = c.isActive ? c.isActive() : false;

                    ctx.fillStyle = active ? '#ffae00' : (c.hover ? '#444' : '#222');
                    ctx.strokeStyle = '#555';
                    ctx.fillRect(c.rect.x, c.rect.y, c.rect.w, c.rect.h);
                    ctx.strokeRect(c.rect.x, c.rect.y, c.rect.w, c.rect.h);

                    ctx.fillStyle = active ? '#000' : '#fff';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(c.label, c.rect.x + c.rect.w / 2, c.rect.y + c.rect.h / 2);
                }
            }
        }

        // ============================================
        // 6. MAIN RENDERER & LOOP
        // ============================================

        const canvas = document.getElementById('sim-canvas');
        const ctx = canvas.getContext('2d', { alpha: false }); // Opt
        let width, height;

        const engine = new PhysicsEngine();
        const stats = new StatsEngine();
        const ui = new UIEngine();
        let mousePos = new Vec2();

        function init() {
            resize();
            engine.init(width, height);

            // Build UI
            // Bottom Toolbar
            const cx = width / 2;
            const y = height - 60;

            ui.addButton(cx - 200, y, 90, 40, "GRAVITY", () => engine.state.gravity = !engine.state.gravity, () => engine.state.gravity);
            ui.addButton(cx - 100, y, 90, 40, "DEMON", () => engine.state.demonMode = !engine.state.demonMode, () => engine.state.demonMode);
            ui.addButton(cx, y, 90, 40, "HEAT GUN", () => engine.state.interaction.type = 'heat', () => engine.state.interaction.type === 'heat');
            ui.addButton(cx + 100, y, 90, 40, "CRYO BEAM", () => engine.state.interaction.type = 'cryo', () => engine.state.interaction.type === 'cryo');

            window.addEventListener('resize', resize);

            // Interaction
            canvas.addEventListener('mousedown', e => {
                mousePos.x = e.clientX; mousePos.y = e.clientY;
                const hit = ui.handleMouse(e.clientX, e.clientY, true);
                if (!hit && engine.state.interaction.type) {
                    engine.state.interaction.active = true;
                }
            });
            window.addEventListener('mousemove', e => {
                mousePos.x = e.clientX; mousePos.y = e.clientY;
                ui.handleMouse(e.clientX, e.clientY, false);
                engine.state.interaction.pos.x = e.clientX;
                engine.state.interaction.pos.y = e.clientY;
            });
            window.addEventListener('mouseup', () => engine.state.interaction.active = false);

            requestAnimationFrame(loop);

            // Boot fade
            setTimeout(() => document.getElementById('boot-screen').style.opacity = 0, 1000);
            setTimeout(() => document.getElementById('boot-screen').style.display = 'none', 1500);
        }

        function resize() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
        }

        function loop() {
            // Logic
            engine.update(width, height);
            stats.update(engine.particles);

            // Render
            ctx.fillStyle = '#050505';
            ctx.fillRect(0, 0, width, height);

            // Draw Wall/Chamber
            ctx.strokeStyle = '#444';
            ctx.lineWidth = 4;
            // Divider
            ctx.beginPath();
            ctx.moveTo(width / 2, 0); ctx.lineTo(width / 2, height / 2 - 50);
            ctx.moveTo(width / 2, height / 2 + 50); ctx.lineTo(width / 2, height);
            ctx.stroke();

            // Door
            if (engine.state.demonMode) {
                ctx.strokeStyle = '#ffae00';
                ctx.shadowColor = '#ffae00'; ctx.shadowBlur = 10;
                ctx.strokeRect(width / 2 - 5, height / 2 - 50, 10, 100);
                ctx.shadowBlur = 0;
            }

            // Draw Particles (Glow)
            // Batching same-colored particles is theoretically faster but dynamic colors sort of kill that.
            // Just raw draw for 1500 is fine on modern canvas.

            for (let p of engine.particles) {
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(p.pos.x, p.pos.y, p.radius, 0, Math.PI * 2);
                ctx.fill();
            }

            // Bloom Overlay (Fake Bloom or Composite)
            // ctx.globalCompositeOperation = 'screen';
            // ctx.drawImage(canvas, 0, 0); 
            // Realtime bloom too slow for simple canvas without offscreen? 
            // We'll skip full screen bloom for performant 60fps.

            // Draw UI Overlays (Stats)
            // Histogram
            ctx.fillStyle = 'rgba(20,20,20,0.8)';
            ctx.fillRect(20, 20, 300, 150);
            ctx.strokeStyle = '#555'; ctx.strokeRect(20, 20, 300, 150);

            ctx.fillStyle = '#aaa';
            ctx.font = '10px "Share Tech Mono"';
            ctx.fillText("SPEED DISTRIBUTION (MAXWELL-BOLTZMANN)", 30, 35);

            const maxBin = Math.max(...stats.bins);
            const barnWidth = 280 / stats.bins.length;

            ctx.fillStyle = '#ffae00';
            for (let i = 0; i < stats.bins.length; i++) {
                const h = (stats.bins[i] / maxBin) * 100;
                ctx.fillRect(30 + i * barnWidth, 160 - h, barnWidth - 1, h);
            }

            // Stats Text
            ctx.fillStyle = '#fff';
            ctx.fillText(`COUNT: ${CONFIG.particleCount}`, 30, 185);
            ctx.fillText(`TEMP (Avg KE): ${engine.state.avgEnergy.toFixed(2)}`, 130, 185);

            // Entropy Graph (Right Side)
            ctx.fillStyle = 'rgba(20,20,20,0.8)';
            ctx.fillRect(width - 320, 20, 300, 100);
            ctx.strokeStyle = '#555'; ctx.strokeRect(width - 320, 20, 300, 100);
            ctx.fillStyle = '#aaa'; ctx.fillText("SYSTEM ENTROPY (DISORDER)", width - 310, 35);

            ctx.beginPath();
            ctx.strokeStyle = '#00ffaa';
            ctx.lineWidth = 2;
            for (let i = 0; i < stats.history.length; i++) {
                const val = stats.history[i];
                const x = (width - 310) + (i / 200) * 280;
                const y = 110 - (val * 80);
                if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
            }
            ctx.stroke();

            // Interaction Pointer
            if (engine.state.interaction.active) {
                ctx.beginPath();
                ctx.arc(mousePos.x, mousePos.y, 100, 0, Math.PI * 2);
                ctx.strokeStyle = engine.state.interaction.type === 'heat' ? 'rgba(255, 50, 0, 0.5)' : 'rgba(0, 200, 255, 0.5)';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.stroke();
                ctx.setLineDash([]);
            }

            ui.draw(ctx);

            requestAnimationFrame(loop);
        }

        init();

    </script>
</body>

</html>