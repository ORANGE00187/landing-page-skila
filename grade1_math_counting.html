<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Skila.ai | Gravity Math</title>
    <link href="https://fonts.googleapis.com/css2?family=Fredoka:wght@400;700&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #22c55e;
            font-family: 'Fredoka', sans-serif;
        }

        #canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        .counter-box {
            position: absolute;
            top: 10%;
            left: 50%;
            transform: translate(-50%, 0);
            background: white;
            border: 4px solid #000;
            padding: 20px 40px;
            border-radius: 20px;
            font-size: 60px;
            font-weight: bold;
            color: #3b82f6;
            box-shadow: 0 10px 0 rgba(0, 0, 0, 0.2);
            pointer-events: none;
        }

        .controls {
            position: absolute;
            bottom: 40px;
            left: 50%;
            transform: translate(-50%, 0);
            display: flex;
            gap: 20px;
        }

        .btn {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            border: 4px solid #fff;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 30px;
            font-weight: bold;
            color: white;
            cursor: pointer;
            box-shadow: 0 5px 0 rgba(0, 0, 0, 0.2);
            transition: transform 0.1s;
        }

        .btn:active {
            transform: translateY(5px);
            box-shadow: none;
        }

        .plus {
            background: #3b82f6;
        }

        .minus {
            background: #ef4444;
        }

        .plus-five {
            background: #eab308;
        }
    </style>
</head>

<body>
    <canvas id="canvas"></canvas>

    <div class="counter-box" id="counter">0</div>

    <div class="controls">
        <div class="btn minus" onclick="spawn(-1)">-1</div>
        <div class="btn plus" onclick="spawn(1)">+1</div>
        <div class="btn plus-five" onclick="spawn(5)">+5</div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const counterEl = document.getElementById('counter');

        let width, height;
        let PARTICLES = [];
        let BOX = { x: 0, y: 0, w: 400, h: 400 };

        // Count
        let COUNT = 0;

        function resize() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
            BOX.x = width / 2 - 200;
            BOX.y = height / 2 - 100;
        }
        window.addEventListener('resize', resize);
        resize();

        class Ball {
            constructor(x, y, val) {
                this.x = x; this.y = y;
                this.vx = (Math.random() - 0.5) * 5;
                this.vy = 0;
                this.r = val > 1 ? 30 : 20; // Size
                this.val = val;
                this.color = `hsl(${Math.random() * 360}, 80%, 60%)`;
                this.dead = false;
            }

            update() {
                this.vy += 0.5; // Gravity
                this.x += this.vx;
                this.y += this.vy;

                // Walls
                // Floor
                if (this.y > BOX.y + BOX.h - this.r) {
                    this.y = BOX.y + BOX.h - this.r;
                    this.vy *= -0.6; // Bounce
                    this.vx *= 0.9; // Friction
                }
                // Walls
                if (this.x < BOX.x + this.r) {
                    this.x = BOX.x + this.r;
                    this.vx *= -0.7;
                }
                if (this.x > BOX.x + BOX.w - this.r) {
                    this.x = BOX.x + BOX.w - this.r;
                    this.vx *= -0.7;
                }
            }

            draw(ctx) {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.r, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.fill();
                ctx.strokeStyle = 'white'; ctx.lineWidth = 4; ctx.stroke();

                // Shine
                ctx.beginPath(); ctx.arc(this.x - this.r * 0.3, this.y - this.r * 0.3, this.r * 0.2, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(255,255,255,0.6)'; ctx.fill();
            }
        }

        // Spawn Logic
        window.spawn = (n) => {
            if (n > 0) {
                // Add
                for (let i = 0; i < n; i++) {
                    setTimeout(() => {
                        PARTICLES.push(new Ball(width / 2 + (Math.random() - 0.5) * 50, BOX.y - 50, 1));
                        COUNT++;
                        updateCounter();
                    }, i * 100);
                }
            } else {
                // Remove (Trapdoor)
                if (PARTICLES.length > 0) {
                    const p = PARTICLES.shift(); // Remove oldest
                    // Animate it falling out?
                    // Just pop it for now or implement trapdoor hole later
                    COUNT--;
                    updateCounter();
                }
            }
        };

        function updateCounter() {
            counterEl.innerText = COUNT;
            counterEl.style.transform = "translate(-50%, 0) scale(1.2)";
            setTimeout(() => counterEl.style.transform = "translate(-50%, 0) scale(1)", 100);
        }

        function loop() {
            // Bg
            ctx.fillStyle = '#f0fdf4'; // Light green
            ctx.fillRect(0, 0, width, height);

            // Draw Box Back
            ctx.fillStyle = '#dcfce7';
            ctx.fillRect(BOX.x, BOX.y, BOX.w, BOX.h);
            ctx.strokeStyle = '#22c55e'; ctx.lineWidth = 10;
            ctx.strokeRect(BOX.x, BOX.y, BOX.w, BOX.h);

            // Physics: Collision (Simple N^2 repulsion)
            for (let i = 0; i < PARTICLES.length; i++) {
                for (let j = i + 1; j < PARTICLES.length; j++) {
                    const p1 = PARTICLES[i];
                    const p2 = PARTICLES[j];
                    const dx = p1.x - p2.x;
                    const dy = p1.y - p2.y;
                    const d = Math.sqrt(dx * dx + dy * dy);
                    const minD = p1.r + p2.r;

                    if (d < minD) {
                        // Push apart
                        const force = (minD - d) * 0.1; // Spring
                        const ang = Math.atan2(dy, dx);
                        const fx = Math.cos(ang) * force;
                        const fy = Math.sin(ang) * force;

                        p1.vx += fx; p1.vy += fy;
                        p2.vx -= fx; p2.vy -= fy;
                    }
                }
                PARTICLES[i].update();
                PARTICLES[i].draw(ctx);
            }

            // Glass Front Reflection
            ctx.fillStyle = 'rgba(255,255,255,0.2)';
            ctx.beginPath();
            ctx.moveTo(BOX.x, BOX.y);
            ctx.lineTo(BOX.x + 100, BOX.y);
            ctx.lineTo(BOX.x, BOX.y + 100);
            ctx.fill();

            requestAnimationFrame(loop);
        }
        loop();

    </script>
</body>

</html>