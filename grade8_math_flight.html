<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Skila.ai | Linear Flight Sim</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000020;
            font-family: 'Press Start 2P', cursive;
            color: #fff;
        }

        #canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        .ui-panel {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 800px;
            height: 160px;
            background: rgba(0, 0, 30, 0.9);
            border: 4px solid #f09;
            box-shadow: 0 0 20px #f09, inset 0 0 20px #f09;
            border-radius: 20px;
            display: flex;
            align-items: center;
            justify-content: space-around;
            padding: 0 40px;
        }

        .var-control {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            width: 250px;
        }

        input[type=range] {
            width: 100%;
            height: 20px;
            accent-color: #f09;
        }

        .eq-display {
            font-size: 30px;
            text-shadow: 4px 4px #00f;
            background: #000;
            padding: 20px;
            border: 2px solid #fff;
            min-width: 300px;
            text-align: center;
        }

        .launch-btn {
            background: #f09;
            color: #fff;
            border: none;
            padding: 20px 40px;
            font-family: inherit;
            font-size: 20px;
            cursor: pointer;
            box-shadow: 6px 6px 0 #800060;
            transition: transform 0.1s;
        }

        .launch-btn:active {
            transform: translate(4px, 4px);
            box-shadow: 2px 2px 0 #800060;
        }

        #score-board {
            position: absolute;
            top: 20px;
            right: 20px;
            font-size: 24px;
            color: #0f0;
            text-shadow: 2px 2px #000;
        }
    </style>
</head>

<body>
    <canvas id="canvas"></canvas>

    <div id="score-board">SCORE: 0</div>

    <div class="ui-panel">
        <!-- Slope Control -->
        <div class="var-control">
            <label style="color:cyan">SLOPE (m)</label>
            <input type="range" id="m-slider" min="-2" max="2" step="0.1" value="0.5">
            <span id="m-val" style="color:cyan">0.5</span>
        </div>

        <!-- Equation -->
        <div class="eq-display">
            y = <span id="eq-m" style="color:cyan">0.5</span>x + <span id="eq-c" style="color:yellow">0</span>
        </div>

        <!-- Intercept Control -->
        <div class="var-control">
            <label style="color:yellow">INTERCEPT (c)</label>
            <input type="range" id="c-slider" min="-300" max="300" step="10" value="0">
            <span id="c-val" style="color:yellow">0</span>
        </div>

        <button class="launch-btn" onclick="launch()">LAUNCH</button>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let width, height;

        // Game State
        let STATE = 'PLANNING'; // PLANNING, FLYING, CRASHED, SUCCESS
        let PLANE = { x: 100, y: 0, vx: 5, vy: 0 };

        // Equation Vars
        let M = 0.5;
        let C = 0;

        // Camera shift for infinite scroll
        let CAM_X = 0;

        // Map Objects
        let RINGS = [];
        let SCORE = 0;

        // UI
        const mSlider = document.getElementById('m-slider');
        const cSlider = document.getElementById('c-slider');
        const eqM = document.getElementById('eq-m');
        const eqC = document.getElementById('eq-c');
        const mVal = document.getElementById('m-val');
        const cVal = document.getElementById('c-val');

        function resize() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
            reset();
        }
        window.addEventListener('resize', resize);

        function reset() {
            STATE = 'PLANNING';
            CAM_X = 0;
            SCORE = 0;
            PLANE.x = 100;
            // Regen Level
            RINGS = [];
            for (let i = 1; i <= 10; i++) {
                // Determine a valid line for generation?
                // Or random rings and user must match?
                // User logic: "Fly through the ring gates".
                // So the rings are fixed. User finds M and C.

                // Let's make a target line: y = 0.5x + 100
                // Rings placed along this line
                // Let's randomize the "Mission" line each reset
                // But wait, the user Sets the M and C. The User IS the pilot.
                // The rings should be placed in a pattern that IS linear.
                // The puzzle is to find that line.

                const targetM = (Math.round((Math.random() * 2 - 1) * 10) / 10); // -1.0 to 1.0
                const targetC = Math.round((Math.random() * 400 - 200) / 10) * 10;

                // Wait, if I generate one line, user just finds it.
                // Let's just place rings in a line and user has to solve it visualy.

                // Actually, simpler mode: User sets path, avoids obstacles?
                // No, educational goal: "Visualize Linear Equations".
                // Best approach: User sets M and C to match a visible set of Rings.

                // Let's generate rings along a specific hidden line.
                // Display text: "Mission: Intercept Coordinates associated with y = -0.5x + 200"
                // Or just show the rings visually.

            }

            // To make it fun/sandbox:
            // The rings are just there. User plans path.
            // Let's generate rings strictly on a line for now so it's solvable.
            generateLevel();
        }

        let LEVEL_M = 0;
        let LEVEL_C = 0;

        function generateLevel() {
            // Pick a random solvable line
            LEVEL_M = (Math.floor(Math.random() * 20) - 10) / 10; // -1.0 to 1.0
            LEVEL_C = Math.floor(Math.random() * 400) - 200;

            RINGS = [];
            for (let i = 0; i < 5; i++) {
                const ringX = 500 + i * 400;
                // Calculate Y based on Math world vs Screen world
                // Math Y: y outputs altitude relative to center
                // Screen Y: Center - MathY
                const mathY = LEVEL_M * (ringX) + LEVEL_C;
                // Actually M is usually applied to local X?
                // Cartesian: y = mx + c. x is horizontal pos.
                // If plane starts at x=100.

                // Lets make it relative.
                // Plane calc: Y = M * (PlaneX) + C.
                // We want rings to lie on this path.
                const rY = LEVEL_M * ringX + LEVEL_C;

                RINGS.push({ x: ringX, y: rY, hit: false });
            }

            // Update UI to HINT the requirement? 
            // Or allow free flight?
            // "Target Flight Path Detected. Align Vectors."
            // We draw the rings, user drives.
        }

        // Input Handling
        mSlider.addEventListener('input', e => {
            M = parseFloat(e.target.value);
            mVal.innerText = M; eqM.innerText = M;
        });
        cSlider.addEventListener('input', e => {
            C = parseFloat(e.target.value);
            cVal.innerText = C; eqC.innerText = C;
        });

        window.launch = () => {
            if (STATE !== 'FLYING') {
                STATE = 'FLYING';
                PLANE.x = 0; // Reset start pos
                SCORE = 0;
                RINGS.forEach(r => r.hit = false);
            }
        };

        // --- LOOP ---
        function loop() {
            // Update
            if (STATE === 'FLYING') {
                PLANE.x += 10; // Speed
                CAM_X = PLANE.x - 200;

                // Calculate Y
                const mathY = M * PLANE.x + C;
                PLANE.y = mathY; // Math coord

                // Collision
                RINGS.forEach(r => {
                    if (!r.hit && Math.abs(r.x - PLANE.x) < 20) {
                        if (Math.abs(r.y - PLANE.y) < 40) {
                            r.hit = true;
                            SCORE += 100;
                            document.getElementById('score-board').innerText = "SCORE: " + SCORE;
                            // Sound effect valid
                        }
                    }
                });

                // End Condition
                if (PLANE.x > RINGS[RINGS.length - 1].x + 500) {
                    STATE = 'SUCCESS';
                    setTimeout(reset, 2000);
                }
                // Floor check? Limit Y?
                // Infinite world, no crash unless obs
            }

            render();
            requestAnimationFrame(loop);
        }

        // --- RENDER ---
        function mathToScreen(x, y) {
            // Screen Center is (width/2, height/2) -> Math (CAM_X + width/2, 0)
            const sx = x - CAM_X;
            const sy = height / 2 - y; // Invert Y for cartesian
            return { x: sx, y: sy };
        }

        function render() {
            // Retro Grid Background
            ctx.fillStyle = '#100020';
            ctx.fillRect(0, 0, width, height);

            // Sun
            ctx.fillStyle = 'linear-gradient(to top, #f09, #fa0)'; // basic fill in canvas
            const grad = ctx.createLinearGradient(0, height / 2, 0, height / 2 - 200);
            grad.addColorStop(0, '#f09'); grad.addColorStop(1, '#fe0');
            ctx.fillStyle = grad;
            ctx.beginPath(); ctx.arc(width / 2, height / 2 - 100, 150, 0, Math.PI, true); ctx.fill();

            // Grid Lines
            ctx.lineWidth = 2;
            const gridSize = 100;
            const offset = CAM_X % gridSize;

            // Perspective Grid (Fake 3D floor)
            // Horizon at height/2
            ctx.fillStyle = '#200040';
            ctx.fillRect(0, height / 2, width, height / 2);

            ctx.strokeStyle = '#f0f';
            ctx.beginPath();
            // Vertical lines moving left
            for (let i = 0; i < width + gridSize; i += gridSize) {
                let x = i - offset;
                // Perspective: meet at vanishing point (width/2, height/2)
                ctx.moveTo(x, height);
                ctx.lineTo(width / 2 + (x - width / 2) * 0.1, height / 2);
            }
            // Horizontal lines
            for (let i = 0; i < height / 2; i += 20) {
                let y = height - i;
                // log spacing for depth?
                ctx.moveTo(0, y); ctx.lineTo(width, y);
            }
            ctx.stroke();

            // -------------------------
            // 2D MATH LAYER
            // -------------------------

            // Coordinate Axes (Ghost)
            const orig = mathToScreen(0, 0);
            if (orig.x > 0 && orig.x < width) {
                ctx.strokeStyle = '#fff'; ctx.lineWidth = 2; ctx.setLineDash([5, 5]);
                ctx.beginPath(); ctx.moveTo(orig.x, 0); ctx.lineTo(orig.x, height); ctx.stroke();
            }
            // Start Line
            const startPos = mathToScreen(0, 0);
            ctx.fillStyle = 'lime';
            ctx.fillText("START (x=0)", startPos.x + 10, height - 20);

            // Plane Path Projection (Laser)
            if (STATE === 'PLANNING') {
                ctx.strokeStyle = '#f09'; ctx.setLineDash([10, 10]); ctx.lineWidth = 2;
                ctx.beginPath();
                // Calc start and end of screen view
                const minX = CAM_X; const maxX = CAM_X + width;
                const y1 = M * minX + C;
                const y2 = M * maxX + C;
                const p1 = mathToScreen(minX, y1);
                const p2 = mathToScreen(maxX, y2);
                ctx.moveTo(p1.x, p1.y); ctx.lineTo(p2.x, p2.y);
                ctx.stroke();
                ctx.setLineDash([]);
            }

            // Rings
            RINGS.forEach(r => {
                const p = mathToScreen(r.x, r.y);
                if (p.x > -100 && p.x < width + 100) {
                    ctx.strokeStyle = r.hit ? '#0f0' : '#0ff';
                    ctx.lineWidth = 8;
                    // Neon effect
                    ctx.shadowBlur = 20; ctx.shadowColor = ctx.strokeStyle;

                    ctx.beginPath();
                    // Perspective ring? Just circle for 2D logic clarity
                    ctx.arc(p.x, p.y, 40, 0, Math.PI * 2);
                    ctx.stroke();

                    // Coordinates Label
                    ctx.fillStyle = '#fff'; ctx.shadowBlur = 0;
                    ctx.font = '10px monospace';
                    ctx.fillText(`(${r.x}, ${Math.floor(r.y)})`, p.x - 30, p.y + 60);
                }
            });

            // Plane
            ctx.shadowBlur = 0;
            const pPos = mathToScreen(PLANE.x, PLANE.y);

            // Jet Sprite (Canvas Geom)
            ctx.save();
            ctx.translate(pPos.x, pPos.y);
            // Tilt based on slope M
            const angle = Math.atan(-M); // Invert for screen Y
            ctx.rotate(angle);

            // Body
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.moveTo(20, 0); ctx.lineTo(-20, 10); ctx.lineTo(-20, -10); ctx.fill();
            // Engine Glow
            ctx.fillStyle = '#f09'; ctx.shadowBlur = 20; ctx.shadowColor = '#f09';
            ctx.beginPath(); ctx.moveTo(-20, 0); ctx.lineTo(-40, 0); ctx.stroke();

            ctx.restore();
            // Info Tag
            ctx.fillStyle = 'lime'; ctx.textAlign = 'center';
            ctx.font = '12px monospace';
            ctx.fillText(`x=${Math.floor(PLANE.x)}`, pPos.x, pPos.y - 40);
            ctx.fillText(`y=${Math.floor(PLANE.y)}`, pPos.x, pPos.y - 25);

        }

        resize();
        generateLevel();
        loop();

    </script>
</body>

</html>