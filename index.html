<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Skila.ai | Detailed Learning Maps</title>
    <meta name="description"
        content="Interactive, nested learning roadmaps for Engineering, Medical, Mathematics, and K-12 Education.">

    <!-- FONTS -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Plus+Jakarta+Sans:wght@300;400;500;600;700;800&family=JetBrains+Mono:wght@400;500&display=swap"
        rel="stylesheet">

    <!-- ICONS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">

    <!-- TAILWIND CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['Plus Jakarta Sans', 'sans-serif'],
                        mono: ['JetBrains Mono', 'monospace'],
                    },
                    colors: {
                        slate: { 850: '#151F32', 900: '#0F172A' },
                        primary: '#2563EB',
                        scientific: '#0F766E',
                    },
                    animation: {
                        'float': 'float 8s ease-in-out infinite',
                        'pulse-glow': 'pulseGlow 4s cubic-bezier(0.4, 0, 0.6, 1) infinite',
                        'cursor-blink': 'blink 1s step-end infinite',
                    },
                    keyframes: {
                        blink: {
                            '0%, 100%': { opacity: '1' },
                            '50%': { opacity: '0' },
                        },
                        float: {
                            '0%, 100%': { transform: 'translateY(0)' },
                            '50%': { transform: 'translateY(-15px)' },
                        },
                        pulseGlow: {
                            '0%, 100%': { opacity: 1, boxShadow: '0 0 20px rgba(59, 130, 246, 0.2)' },
                            '50%': { opacity: 0.8, boxShadow: '0 0 40px rgba(59, 130, 246, 0.5)' },
                        }
                    }
                }
            }
        }
    </script>

    <!-- LIBRARIES -->
    <script src="https://cdn.jsdelivr.net/npm/gsap@3.12.5/dist/gsap.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/gsap@3.12.5/dist/ScrollToPlugin.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/gsap@3.12.5/dist/ScrollTrigger.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/gsap@3.12.5/dist/MotionPathPlugin.min.js"></script>

    <!-- THREE.JS Global (for Hero section) -->
    <script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>



    <style>
        /* --- CORE VISUALS --- */
        body {
            background-color: #F8FAFC;
            color: #1E293B;
            overflow-x: hidden;
            transition: background-color 1.2s ease-in-out;
        }

        /* Noise Texture */
        .noise-overlay {
            position: fixed;
            inset: 0;
            width: 100%;
            height: 100%;
            background: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.85' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)' opacity='0.03'/%3E%3C/svg%3E");
            pointer-events: none;
            z-index: 9000;
            mix-blend-mode: multiply;
        }

        /* Glassmorphism */
        .glass-nav {
            background: rgba(255, 255, 255, 0.8);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.6);
            box-shadow: 0 4px 30px rgba(0, 0, 0, 0.03);
        }

        .glass-card {
            background: rgba(255, 255, 255, 0.65);
            backdrop-filter: blur(24px);
            -webkit-backdrop-filter: blur(24px);
            border: 1px solid rgba(255, 255, 255, 0.8);
            box-shadow: 0 20px 40px -10px rgba(0, 0, 0, 0.05);
            transition: transform 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94), box-shadow 0.4s;
        }

        .glass-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 30px 60px -15px rgba(0, 0, 0, 0.1);
        }

        /* --- GOD-LEVEL NAVBAR STYLES --- */
        .glass-nav-container {
            background: rgba(255, 255, 255, 0.65);
            backdrop-filter: blur(24px);
            -webkit-backdrop-filter: blur(24px);
            border: 1px solid rgba(255, 255, 255, 0.8);
            box-shadow: 0 10px 40px -10px rgba(0, 0, 0, 0.05);
            transition: all 0.5s cubic-bezier(0.2, 0.8, 0.2, 1);
        }

        .glass-nav-container:hover {
            background: rgba(255, 255, 255, 0.85);
            box-shadow: 0 20px 60px -15px rgba(0, 0, 0, 0.1);
            transform: translateY(-2px);
            border-color: #ffffff;
        }

        .nav-energy-line {
            position: absolute;
            bottom: -1px;
            left: 50%;
            transform: translateX(-50%);
            width: 0%;
            height: 2px;
            background: linear-gradient(90deg, transparent, #2563EB, transparent);
            opacity: 0;
            transition: all 0.6s ease;
            box-shadow: 0 0 10px #2563EB;
        }

        .glass-nav-container:hover .nav-energy-line {
            width: 60%;
            opacity: 1;
        }

        /* ROADMAP CONTAINER & SVG */
        #roadmap-section {
            position: relative;
            min-height: 100vh;
            padding-bottom: 200px;
        }

        .roadmap-svg-layer {
            position: absolute;
            top: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 100%;
            max-width: 1000px;
            height: 100%;
            z-index: 0;
            pointer-events: none;
        }

        .road-base {
            fill: none;
            stroke: rgba(0, 0, 0, 0.03);
            stroke-width: 60px;
            stroke-linecap: round;
        }

        .road-active {
            fill: none;
            stroke: url(#roadGradient);
            stroke-width: 8px;
            stroke-linecap: round;
            filter: drop-shadow(0 0 10px rgba(255, 255, 255, 0.8));
        }

        /* NODES */
        .roadmap-nodes-container {
            position: relative;
            z-index: 10;
            max-width: 1000px;
            margin: 0 auto;
        }

        .node-item {
            position: absolute;
            width: 320px;
            cursor: pointer;
            opacity: 0;
            transform: translateY(20px);
        }

        .node-left {
            left: 5%;
        }

        .node-right {
            right: 5%;
        }

        /* BREADCRUMBS UI */
        .breadcrumbs-ui {
            position: sticky;
            top: 100px;
            z-index: 50;
            display: flex;
            justify-content: center;
            gap: 1rem;
            margin-bottom: 4rem;
        }

        /* LAB MODAL */
        .lab-modal {
            position: fixed;
            inset: 0;
            z-index: 9999;
            background: rgba(248, 250, 252, 0.85);
            backdrop-filter: blur(40px);
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.4s ease;
        }

        .lab-modal.active {
            opacity: 1;
            pointer-events: all;
        }

        .lab-console {
            width: 95vw;
            height: 92vh;
            background: white;
            border-radius: 24px;
            box-shadow: 0 50px 100px -20px rgba(0, 0, 0, 0.15);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            border: 1px solid #e2e8f0;
            transform: scale(0.95);
            transition: transform 0.4s cubic-bezier(0.16, 1, 0.3, 1);
        }

        .lab-modal.active .lab-console {
            transform: scale(1);
        }

        /* Canvas */
        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* --- OFFER SECTION (NEW) --- */
        /* --- OFFER SECTION (NEW) --- */
        .offer-card {
            position: relative;
            height: 320px;
            border-radius: 24px;
            overflow: hidden;
            background: rgba(255, 255, 255, 0.4);
            border: 1px solid rgba(255, 255, 255, 0.6);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            box-shadow:
                0 4px 6px -1px rgba(0, 0, 0, 0.02),
                0 2px 4px -1px rgba(0, 0, 0, 0.02),
                inset 0 0 0 1px rgba(255, 255, 255, 0.5);
            /* Inner light ring */
            transition: all 0.5s cubic-bezier(0.2, 0.8, 0.2, 1);
            cursor: default;
        }

        .offer-card:hover {
            transform: translateY(-8px) scale(1.01);
            box-shadow:
                0 20px 40px -5px rgba(0, 0, 0, 0.1),
                0 0 30px rgba(255, 255, 255, 0.4),
                /* Outer glow */
                inset 0 0 20px rgba(255, 255, 255, 0.5);
            /* Inner glow */
            background: rgba(255, 255, 255, 0.75);
            border-color: rgba(255, 255, 255, 0.9);
            z-index: 50;
        }

        /* Layers */
        .layer-bg {
            position: absolute;
            inset: -20px;
            /* Oversize for parallax */
            z-index: 0;
            opacity: 0.5;
            transition: opacity 0.5s;
        }

        .offer-card:hover .layer-bg {
            opacity: 0.8;
        }

        .layer-content {
            position: relative;
            z-index: 20;
            padding: 2.5rem;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: flex-end;
            /* Bottom align text like Apple */
            pointer-events: none;
            /* Let clicks pass through */
        }

        /* New: Glowing Blob behind accent */
        .accent-glow {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 140%;
            height: 140%;
            background: radial-gradient(circle, rgba(255, 255, 255, 0.8) 0%, rgba(255, 255, 255, 0) 70%);
            opacity: 0;
            transition: opacity 0.5s;
            pointer-events: none;
            z-index: -1;
        }

        .offer-card:hover .accent-glow {
            opacity: 0.6;
        }

        .layer-accent {
            position: absolute;
            top: 2rem;
            right: 2rem;
            width: 120px;
            height: 120px;
            z-index: 10;
            display: flex;
            align-items: center;
            justify-content: center;
            /* Subtly float */
        }

        /* Grid Stagger */
        .grid-staggered .offer-card:nth-child(even) {
            transform: translateY(40px);
        }

        @media (max-width: 768px) {
            .grid-staggered .offer-card:nth-child(even) {
                transform: none;
            }

            .offer-card {
                height: 280px;
            }
        }

        /* Typography */
        .offer-title {
            font-size: 1.5rem;
            /* 24px */
            font-weight: 700;
            letter-spacing: -0.02em;
            color: #1e293b;
            margin-bottom: 0.5rem;
        }

        .offer-desc {
            font-size: 0.95rem;
            line-height: 1.5;
            color: #64748b;
            font-weight: 500;
        }

        .logo-mark svg {
            overflow: visible;
        }

        .logo-mark path {
            stroke-dasharray: 1000;
            stroke-dashoffset: 1000;
            fill: none;
            stroke-width: 12;
            stroke-linecap: round;
            stroke-linejoin: round;
            animation: draw-in 2s cubic-bezier(0.5, 0, 0.5, 1) forwards;
        }

        @keyframes draw-in {
            to {
                stroke-dashoffset: 0;
            }
        }

        /* The "i" Dot Pulse */
        .logo-dot-pulse {
            width: 6px;
            height: 6px;
            background: #10B981;
            border-radius: 50%;
            display: inline-block;
            margin-left: 2px;
            margin-bottom: 2px;
            box-shadow: 0 0 0 0 rgba(16, 185, 129, 0.7);
            animation: dot-pulse 2s infinite;
        }

        @keyframes dot-pulse {
            0% {
                transform: scale(0.95);
                box-shadow: 0 0 0 0 rgba(16, 185, 129, 0.7);
            }

            70% {
                transform: scale(1);
                box-shadow: 0 0 0 6px rgba(16, 185, 129, 0);
            }

            100% {
                transform: scale(0.95);
                box-shadow: 0 0 0 0 rgba(16, 185, 129, 0);
            }
        }

        /* --- CORTEX SECTION (BRAIN PARALLAX) --- */
        #cortex-section {
            position: relative;
            z-index: 20;
            background-color: #0F172A;
            /* Dark start */
            transition: background-color 1s ease;
        }

        .cortex-sticky {
            overflow: hidden;
            width: 100%;
            height: 100vh;
            pointer-events: none;
            /* Prevents blocking clicks on roadmap */
        }

        #cortex-canvas-container {
            position: absolute;
            inset: 0;
            z-index: 1;
            pointer-events: none;
        }

        .cortex-text-layer {
            position: absolute;
            inset: 0;
            z-index: 2;
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: none;
        }

        .cortex-text {
            font-family: 'Plus Jakarta Sans', sans-serif;
            font-weight: 800;
            font-size: 4rem;
            color: white;
            text-align: center;
            opacity: 0;
            transform: translateY(20px);
            text-shadow: 0 0 30px rgba(59, 130, 246, 0.5);
            max-width: 800px;
            padding: 20px;
            position: absolute;
            /* Stack them */
        }

        @media (max-width: 768px) {
            .cortex-text {
                font-size: 2rem;
            }
        }

        /* ============================================= */
        /* COMPREHENSIVE MOBILE STYLES                   */
        /* ============================================= */

        /* --- TABLET BREAKPOINT (max-width: 1024px) --- */
        @media (max-width: 1024px) {

            /* Hero Section */
            section.min-h-screen h1 {
                font-size: 3.5rem !important;
            }

            /* Offer Cards Grid */
            .grid-staggered {
                gap: 1.5rem !important;
            }

            .offer-card {
                min-height: 280px !important;
            }

            /* Roadmap */
            .roadmap-nodes-container {
                padding: 1rem !important;
            }

            /* CTA Section */
            #cta-section h2 {
                font-size: 3rem !important;
            }
        }

        /* --- MOBILE BREAKPOINT (max-width: 768px) --- */
        @media (max-width: 768px) {

            /* NAVBAR */
            nav#navbar {
                padding: 0.75rem 1rem !important;
            }

            nav .glass-nav-container {
                padding: 0.5rem 1rem !important;
                border-radius: 1rem !important;
            }

            nav .logo-mark {
                width: 2rem !important;
                height: 2rem !important;
            }

            nav .font-bold.text-xl {
                font-size: 1rem !important;
            }

            nav .nav-links {
                display: none !important;
            }

            nav .flex.items-center.gap-3 {
                gap: 0.5rem !important;
            }

            nav button,
            nav a.group {
                padding: 0.5rem 0.75rem !important;
                font-size: 0.65rem !important;
            }

            nav button span,
            nav a.group span {
                gap: 0.25rem !important;
            }

            nav button i,
            nav a.group i {
                font-size: 0.6rem !important;
            }

            /* HERO SECTION */
            section.min-h-screen {
                min-height: 80vh !important;
                padding: 6rem 1rem 2rem !important;
            }

            section.min-h-screen h1 {
                font-size: 2.5rem !important;
                line-height: 1.2 !important;
            }

            section.min-h-screen p {
                font-size: 1rem !important;
                padding: 0 0.5rem !important;
            }

            section.min-h-screen .pt-8 button {
                font-size: 0.7rem !important;
            }

            /* OFFER SECTION */
            #offer-section {
                padding: 3rem 1rem !important;
            }

            #offer-section h2 {
                font-size: 2rem !important;
                margin-bottom: 1rem !important;
            }

            #offer-section>div>p {
                font-size: 0.95rem !important;
            }

            #offer-section .mb-24 {
                margin-bottom: 2rem !important;
            }

            .offer-card {
                min-height: 220px !important;
                border-radius: 1rem !important;
            }

            .offer-title {
                font-size: 1.25rem !important;
            }

            .offer-desc {
                font-size: 0.85rem !important;
            }

            .layer-accent {
                opacity: 0.5 !important;
            }

            /* CORTEX BRAIN SECTION */
            #cortex-section {
                height: 400vh !important;
            }

            .cortex-text {
                font-size: 1.5rem !important;
                padding: 1rem !important;
                max-width: 90% !important;
            }

            .cortex-text-layer {
                padding: 0 1rem !important;
            }

            /* ROADMAP SECTION */
            #roadmap-section {
                padding-top: 2rem !important;
            }

            .breadcrumbs-ui {
                top: 70px !important;
                left: 50% !important;
                transform: translateX(-50%) !important;
                flex-direction: column !important;
                gap: 0.5rem !important;
                width: 90% !important;
            }

            .breadcrumbs-ui button,
            .breadcrumbs-ui div {
                font-size: 0.7rem !important;
                padding: 0.4rem 0.8rem !important;
            }

            .roadmap-nodes-container {
                min-height: 600px !important;
                padding: 0.5rem !important;
            }

            .roadmap-svg-layer {
                display: none !important;
            }

            /* Roadmap Node Cards */
            .node-card {
                width: 100% !important;
                max-width: 320px !important;
                padding: 1rem !important;
            }

            .node-card h3 {
                font-size: 1rem !important;
            }

            .node-card p {
                font-size: 0.8rem !important;
            }

            .node-card .node-icon {
                width: 2.5rem !important;
                height: 2.5rem !important;
                font-size: 1rem !important;
            }

            /* CTA SECTION */
            #cta-section {
                padding: 4rem 1rem !important;
            }

            #cta-section h2 {
                font-size: 2rem !important;
                line-height: 1.3 !important;
            }

            #cta-section p {
                font-size: 1rem !important;
                margin-bottom: 2rem !important;
            }

            #cta-section a.group {
                padding: 1rem 2rem !important;
                font-size: 1rem !important;
            }

            #cta-section .mt-16 {
                margin-top: 2rem !important;
                flex-direction: column !important;
                gap: 1rem !important;
            }

            #cta-section .mt-16 .w-px {
                display: none !important;
            }

            #cta-section .absolute.w-96 {
                width: 200px !important;
                height: 200px !important;
            }

            /* FOOTER */
            footer {
                padding: 2rem 1rem 1rem !important;
            }

            footer .grid {
                gap: 2rem !important;
            }

            footer h3 {
                font-size: 0.75rem !important;
                margin-bottom: 1rem !important;
            }

            footer ul {
                gap: 0.5rem !important;
            }

            footer .pt-8 {
                padding-top: 1.5rem !important;
                text-align: center !important;
            }

            footer .font-bold.text-xl {
                font-size: 1rem !important;
            }

            footer p.text-sm {
                font-size: 0.8rem !important;
            }

            /* SIMULATION MODAL */
            .lab-console {
                width: 100% !important;
                height: 100% !important;
                border-radius: 0 !important;
            }

            .lab-console .h-16 {
                height: 3.5rem !important;
                padding: 0 1rem !important;
            }

            .lab-console #lab-title {
                font-size: 0.7rem !important;
            }

            /* LIQUID TRANSITION */
            #transition-logo {
                flex-direction: column !important;
                gap: 1rem !important;
            }

            #transition-logo .w-24 {
                width: 4rem !important;
                height: 4rem !important;
            }

            #transition-logo .text-6xl {
                font-size: 2.5rem !important;
            }

            #transition-logo span[class*="10px"] {
                font-size: 8px !important;
            }
        }

        /* --- SMALL MOBILE (max-width: 480px) --- */
        @media (max-width: 480px) {

            /* NAVBAR - Stack buttons */
            nav .flex.items-center.gap-3 {
                flex-direction: column !important;
                gap: 0.25rem !important;
            }

            nav button,
            nav a.group {
                width: 100% !important;
                justify-content: center !important;
            }

            /* HERO */
            section.min-h-screen h1 {
                font-size: 2rem !important;
            }

            section.min-h-screen p {
                font-size: 0.9rem !important;
            }

            /* OFFER CARDS */
            .offer-card {
                min-height: 180px !important;
            }

            .offer-title {
                font-size: 1.1rem !important;
            }

            .offer-desc {
                font-size: 0.8rem !important;
            }

            /* CORTEX */
            .cortex-text {
                font-size: 1.25rem !important;
            }

            /* CTA */
            #cta-section h2 {
                font-size: 1.75rem !important;
            }

            #cta-section a.group {
                padding: 0.875rem 1.5rem !important;
                font-size: 0.9rem !important;
            }

            /* Hide floating particles on small screens */
            #cta-section>.absolute.w-4,
            #cta-section>.absolute.w-3,
            #cta-section>.absolute.w-2 {
                display: none !important;
            }

            /* FOOTER */
            footer .grid {
                grid-template-columns: 1fr !important;
            }

            footer .flex.gap-4 {
                justify-content: center !important;
            }
        }

        /* --- MOBILE ANIMATION OPTIMIZATIONS --- */
        @media (max-width: 768px) {

            /* Reduce animation intensity for performance */
            .animate-pulse {
                animation-duration: 3s !important;
            }

            .animate-float {
                animation-duration: 10s !important;
            }

            /* Disable heavy blur effects on mobile */
            .blur-effect-large {
                filter: blur(50px) !important;
            }

            /* Reduce parallax intensity */
            .layer-accent {
                transform: none !important;
            }
        }

        /* --- TOUCH DEVICE OPTIMIZATIONS --- */
        @media (hover: none) and (pointer: coarse) {

            /* Larger tap targets */
            nav button,
            nav a.group {
                min-height: 44px !important;
            }

            .offer-card {
                cursor: default !important;
            }

            /* Remove hover states that don't work on touch */
            /* Touch devices handle these natively */

            /* Ensure buttons are easily tappable */
            a,
            button {
                min-height: 44px;
                min-width: 44px;
            }
        }

        /* --- LANDSCAPE MOBILE --- */
        @media (max-height: 500px) and (orientation: landscape) {
            section.min-h-screen {
                min-height: 100vh !important;
                padding-top: 4rem !important;
            }

            section.min-h-screen h1 {
                font-size: 2rem !important;
            }

            #cta-section {
                padding: 2rem 1rem !important;
            }

            #cta-section h2 {
                font-size: 1.5rem !important;
            }
        }

        /* ========================================= */
        /* === MOBILE OPTIMIZATION PATCH (FINAL) === */
        /* ========================================= */

        @media (max-width: 768px) {

            /* 1. ROADMAP RE-FLOW (Critical Fix) 
           The JS sets absolute position which breaks on mobile. 
           This forces nodes into a vertical timeline stack. */
            #nodes-mount {
                position: relative;
                height: auto !important;
                /* Ignore JS height */
                display: flex;
                flex-direction: column;
                align-items: center;
                gap: 2.5rem;
                padding-top: 3rem;
                padding-bottom: 6rem;
            }

            /* Create a vertical line connecting the nodes */
            #nodes-mount::before {
                content: '';
                position: absolute;
                top: 2rem;
                bottom: 2rem;
                left: 50%;
                width: 4px;
                background: linear-gradient(to bottom, #3b82f6, #10b981, #f59e0b);
                transform: translateX(-50%);
                border-radius: 99px;
                opacity: 0.3;
                z-index: 0;
            }

            /* Override inline JS styles for card positioning */
            .node-item {
                position: relative !important;
                top: auto !important;
                left: auto !important;
                transform: none !important;
                /* Remove centering transform */
                width: 90% !important;
                max-width: 400px !important;
                margin: 0 !important;
                z-index: 10;
            }

            /* 2. NAVBAR ADJUSTMENTS */
            nav#navbar {
                padding: 10px !important;
            }

            .glass-nav-container {
                padding: 0.75rem !important;
                flex-wrap: wrap;
                /* Allow wrapping on tiny screens */
                justify-content: center;
                gap: 0.75rem;
                border-radius: 1rem !important;
            }

            /* Hide the glowing line on mobile to save performance */
            .nav-energy-line {
                display: none;
            }

            /* Adjust button sizes */
            nav button,
            nav a.group {
                padding: 8px 16px !important;
                font-size: 0.75rem !important;
            }

            /* 3. HERO & TEXT SIZING */
            section.min-h-screen {
                padding-top: 8rem !important;
                /* Push down content so nav doesn't cover it */
                min-height: auto !important;
                /* Allow natural height */
                padding-bottom: 4rem;
            }

            section.min-h-screen h1 {
                font-size: 2.75rem !important;
                line-height: 1.1;
            }

            .py-32 {
                padding-top: 4rem !important;
                padding-bottom: 4rem !important;
            }

            /* 4. MODAL / SIMULATION FIXES */
            .lab-modal {
                align-items: flex-end;
                /* Sheet-like appearance */
                padding: 0;
            }

            .lab-console {
                width: 100% !important;
                height: 85vh !important;
                /* Account for mobile browser bars */
                border-bottom-left-radius: 0 !important;
                border-bottom-right-radius: 0 !important;
                border-top-left-radius: 24px !important;
                border-top-right-radius: 24px !important;
            }

            /* 5. CORTEX / BRAIN SECTION */
            /* Reduce the scroll height significantly for mobile */
            #cortex-section {
                height: 200vh !important;
            }

            .cortex-text {
                font-size: 1.75rem !important;
                width: 100%;
                padding: 0 1rem;
            }
        }

        /* 6. TINY SCREENS (iPhone SE, etc) */
        @media (max-width: 380px) {
            .glass-nav-container {
                flex-direction: column;
                /* Stack logo and buttons */
                gap: 1rem;
            }

            .glass-nav-container>div {
                width: 100%;
                justify-content: center;
            }

            section.min-h-screen h1 {
                font-size: 2.25rem !important;
            }
        }


        /* ================================================================= */
        /* === MOBILE EMERGENCY FIXES (ROADMAP & BRAIN) - PASTE AT END === */
        /* ================================================================= */

        @media (max-width: 1024px) {

            /* --- 1. CORTEX (BRAIN) FIXES --- */
            /* Reduce the scroll distance so users aren't scrolling forever on empty space */
            #cortex-section {
                height: 250vh !important;
                /* Overrides the inline 600vh */
                min-height: 600px;
            }

            /* Force text to be readable and centered */
            .cortex-text {
                font-size: 1.75rem !important;
                line-height: 1.3;
                width: 90%;
                max-width: 400px;
                left: 50% !important;
                top: 50% !important;
                transform: translate(-50%, -50%) !important;
                /* Force center */
                text-align: center;
                padding: 0 1rem;
                /* Ensure text is visible over the canvas */
                text-shadow: 0 2px 10px rgba(0, 0, 0, 0.8);
                white-space: normal !important;
                /* Allow wrapping */
            }

            /* --- 2. ROADMAP FIXES (THE "SHIT" FIXER) --- */

            /* Hide the SVG Curve because it doesn't scale to mobile width correctly */
            .roadmap-svg-layer {
                display: none !important;
            }

            /* Reset the container to a vertical flex stack */
            #nodes-mount {
                /* Override JS height calculation */
                height: auto !important;
                min-height: auto !important;

                /* Flexbox Vertical Stack */
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: flex-start;
                gap: 2rem;
                /* Space between cards */

                /* Padding */
                padding-top: 4rem;
                padding-bottom: 8rem;
                padding-left: 1rem;
                padding-right: 1rem;

                position: relative;
            }

            /* Create a fake "Road" line using CSS since we hid the SVG */
            #nodes-mount::before {
                content: '';
                position: absolute;
                top: 2rem;
                bottom: 2rem;
                left: 50%;
                width: 4px;
                /* Gradient line matching your theme */
                background: linear-gradient(to bottom, #3B82F6, #10B981, #F59E0B);
                transform: translateX(-50%);
                border-radius: 4px;
                z-index: 0;
                opacity: 0.3;
            }

            /* Force the Node Cards to behave */
            .node-item {
                /* CRITICAL: Override absolute positioning from JS */
                position: relative !important;
                top: auto !important;
                left: auto !important;
                transform: none !important;

                /* Size adjustments */
                width: 100% !important;
                max-width: 360px !important;
                height: auto !important;

                /* Visuals */
                margin: 0 !important;
                z-index: 10;

                /* Ensure they are visible even if GSAP tried to hide them */
                opacity: 1 !important;
                visibility: visible !important;
            }

            /* Adjust the card internals */
            .glass-card {
                backdrop-filter: blur(10px) !important;
                background: rgba(255, 255, 255, 0.85) !important;
            }

            /* Fix Canvas inside cards */
            .node-item canvas {
                width: 100% !important;
                height: 120px !important;
                /* Fixed height for mobile preview */
            }

            /* --- 3. BREADCRUMBS UI FIX --- */
            .breadcrumbs-ui {
                top: 80px !important;
                /* Move down below navbar */
                flex-wrap: wrap;
                width: 90%;
                left: 50%;
                transform: translateX(-50%);
            }

            /* --- 4. HERO SECTION FIX --- */
            /* Ensure title fits */
            section.min-h-screen h1 {
                font-size: 2.5rem !important;
                /* Smaller title */
                word-wrap: break-word;
            }

            section.min-h-screen {
                padding-top: 7rem !important;
            }

            /* --- 5. NAVBAR STACKING --- */
            /* Fix overlap issues */
            .glass-nav-container {
                padding: 0.5rem !important;
            }

            .logo-mark {
                width: 30px !important;
                height: 30px !important;
            }
        }
    </style>
</head>

<body>
    <!-- === PASTE THIS INTO BODY OF BOTH FILES === -->
    <div id="liquid-transition" class="fixed inset-0 z-[99999] pointer-events-none" style="display: none;">
        <!-- The Morphing Layer: Liquid Glass -->
        <div id="liquid-circle" class="absolute inset-0 bg-[#F8FAFC] flex items-center justify-center overflow-hidden"
            style="clip-path: circle(0% at 50% 50%);">

            <!-- 1. The Glassy Gradient (Matches your Hero Section) -->
            <div
                class="absolute inset-0 bg-[radial-gradient(circle_at_center,_var(--tw-gradient-stops))] from-white via-slate-50 to-blue-50/50">
            </div>

            <!-- Optional: Very subtle noise texture for realism -->
            <div class="absolute inset-0 opacity-[0.03]"
                style="background-image: url('data:image/svg+xml,%3Csvg viewBox=%220 0 200 200%22 xmlns=%22http://www.w3.org/2000/svg%22%3E%3Cfilter id=%22noiseFilter%22%3E%3CfeTurbulence type=%22fractalNoise%22 baseFrequency=%220.65%22 numOctaves=%223%22 stitchTiles=%22stitch%22/%3E%3C/filter%3E%3Crect width=%22100%25%22 height=%22100%25%22 filter=%22url(%23noiseFilter)%22/%3E%3C/svg%3E');">
            </div>

            <!-- 2. The Full Brand Lockup (HORIZONTAL) -->
            <div class="relative z-10 flex flex-row items-center justify-center gap-6 opacity-0 transform scale-90"
                id="transition-logo">

                <!-- A. The Logo Mark (Left) -->
                <div class="relative w-24 h-24 shrink-0">
                    <!-- Glowing Backdrop (Soft Pastel) -->
                    <div class="absolute inset-0 bg-blue-400/20 blur-[60px] rounded-full animate-pulse"></div>

                    <!-- The Vector Mark -->
                    <svg viewBox="180 200 600 600" width="100%" height="100%" xmlns="http://www.w3.org/2000/svg"
                        class="relative z-10 drop-shadow-xl">
                        <defs>
                            <linearGradient id="transGrad" x1="0" x2="1" y1="0" y2="1">
                                <stop offset="0%" stop-color="#2563EB" />
                                <stop offset="50%" stop-color="#7C3AED" />
                                <stop offset="100%" stop-color="#10B981" />
                            </linearGradient>
                        </defs>
                        <path stroke="url(#transGrad)" fill="none" stroke-width="16" stroke-linecap="round"
                            stroke-linejoin="round"
                            d="M0 0 C12.44795096 11.15193612 25.209924 26.49916535 26.7421875 43.85644531 C26.93179549 51.49066179 26.236526 57.76844022 21.1484375 63.75097656 C14.29280134 70.0736008 5.27434454 69.52993902 -3.45703125 69.52783203 C-5.49173017 69.53221716 -7.5242755 69.56864548 -9.55859375 69.60644531 C-18.14831286 69.63200995 -23.10236282 69.23406072 -29.5 63.29785156 C-30.01433594 62.67394531 -30.52867187 62.05003906 -31.05859375 61.40722656 C-31.63867188 60.71242188 -32.21875 60.01761719 -32.81640625 59.30175781 C-34.4100245 57.26711498 -35.92582544 55.19337705 -37.43359375 53.09472656 C-44.86753252 43.15037392 -55.763018 36.58908709 -68.06640625 34.40332031 C-82.00493749 32.99153982 -95.14293339 34.40344299 -106.49609375 43.15722656 C-113.84092745 49.79045007 -118.20904961 56.6681874 -118.87109375 66.62988281 C-119.40021676 80.49483979 -117.03175699 90.70670264 -107.49609375 101.15722656 C-102.60981911 106.30604731 -97.62113337 111.27177657 -92.18359375 115.84472656 C-81.65027014 124.96504335 -74.36366647 139.40510018 -72.49609375 153.15722656 C-71.65901004 166.901601 -71.65901004 166.901601 -74.49609375 171.15722656 C-83.10650834 170.73477779 -91.01635779 169.28947525 -99.30859375 166.96972656 C-100.4471582 166.65583984 -101.58572266 166.34195313 -102.75878906 166.01855469 C-111.28613295 163.61409145 -119.43482192 160.86388701 -127.49609375 157.15722656 C-128.66914063 156.62484375 -129.8421875 156.09246094 -131.05078125 155.54394531 C-154.43275022 144.41576533 -171.50401018 127.74589403 -181.28125 103.61425781 C-189.64889096 79.80280363 -188.20222315 53.93549868 -177.49609375 31.15722656 C-172.32524034 20.77417359 -165.72074162 12.27906633 -157.49609375 4.15722656 C-156.60921875 3.27164062 -155.72234375 2.38605469 -154.80859375 1.47363281 C-113.92382881 -37.56894068 -41.95830224 -36.37228731 0 0 Z"
                            transform="translate(408.49609375,363.8427734375)" />
                        <path stroke="url(#transGrad)" fill="none" stroke-width="16" stroke-linecap="round"
                            stroke-linejoin="round"
                            d="M0 0 C6.34498414 -0.76650815 12.32105685 1.05255799 18.4375 2.625 C19.50355469 2.89715332 20.56960938 3.16930664 21.66796875 3.44970703 C41.10643665 8.54115356 59.43172211 16.04861213 75 29 C75.88429688 29.7321875 76.76859375 30.464375 77.6796875 31.21875 C94.28485334 45.55269255 105.96671454 65.91626071 108 88 C109.51108543 112.50639352 103.601609 135.85134046 87.07617188 154.66601562 C84.78356142 157.17789122 82.40354185 159.59478321 80 162 C79.14664063 162.8765625 78.29328125 163.753125 77.4140625 164.65625 C55.25012496 186.2211622 22.93540443 193.3964399 -6.99414062 193.30273438 C-37.11338155 192.78836404 -66.24524374 180.99860186 -87.55322266 159.52441406 C-94.89988063 151.78352098 -99.60694275 142.61723343 -104 133 C-104.38542969 132.19820312 -104.77085937 131.39640625 -105.16796875 130.5703125 C-107.24806212 124.14448415 -107.13256511 115.48193571 -105.0546875 109.09375 C-102.09187852 103.50354437 -98.75965606 99.8763342 -92.6171875 97.92578125 C-86.93905656 96.57815427 -81.24587523 96.631846 -75.4375 96.625 C-74.33986328 96.60050781 -73.24222656 96.57601562 -72.11132812 96.55078125 C-65.48794966 96.5268269 -61.27986492 96.87680652 -56 101 C-54.18216476 103.0728257 -52.62503853 105.01116308 -51.0625 107.25 C-50.20328809 108.41577064 -49.33998551 109.5785372 -48.47265625 110.73828125 C-47.84447998 111.57866943 -47.84447998 111.57866943 -47.20361328 112.43603516 C-38.10721505 124.25581752 -24.53717575 131.26811555 -10 134 C-7.05588512 134.28265107 -4.14386726 134.33446268 -1.1875 134.3125 C-0.39923828 134.30758545 0.38902344 134.3026709 1.20117188 134.29760742 C12.99441054 134.06179102 24.41558262 130.51755536 33.25 122.4375 C42.20883978 112.89715337 44.59170196 102.06923591 44.3359375 89.46484375 C43.41635524 71.61658807 28.72977732 57.17197753 16.375 45.5625 C5.98468673 35.32240812 -1.81812468 21.38973764 -2.25 6.625 C-2 3 -2 3 0 0 Z"
                            transform="translate(328,448)" />
                    </svg>
                </div>

                <!-- B. The Typography (Right, Aligned Left) -->
                <div class="flex flex-col items-start justify-center">
                    <!-- TEXT IS NOW DARK SLATE (High Contrast) -->
                    <span
                        class="font-sans font-black text-6xl tracking-tight text-slate-800 drop-shadow-sm leading-none">
                        SKILA<span
                            class="text-transparent bg-clip-text bg-gradient-to-r from-blue-600 to-emerald-500 font-bold">.ai</span>
                    </span>
                    <!-- SUBTEXT IS NOW DARKER BLUE -->

                </div>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener("DOMContentLoaded", () => {
            const overlay = document.getElementById('liquid-transition');
            const circle = document.getElementById('liquid-circle');
            const logo = document.getElementById('transition-logo');

            if (sessionStorage.getItem('morph_status') === 'active') {
                overlay.style.display = 'block';
                gsap.set(circle, { clipPath: "circle(150% at 50% 50%)" });
                gsap.set(logo, { opacity: 1, scale: 1 });
                sessionStorage.removeItem('morph_status');

                const tl = gsap.timeline();
                gsap.from("main, nav", { y: 100, scale: 0.98, duration: 1.2, ease: "power4.out" });

                tl.to(logo, { opacity: 0, scale: 0.8, duration: 0.4, ease: "power2.in" })
                    .to(circle, { clipPath: "circle(0% at 50% 50%)", duration: 1.2, ease: "expo.inOut" }, "-=0.1")
                    .set(overlay, { display: 'none' });
            }
        });

        function fluidSwitch(targetUrl, e) {
            const overlay = document.getElementById('liquid-transition');
            const circle = document.getElementById('liquid-circle');
            const logo = document.getElementById('transition-logo');
            const x = e ? e.clientX : window.innerWidth / 2;
            const y = e ? e.clientY : window.innerHeight / 2;

            overlay.style.display = 'block';
            gsap.set(circle, { clipPath: `circle(0% at ${x}px ${y}px)` });
            gsap.set(logo, { opacity: 0, scale: 0.8 });
            sessionStorage.setItem('morph_status', 'active');

            const tl = gsap.timeline({ onComplete: () => { window.location.href = targetUrl; } });

            tl.to(circle, { clipPath: `circle(150% at ${x}px ${y}px)`, duration: 1.0, ease: "expo.inOut" })
                .to(logo, { opacity: 1, scale: 1, duration: 0.5, ease: "back.out(1.7)" }, "-=0.5");

            gsap.to("main, nav", { scale: 0.95, opacity: 0.5, duration: 1.0, ease: "power2.inOut" });
        }
    </script>

    <!-- VISUAL NOISE LAYER -->
    <div class="noise-overlay"></div>

    <script>
        // --- DYNAMIC TEXT TYPEWRITER LOGIC ---
        document.addEventListener('DOMContentLoaded', () => {
            const dynamicText = document.getElementById('dynamic-text');
            const words = ["Study", "Visualize", "Interact", "Master"];
            let wordIndex = 0;
            let charIndex = 0;
            let isDeleting = false;
            let typeSpeed = 100;

            function type() {
                const currentWord = words[wordIndex];

                if (isDeleting) {
                    dynamicText.textContent = currentWord.substring(0, charIndex - 1);
                    charIndex--;
                    typeSpeed = 50; // Faster deletion
                } else {
                    dynamicText.textContent = currentWord.substring(0, charIndex + 1);
                    charIndex++;
                    typeSpeed = 150; // Normal typing
                }

                if (!isDeleting && charIndex === currentWord.length) {
                    // Word complete, pause
                    isDeleting = true;
                    typeSpeed = 2000;
                } else if (isDeleting && charIndex === 0) {
                    // Deletion complete, next word
                    isDeleting = false;
                    wordIndex = (wordIndex + 1) % words.length;
                    typeSpeed = 500;
                }

                setTimeout(type, typeSpeed);
            }

            // Start Typing Loop
            setTimeout(type, 1000);
        });
    </script>

    <!-- GOD-LEVEL NAVBAR (Consistent) -->
    <nav class="fixed top-0 w-full z-50 px-6 py-5" id="navbar">
        <div
            class="max-w-7xl mx-auto flex justify-between items-center glass-nav-container rounded-full px-8 py-3 relative">

            <!-- 1. The Energy Line -->
            <div class="nav-energy-line"></div>

            <!-- 2. The Animated Logo -->
            <a href="#" class="flex items-center gap-2 group">
                <div class="logo-mark w-10 h-10">
                    <svg viewBox="180 200 600 600" width="100%" height="100%" preserveAspectRatio="xMidYMid meet"
                        xmlns="http://www.w3.org/2000/svg">
                        <defs>
                            <linearGradient id="navLogoGrad" x1="0" x2="1" y1="0" y2="1">
                                <stop offset="0%" stop-color="#2563EB" />
                                <stop offset="50%" stop-color="#7C3AED" />
                                <stop offset="100%" stop-color="#10B981" />
                            </linearGradient>
                        </defs>
                        <path stroke="url(#navLogoGrad)"
                            d="M0 0 C12.44795096 11.15193612 25.209924 26.49916535 26.7421875 43.85644531 C26.93179549 51.49066179 26.236526 57.76844022 21.1484375 63.75097656 C14.29280134 70.0736008 5.27434454 69.52993902 -3.45703125 69.52783203 C-5.49173017 69.53221716 -7.5242755 69.56864548 -9.55859375 69.60644531 C-18.14831286 69.63200995 -23.10236282 69.23406072 -29.5 63.29785156 C-30.01433594 62.67394531 -30.52867187 62.05003906 -31.05859375 61.40722656 C-31.63867188 60.71242188 -32.21875 60.01761719 -32.81640625 59.30175781 C-34.4100245 57.26711498 -35.92582544 55.19337705 -37.43359375 53.09472656 C-44.86753252 43.15037392 -55.763018 36.58908709 -68.06640625 34.40332031 C-82.00493749 32.99153982 -95.14293339 34.40344299 -106.49609375 43.15722656 C-113.84092745 49.79045007 -118.20904961 56.6681874 -118.87109375 66.62988281 C-119.40021676 80.49483979 -117.03175699 90.70670264 -107.49609375 101.15722656 C-102.60981911 106.30604731 -97.62113337 111.27177657 -92.18359375 115.84472656 C-81.65027014 124.96504335 -74.36366647 139.40510018 -72.49609375 153.15722656 C-71.65901004 166.901601 -71.65901004 166.901601 -74.49609375 171.15722656 C-83.10650834 170.73477779 -91.01635779 169.28947525 -99.30859375 166.96972656 C-100.4471582 166.65583984 -101.58572266 166.34195313 -102.75878906 166.01855469 C-111.28613295 163.61409145 -119.43482192 160.86388701 -127.49609375 157.15722656 C-128.66914063 156.62484375 -129.8421875 156.09246094 -131.05078125 155.54394531 C-154.43275022 144.41576533 -171.50401018 127.74589403 -181.28125 103.61425781 C-189.64889096 79.80280363 -188.20222315 53.93549868 -177.49609375 31.15722656 C-172.32524034 20.77417359 -165.72074162 12.27906633 -157.49609375 4.15722656 C-156.60921875 3.27164062 -155.72234375 2.38605469 -154.80859375 1.47363281 C-113.92382881 -37.56894068 -41.95830224 -36.37228731 0 0 Z"
                            transform="translate(408.49609375,363.8427734375)" />
                        <path stroke="url(#navLogoGrad)"
                            d="M0 0 C6.34498414 -0.76650815 12.32105685 1.05255799 18.4375 2.625 C19.50355469 2.89715332 20.56960938 3.16930664 21.66796875 3.44970703 C41.10643665 8.54115356 59.43172211 16.04861213 75 29 C75.88429688 29.7321875 76.76859375 30.464375 77.6796875 31.21875 C94.28485334 45.55269255 105.96671454 65.91626071 108 88 C109.51108543 112.50639352 103.601609 135.85134046 87.07617188 154.66601562 C84.78356142 157.17789122 82.40354185 159.59478321 80 162 C79.14664063 162.8765625 78.29328125 163.753125 77.4140625 164.65625 C55.25012496 186.2211622 22.93540443 193.3964399 -6.99414062 193.30273438 C-37.11338155 192.78836404 -66.24524374 180.99860186 -87.55322266 159.52441406 C-94.89988063 151.78352098 -99.60694275 142.61723343 -104 133 C-104.38542969 132.19820312 -104.77085937 131.39640625 -105.16796875 130.5703125 C-107.24806212 124.14448415 -107.13256511 115.48193571 -105.0546875 109.09375 C-102.09187852 103.50354437 -98.75965606 99.8763342 -92.6171875 97.92578125 C-86.93905656 96.57815427 -81.24587523 96.631846 -75.4375 96.625 C-74.33986328 96.60050781 -73.24222656 96.57601562 -72.11132812 96.55078125 C-65.48794966 96.5268269 -61.27986492 96.87680652 -56 101 C-54.18216476 103.0728257 -52.62503853 105.01116308 -51.0625 107.25 C-50.20328809 108.41577064 -49.33998551 109.5785372 -48.47265625 110.73828125 C-47.84447998 111.57866943 -47.84447998 111.57866943 -47.20361328 112.43603516 C-38.10721505 124.25581752 -24.53717575 131.26811555 -10 134 C-7.05588512 134.28265107 -4.14386726 134.33446268 -1.1875 134.3125 C-0.39923828 134.30758545 0.38902344 134.3026709 1.20117188 134.29760742 C12.99441054 134.06179102 24.41558262 130.51755536 33.25 122.4375 C42.20883978 112.89715337 44.59170196 102.06923591 44.3359375 89.46484375 C43.41635524 71.61658807 28.72977732 57.17197753 16.375 45.5625 C5.98468673 35.32240812 -1.81812468 21.38973764 -2.25 6.625 C-2 3 -2 3 0 0 Z"
                            transform="translate(328,448)" />
                    </svg>
                </div>
                <div class="flex flex-col leading-none">
                    <span class="font-sans font-bold text-xl tracking-tight text-slate-800">SKILA<span
                            class="text-slate-400 font-normal">.ai</span></span>
                </div>
            </a>

            <!-- 3. Floating Pill Navigation -->
            <div class="hidden md:flex relative nav-links gap-1">
                <a href="#offer-section"
                    class="nav-link px-4 py-2 text-xs font-bold text-gray-500 tracking-wide rounded-full hover:bg-slate-100 transition-colors">OFFER</a>
                <a href="#roadmap-section"
                    class="nav-link px-4 py-2 text-xs font-bold text-gray-500 tracking-wide rounded-full hover:bg-slate-100 transition-colors">ROADMAP</a>
            </div>

            <!-- 4. Action Button (World Switch) -->
            <div class="flex items-center gap-3">
                <button onclick="fluidSwitch('developer.html', event)"
                    class="group relative px-6 py-2.5 bg-slate-900 text-white text-xs font-bold rounded-full overflow-hidden shadow-lg hover:shadow-xl transition-all hover:-translate-y-0.5">
                    <span class="relative z-10 group-hover:text-blue-400 transition-colors flex items-center gap-2">
                        <i class="fas fa-code text-blue-500"></i> BACK TO HOME
                    </span>
                    <div
                        class="absolute inset-0 bg-slate-800 translate-y-full group-hover:translate-y-0 transition-transform duration-300">
                    </div>
                </button>
                <a href="https://technirmaan.live"
                    class="group relative px-6 py-2.5 bg-gradient-to-r from-blue-600 to-emerald-500 text-white text-xs font-bold rounded-full overflow-hidden shadow-lg hover:shadow-xl transition-all hover:-translate-y-0.5 hover:scale-105">
                    <span class="relative z-10 flex items-center gap-2">
                        <i class="fas fa-sign-in-alt"></i> LOGIN
                    </span>
                </a>
            </div>
        </div>
    </nav>

    <!-- BACKGROUND THREE.JS -->
    <div id="hero-canvas" class="fixed inset-0 z-0 opacity-40"></div>

    <!-- SECTION 1: HERO -->
    <section class="min-h-screen flex flex-col justify-center items-center text-center px-6 relative z-10">
        <div class="max-w-4xl mx-auto space-y-8">

            <h1 class="text-6xl md:text-8xl font-bold text-slate-900 tracking-tight leading-[1.1]">
                The Final Stop to <br>
                <span class="text-transparent bg-clip-text bg-gradient-to-r from-blue-600 via-teal-500 to-emerald-600"
                    id="dynamic-text">Study</span>
                <span class="animate-cursor-blink text-teal-500">|</span>
            </h1>
            <p class="text-xl text-slate-500 leading-relaxed max-w-2xl mx-auto font-light">
                The complete ecosystem. Not just a path, but an immersive intelligence engine designed to make you
                visualise, interact, and master every concept.
            </p>
            <div class="pt-8">
                <button onclick="scrollToRoadmap()"
                    class="animate-bounce text-slate-400 flex flex-col items-center gap-2 mx-auto cursor-pointer">
                    <span class="text-xs font-mono uppercase tracking-widest">Explore The Map</span>
                    <i class="fas fa-chevron-down"></i>
                </button>
            </div>
        </div>
    </section>

    <!-- SECTION 2: PLATFORM FEATURES -->
    <!-- SECTION 2: WHAT WE OFFER (REDESIGNED) -->
    <section id="offer-section" class="py-32 px-6 relative z-10">
        <div class="max-w-7xl mx-auto">
            <div class="mb-24 max-w-2xl">
                <h2 class="text-4xl md:text-5xl font-bold text-slate-900 tracking-tight mb-6">
                    Not just a course. <br>
                    <span class="text-transparent bg-clip-text bg-gradient-to-r from-blue-600 to-teal-500">
                        An Intelligence Engine.
                    </span>
                </h2>
                <p class="text-lg text-slate-500 leading-relaxed">
                    We don't serve video playlists. We simulate the entire universe of a concept,
                    letting you touch, break, and rebuild it until you master it.
                </p>
            </div>

            <!-- Staggered Grid -->
            <div class="grid grid-cols-1 md:grid-cols-2 gap-8 md:gap-12 grid-staggered">

                <!-- CARD 1: STRUCTURED PATHS -->
                <div class="offer-card group" id="card-paths">
                    <!-- Layer 1: BG (Noise/Mesh) -->
                    <div class="layer-bg bg-gradient-to-br from-slate-50 to-blue-50/50"></div>
                    <!-- Layer 3: Accent (Animated Nodes) -->
                    <div class="layer-accent">
                        <svg viewBox="0 0 100 100" class="w-full h-full opacity-90">
                            <!-- Animated Path -->
                            <path d="M20,80 Q50,20 80,50" fill="none" stroke="#CBD5E1" stroke-width="4" />
                            <circle cx="20" cy="80" r="6" fill="#3B82F6" class="node-pulse" />
                            <circle cx="80" cy="50" r="6" fill="#10B981" class="node-pulse"
                                style="animation-delay: 0.5s" />
                            <circle cx="50" cy="40" r="4" fill="#64748B" class="node-ghost opacity-0" />
                        </svg>
                    </div>
                    <!-- Layer 2: Content -->
                    <div class="layer-content">
                        <h3 class="offer-title">Structured Learning Paths</h3>
                        <p class="offer-desc">Step-by-step progression with strict prerequisite flows. No random
                            jumpingbuild a solid foundation.</p>
                    </div>
                </div>

                <!-- CARD 2: INTERACTIVE SIMULATIONS -->
                <div class="offer-card group" id="card-sims">
                    <div class="layer-bg bg-gradient-to-bl from-teal-50 to-emerald-50/50"></div>
                    <div class="layer-accent">
                        <!-- Atom / Orbit Visual -->
                        <svg viewBox="0 0 100 100" class="w-full h-full">
                            <circle cx="50" cy="50" r="8" fill="#0F766E" />
                            <ellipse cx="50" cy="50" rx="30" ry="10" stroke="#14B8A6" fill="none" stroke-width="2"
                                transform="rotate(45 50 50)" class="orbit-1" />
                            <ellipse cx="50" cy="50" rx="30" ry="10" stroke="#14B8A6" fill="none" stroke-width="2"
                                transform="rotate(-45 50 50)" class="orbit-2" />
                            <circle cx="70" cy="70" r="4" fill="#F59E0B" class="electron" />
                        </svg>
                    </div>
                    <div class="layer-content">
                        <h3 class="offer-title">Interactive Simulations</h3>
                        <p class="offer-desc">Real-time cause-and-effect labs. Tweak gravity, mutate cells, or
                            stress-test bridges instantly.</p>
                    </div>
                </div>

                <!-- CARD 3: VISUAL EXECUTION -->
                <div class="offer-card group" id="card-exec">
                    <div class="layer-bg bg-gradient-to-tr from-slate-50 to-indigo-50/50"></div>
                    <div class="layer-accent">
                        <!-- Code Typing Visual -->
                        <div
                            class="font-mono text-[10px] text-slate-400 bg-slate-900/5 p-2 rounded leading-tight w-full h-full flex flex-col justify-center">
                            <span class="text-blue-600">const</span> <span class="text-slate-700">future</span> = <span
                                class="text-emerald-600">true</span>;
                            <span class="typing-cursor">|</span>
                        </div>
                    </div>
                    <div class="layer-content">
                        <h3 class="offer-title">Visual Execution</h3>
                        <p class="offer-desc">See concepts run. Code isn't just text; it's a living machine that
                            executes before your eyes.</p>
                    </div>
                </div>

                <!-- CARD 4: NESTED KNOWLEDGE -->
                <div class="offer-card group" id="card-nested">
                    <div class="layer-bg bg-gradient-to-br from-orange-50 to-amber-50/50"></div>
                    <div class="layer-accent">
                        <!-- Zoom Circles -->
                        <svg viewBox="0 0 100 100" class="w-full h-full">
                            <circle cx="50" cy="50" r="30" stroke="#F59E0B" fill="none" stroke-width="2"
                                class="zoom-circle-1" />
                            <circle cx="50" cy="50" r="15" stroke="#F59E0B" fill="none" stroke-width="2"
                                class="zoom-circle-2 opacity-50" />
                            <circle cx="50" cy="50" r="5" fill="#F59E0B" class="zoom-dot" />
                        </svg>
                    </div>
                    <div class="layer-content">
                        <h3 class="offer-title">Nested Knowledge</h3>
                        <p class="offer-desc">Zoom from broad domains into microscopic sub-topics without ever losing
                            your context.</p>
                    </div>
                </div>

                <!-- CARD 5: AI PRACTICE -->
                <div class="offer-card group" id="card-ai">
                    <div class="layer-bg bg-gradient-to-tl from-purple-50 to-pink-50/50"></div>
                    <div class="layer-accent">
                        <!-- Sparkles / Chat -->
                        <svg viewBox="0 0 100 100" class="w-full h-full text-purple-500">
                            <path d="M50,20 L53,40 L73,43 L53,46 L50,66 L47,46 L27,43 L47,40 Z" fill="currentColor"
                                class="sparkle-1" />
                            <path d="M70,70 L72,80 L82,82 L72,84 L70,94 L68,84 L58,82 L68,80 Z" fill="currentColor"
                                class="sparkle-2" style="opacity:0.6" />
                        </svg>
                    </div>
                    <div class="layer-content">
                        <h3 class="offer-title">AI-Generated Practice</h3>
                        <p class="offer-desc">Adaptive challenges that evolve with you. Never solve the same static
                            problem twice.</p>
                    </div>
                </div>

                <!-- CARD 6: CONTESTS -->
                <div class="offer-card group" id="card-contest">
                    <div class="layer-bg bg-gradient-to-r from-red-50 to-rose-50/50"></div>
                    <div class="layer-accent">
                        <!-- Stopwatch -->
                        <svg viewBox="0 0 100 100" class="w-full h-full text-rose-500">
                            <circle cx="50" cy="50" r="35" stroke="currentColor" stroke-width="4" fill="none" />
                            <path d="M50,50 L50,25" stroke="currentColor" stroke-width="4" stroke-linecap="round"
                                class="clock-hand" />
                        </svg>
                    </div>
                    <div class="layer-content">
                        <h3 class="offer-title">Time-Bound Challenges</h3>
                        <p class="offer-desc">Validate real skill under pressure. Compete in live contests to prove your
                            mastery.</p>
                    </div>
                </div>

                <!-- CARD 7: PROGRESS -->
                <div class="offer-card group" id="card-progress">
                    <div class="layer-bg bg-gradient-to-b from-blue-50 to-cyan-50/50"></div>
                    <div class="layer-accent">
                        <!-- Bar Chart -->
                        <div class="flex items-end gap-1 h-1/2 w-2/3 mx-auto">
                            <div class="w-2 bg-blue-400 rounded-t h-1/3 bar-grow"></div>
                            <div class="w-2 bg-blue-500 rounded-t h-1/2 bar-grow" style="animation-delay:0.1s"></div>
                            <div class="w-2 bg-blue-600 rounded-t h-2/3 bar-grow" style="animation-delay:0.2s"></div>
                            <div class="w-2 bg-blue-700 rounded-t h-full bar-grow" style="animation-delay:0.3s"></div>
                        </div>
                    </div>
                    <div class="layer-content">
                        <h3 class="offer-title">Skill Graphs</h3>
                        <p class="offer-desc">Visualize your growth. Track granular progress across every skill tree
                            node.</p>
                    </div>
                </div>

                <!-- CARD 8: UNIFIED -->
                <div class="offer-card group" id="card-unified">
                    <div class="layer-bg bg-gradient-to-tr from-slate-100 to-gray-200/50"></div>
                    <div class="layer-accent">
                        <!-- Merged Icons -->
                        <div class="relative w-full h-full flex items-center justify-center">
                            <i class="fas fa-cog text-2xl text-slate-400 absolute top-0 right-0 animate-spin-slow"></i>
                            <i class="fas fa-heart text-2xl text-slate-400 absolute bottom-0 left-0 animate-pulse"></i>
                            <span class="text-4xl font-bold text-slate-800"></span>
                        </div>
                    </div>
                    <div class="layer-content">
                        <h3 class="offer-title">One Platform</h3>
                        <p class="offer-desc">Engineering, Medical, Math, School. All subjects, one unified learning
                            operating system.</p>
                    </div>
                </div>

            </div>
        </div>
    </section>

    <!-- SECTION 2.5: CORTEX (BRAIN PARALLAX) -->
    <section id="cortex-section" style="height: 600vh; position: relative; z-index: 5;">
        <div class="cortex-sticky">
            <div id="cortex-canvas-container"></div>

            <!-- Text Container -->
            <div class="cortex-text-layer">
                <div class="cortex-text" id="cortex-text-1">Knowledge is Noise.</div>
                <div class="cortex-text" id="cortex-text-2">We deconstruct complex subjects into thousands of
                    fundamental nodes.</div>
                <div class="cortex-text" id="cortex-text-3">You Don't Just Learn. You Traverse.</div>
                <div class="cortex-text" id="cortex-text-4" style="color: #1E293B; text-shadow: none;">Your Journey
                    Begins Now.</div>
            </div>
        </div>
    </section>



    <!-- SECTION 3: THE DYNAMIC ROADMAP -->
    <section id="roadmap-section" class="relative">

        <!-- BREADCRUMBS -->
        <div class="breadcrumbs-ui">
            <button id="back-btn" onclick="goUpLevel()"
                class="glass-nav px-6 py-2 rounded-full text-slate-600 font-bold text-sm hover:bg-white transition-all hidden items-center gap-2">
                <i class="fas fa-arrow-left"></i> <span>Back</span>
            </button>
            <div id="current-path-display"
                class="glass-nav px-6 py-2 rounded-full text-slate-900 font-bold text-sm flex items-center gap-2">
                <i class="fas fa-home text-slate-400"></i>
                <span id="path-text">Main Learning Path</span>
            </div>
        </div>

        <!-- SVG ROAD LAYER -->
        <div class="roadmap-svg-layer">
            <svg id="road-svg" viewBox="0 0 1000 2000" preserveAspectRatio="xMidYMin slice"
                class="w-full h-full overflow-visible">
                <defs>
                    <linearGradient id="roadGradient" x1="0" x2="0" y1="0" y2="1">
                        <stop offset="0%" stop-color="#3B82F6" />
                        <stop offset="50%" stop-color="#10B981" />
                        <stop offset="100%" stop-color="#F59E0B" />
                    </linearGradient>
                </defs>
                <path id="road-base-path" class="road-base" d="" />
                <path id="road-active-path" class="road-active" d="" />
            </svg>
        </div>

        <!-- NODES CONTAINER -->
        <div id="nodes-mount" class="roadmap-nodes-container min-h-[1000px]">
            <!-- Nodes injected here -->
        </div>

    </section>

    <!-- GOD-LEVEL CTA SECTION -->
    <section id="cta-section"
        class="relative py-32 px-6 overflow-hidden bg-gradient-to-br from-slate-900 via-slate-800 to-slate-900">
        <!-- Animated Background -->
        <div class="absolute inset-0 opacity-30">
            <div class="absolute top-1/4 left-1/4 w-96 h-96 bg-blue-500 rounded-full filter blur-[100px] animate-pulse">
            </div>
            <div class="absolute bottom-1/4 right-1/4 w-96 h-96 bg-emerald-500 rounded-full filter blur-[100px] animate-pulse"
                style="animation-delay: 1s;"></div>
            <div class="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 w-[600px] h-[600px] bg-purple-500 rounded-full filter blur-[150px] animate-pulse"
                style="animation-delay: 2s;"></div>
        </div>

        <!-- Grid Pattern Overlay -->
        <div class="absolute inset-0 opacity-10"
            style="background-image: url('data:image/svg+xml,%3Csvg width=%2260%22 height=%2260%22 viewBox=%220 0 60 60%22 xmlns=%22http://www.w3.org/2000/svg%22%3E%3Cg fill=%22none%22 fill-rule=%22evenodd%22%3E%3Cg fill=%22%239C92AC%22 fill-opacity=%220.4%22%3E%3Cpath d=%22M36 34v-4h-2v4h-4v2h4v4h2v-4h4v-2h-4zm0-30V0h-2v4h-4v2h4v4h2V6h4V4h-4zM6 34v-4H4v4H0v2h4v4h2v-4h4v-2H6zM6 4V0H4v4H0v2h4v4h2V6h4V4H6z%22/%3E%3C/g%3E%3C/g%3E%3C/svg%3E');">
        </div>

        <div class="relative z-10 max-w-4xl mx-auto text-center">
            <!-- Glowing Badge -->
            <div
                class="inline-flex items-center gap-2 px-4 py-2 rounded-full bg-white/10 backdrop-blur-sm border border-white/20 text-white/80 text-sm font-medium mb-8 animate-pulse">
                <span class="w-2 h-2 rounded-full bg-emerald-400 animate-ping"></span>
                <span>The Platform is LIVE</span>
            </div>

            <!-- Main Heading -->
            <h2 class="text-4xl md:text-6xl lg:text-7xl font-bold text-white mb-6 leading-tight">
                Ready to
                <span
                    class="text-transparent bg-clip-text bg-gradient-to-r from-blue-400 via-purple-400 to-emerald-400 animate-gradient-x">Transform</span>
                <br>Your Learning?
            </h2>

            <p class="text-lg md:text-xl text-slate-400 mb-12 max-w-2xl mx-auto leading-relaxed">
                Stop watching. Start doing. Our interactive simulations and structured paths are waiting for you.
            </p>

            <!-- CTA Button -->
            <a href="https://technirmaan.live"
                class="group relative inline-flex items-center gap-3 px-10 py-5 bg-gradient-to-r from-blue-600 via-purple-600 to-emerald-600 text-white text-lg font-bold rounded-full shadow-2xl hover:shadow-[0_0_60px_rgba(59,130,246,0.5)] transition-all duration-500 hover:scale-105 overflow-hidden">

                <!-- Shimmer Effect -->
                <div
                    class="absolute inset-0 bg-gradient-to-r from-transparent via-white/30 to-transparent -translate-x-full group-hover:translate-x-full transition-transform duration-1000">
                </div>

                <span class="relative z-10">Enter the Platform</span>
                <i
                    class="fas fa-arrow-right relative z-10 group-hover:translate-x-2 transition-transform duration-300"></i>
            </a>

            <!-- Trust Indicators -->
            <div class="mt-16 flex flex-wrap justify-center items-center gap-8 text-slate-500 text-sm">
                <div class="flex items-center gap-2">
                    <i class="fas fa-users text-blue-400"></i>
                    <span>10,000+ Learners</span>
                </div>
                <div class="w-px h-4 bg-slate-700"></div>
                <div class="flex items-center gap-2">
                    <i class="fas fa-star text-yellow-400"></i>
                    <span>4.9 Rating</span>
                </div>
                <div class="w-px h-4 bg-slate-700"></div>
                <div class="flex items-center gap-2">
                    <i class="fas fa-infinity text-emerald-400"></i>
                    <span>Lifetime Access</span>
                </div>
            </div>
        </div>

        <!-- Floating Particles -->
        <div class="absolute top-10 left-10 w-4 h-4 bg-blue-400 rounded-full opacity-50 animate-float"></div>
        <div class="absolute top-20 right-20 w-3 h-3 bg-emerald-400 rounded-full opacity-50 animate-float"
            style="animation-delay: 0.5s;"></div>
        <div class="absolute bottom-20 left-1/4 w-2 h-2 bg-purple-400 rounded-full opacity-50 animate-float"
            style="animation-delay: 1s;"></div>
        <div class="absolute bottom-10 right-1/3 w-3 h-3 bg-pink-400 rounded-full opacity-50 animate-float"
            style="animation-delay: 1.5s;"></div>
    </section>

    <!-- FOOTER -->
    <footer class="bg-white border-t border-gray-200 pt-16 pb-8 px-6 relative z-20">
        <div class="max-w-7xl mx-auto">
            <div class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-12 mb-16">

                <!-- Col 1: About -->
                <div class="space-y-6">
                    <div class="flex items-center gap-3">

                        <span class="font-sans font-bold text-xl text-primary">Technirmaan</span>
                    </div>
                    <p class="text-sm text-gray-500 leading-relaxed">
                        We are dedicated to providing the best learning experience with expert guidance,
                        innovative resources, and a supportive community.
                    </p>
                    <div class="flex gap-4">
                        <!-- Socials (Styled as circles) -->
                        <a href="#"
                            class="w-10 h-10 rounded-full bg-gray-50 border border-gray-100 flex items-center justify-center text-gray-500 hover:bg-blue-50 hover:border-blue-200 hover:text-blue-600 transition-all duration-300">
                            <i class="fab fa-discord"></i>
                        </a>
                        <a href="#"
                            class="w-10 h-10 rounded-full bg-gray-50 border border-gray-100 flex items-center justify-center text-gray-500 hover:bg-pink-50 hover:border-pink-200 hover:text-pink-600 transition-all duration-300">
                            <i class="fab fa-instagram"></i>
                        </a>
                        <a href="#"
                            class="w-10 h-10 rounded-full bg-gray-50 border border-gray-100 flex items-center justify-center text-gray-500 hover:bg-blue-50 hover:border-blue-200 hover:text-blue-700 transition-all duration-300">
                            <i class="fab fa-linkedin-in"></i>
                        </a>
                        <a href="#"
                            class="w-10 h-10 rounded-full bg-gray-50 border border-gray-100 flex items-center justify-center text-gray-500 hover:bg-gray-800 hover:border-gray-800 hover:text-white transition-all duration-300">
                            <i class="fab fa-github"></i>
                        </a>
                    </div>
                </div>

                <!-- Col 2: Quick Links -->
                <div>
                    <h3 class="font-bold text-primary mb-6 text-sm uppercase tracking-wider">Quick Links</h3>
                    <ul class="space-y-3 text-sm text-gray-500 font-medium">
                        <li><a href="#"
                                class="hover:text-blue-600 hover:translate-x-1 inline-block transition-all">Home</a>
                        </li>
                        <li><a href="#" class="hover:text-blue-600 hover:translate-x-1 inline-block transition-all">DSA
                                Sheet</a></li>
                        <li><a href="#"
                                class="hover:text-blue-600 hover:translate-x-1 inline-block transition-all">Roadmaps</a>
                        </li>
                        <li><a href="#"
                                class="hover:text-blue-600 hover:translate-x-1 inline-block transition-all">Projects</a>
                        </li>
                        <li><a href="#"
                                class="hover:text-blue-600 hover:translate-x-1 inline-block transition-all">Jobs</a>
                        </li>
                    </ul>
                </div>

                <!-- Col 3: Resources (Added placeholder to balance grid) -->
                <div>
                    <h3 class="font-bold text-primary mb-6 text-sm uppercase tracking-wider">Resources</h3>
                    <ul class="space-y-3 text-sm text-gray-500 font-medium">
                        <li><a href="#"
                                class="hover:text-blue-600 hover:translate-x-1 inline-block transition-all">Documentation</a>
                        </li>
                        <li><a href="#" class="hover:text-blue-600 hover:translate-x-1 inline-block transition-all">API
                                Reference</a></li>
                        <li><a href="#"
                                class="hover:text-blue-600 hover:translate-x-1 inline-block transition-all">Community
                                Guidelines</a></li>
                        <li><a href="#"
                                class="hover:text-blue-600 hover:translate-x-1 inline-block transition-all">Privacy
                                Policy</a></li>
                    </ul>
                </div>

                <!-- Col 4: Contact -->
                <div>
                    <h3 class="font-bold text-primary mb-6 text-sm uppercase tracking-wider">Contact Us</h3>
                    <ul class="space-y-4 text-sm text-gray-500">
                        <li class="flex items-start gap-3">
                            <div
                                class="mt-1 w-8 h-8 rounded bg-blue-50 flex items-center justify-center text-blue-600 shrink-0">
                                <i class="fas fa-envelope"></i>
                            </div>
                            <div>
                                <span class="block text-xs font-bold text-gray-400 uppercase">Email</span>
                                <a href="mailto:support@technirmaan.net"
                                    class="hover:text-blue-600 transition-colors">support@technirmaan.net</a>
                            </div>
                        </li>
                        <li class="flex items-start gap-3">
                            <div
                                class="mt-1 w-8 h-8 rounded bg-emerald-50 flex items-center justify-center text-emerald-600 shrink-0">
                                <i class="fas fa-phone"></i>
                            </div>
                            <div>
                                <span class="block text-xs font-bold text-gray-400 uppercase">Phone</span>
                                <a href="tel:+919876543210" class="hover:text-emerald-600 transition-colors">+91
                                    98765 43210</a>
                            </div>
                        </li>
                    </ul>
                </div>
            </div>

            <!-- Bottom Bar -->
            <div
                class="pt-8 border-t border-gray-100 flex flex-col md:flex-row justify-between items-center gap-4 text-xs text-gray-400 font-mono">
                <div> 2025 Technirmaan. All rights reserved.</div>

            </div>
        </div>
    </footer>

    <!-- SIMULATION OVERLAY -->
    <div id="lab-modal" class="lab-modal">
        <div class="lab-console">
            <div class="h-16 bg-white border-b border-slate-200 flex justify-between items-center px-6 shrink-0">
                <div class="flex items-center gap-4">
                    <div class="flex gap-1.5">
                        <div class="w-3 h-3 rounded-full bg-red-400 hover:bg-red-500 cursor-pointer"
                            onclick="closeLab()"></div>
                        <div class="w-3 h-3 rounded-full bg-yellow-400"></div>
                        <div class="w-3 h-3 rounded-full bg-green-400"></div>
                    </div>
                    <div class="h-6 w-px bg-slate-200"></div>
                    <span class="font-mono text-sm font-bold text-slate-600 uppercase tracking-wider"
                        id="lab-title">Simulation</span>
                </div>
                <button onclick="closeLab()" class="text-slate-400 hover:text-slate-900"><i
                        class="fas fa-times text-xl"></i></button>
            </div>
            <div id="lab-viewport"
                class="flex-1 bg-slate-50 relative w-full h-full overflow-hidden flex items-center justify-center">
                <!-- Content injected -->
            </div>
            <div class="h-20 bg-white border-t border-slate-200 flex justify-end items-center px-8 shrink-0">
                <button onclick="closeLab()"
                    class="px-6 py-2.5 rounded-lg bg-slate-900 text-white font-bold hover:bg-slate-800 text-sm">Close
                    Simulation</button>
            </div>
        </div>
    </div>

    <!-- CORTEX ENGINE V4 (SHARP & DEFINED) -->
    <script>
        document.addEventListener("DOMContentLoaded", () => {
            // --- CONFIGURATION ---
            const CONFIG = {
                particleCount: 6000,
                brainSize: 25,
                connectionDistance: 4.5,
                signalCount: 150,
                signalSpeed: 0.4,
                colors: {
                    front: new THREE.Color('#3B82F6'),
                    back: new THREE.Color('#A855F7'),
                    side: new THREE.Color('#06B6D4'),
                    signal: new THREE.Color('#FFFFFF')
                }
            };

            const SECTION_ID = "cortex-section";
            const CANVAS_ID = "cortex-canvas-container";

            // --- THREE.JS SETUP ---
            const container = document.getElementById(CANVAS_ID);
            if (!container) return;

            const scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x020617, 0.02);

            const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 30; // START ZOOMED IN (was 45)

            const renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.setClearColor(0x000000, 0);
            container.appendChild(renderer.domElement);

            // --- INTERACTION STATE ---
            let mouseX = 0;
            let mouseY = 0;
            let targetRotX = 0;
            let targetRotY = 0;

            // Mouse Parallax Listener
            window.addEventListener('mousemove', (e) => {
                mouseX = (e.clientX / window.innerWidth) * 2 - 1;
                mouseY = -(e.clientY / window.innerHeight) * 2 + 1;
            });

            // --- SHARP TEXTURE ---
            const getSharpSprite = () => {
                const canvas = document.createElement('canvas');
                canvas.width = 64;
                canvas.height = 64;
                const ctx = canvas.getContext('2d');
                const gradient = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
                gradient.addColorStop(0, 'rgba(255,255,255,1)');
                gradient.addColorStop(0.3, 'rgba(255,255,255,0.2)');
                gradient.addColorStop(1, 'rgba(0,0,0,0)');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, 64, 64);
                return new THREE.CanvasTexture(canvas);
            };
            const particleTexture = getSharpSprite();

            // --- BRAIN GENERATION ---
            const brainGeo = new THREE.BufferGeometry();
            const positions = [];
            const colors = [];
            const sizes = [];
            const randoms = [];

            const isInsideEllipsoid = (x, y, z, rx, ry, rz) => {
                return (x * x) / (rx * rx) + (y * y) / (ry * ry) + (z * z) / (rz * rz) <= 1;
            };

            let pCount = 0;
            let attempts = 0;
            while (pCount < CONFIG.particleCount && attempts < 150000) {
                attempts++;
                const r = CONFIG.brainSize;
                const x = (Math.random() * 2 - 1) * r;
                const y = (Math.random() * 2 - 1) * (r * 0.8);
                const z = (Math.random() * 2 - 1) * (r * 1.2);

                let valid = false;

                // 1. Cerebrum
                const hemX = Math.abs(x);
                if (hemX > 0.8) {
                    if (isInsideEllipsoid(hemX - 2.5, y, z, 7, 8.5, 9.5)) valid = true;
                }
                // 2. Cerebellum
                if (!valid && y < -4 && z < -5) {
                    if (isInsideEllipsoid(x, y + 5, z + 6, 5.5, 4, 4)) valid = true;
                }
                // 3. Stem
                if (!valid && y < -6 && Math.abs(x) < 3.5 && Math.abs(z) < 3.5) {
                    if (x * x + z * z < 6 && y > -14) valid = true;
                }

                if (valid) {
                    const noise = 0.5;
                    const scale = 0.4;
                    const nx = Math.sin(x * scale) * Math.cos(y * scale);
                    const ny = Math.sin(y * scale) * Math.cos(z * scale);
                    const nz = Math.sin(z * scale) * Math.cos(x * scale);

                    const fx = x + nx * noise;
                    const fy = y + ny * noise;
                    const fz = z + nz * noise;

                    const color = new THREE.Color();
                    if (fz > 3) color.copy(CONFIG.colors.front);
                    else if (fz < -3) color.copy(CONFIG.colors.back);
                    else color.copy(CONFIG.colors.side);
                    color.offsetHSL(0.01, 0.05, 0);

                    positions.push(fx, fy, fz);
                    colors.push(color.r, color.g, color.b);
                    sizes.push(Math.random() * 0.5 + 0.4);
                    randoms.push(Math.random());

                    pCount++;
                }
            }

            brainGeo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            brainGeo.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            brainGeo.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));

            const basePositions = Float32Array.from(positions);

            // --- MATERIALS ---
            const particlesMaterial = new THREE.PointsMaterial({
                size: 0.6,
                vertexColors: true,
                map: particleTexture,
                transparent: true,
                opacity: 0.9,
                depthWrite: false,
                blending: THREE.AdditiveBlending,
                sizeAttenuation: true
            });
            const brainParticles = new THREE.Points(brainGeo, particlesMaterial);
            scene.add(brainParticles);

            // --- LINES ---
            const linePositions = [];
            const lineColors = [];
            const connections = [];

            for (let i = 0; i < pCount; i++) {
                for (let j = 1; j < 30; j++) {
                    const idxB = (i + j) % pCount;
                    const dist = Math.sqrt(
                        (positions[i * 3] - positions[idxB * 3]) ** 2 +
                        (positions[i * 3 + 1] - positions[idxB * 3 + 1]) ** 2 +
                        (positions[i * 3 + 2] - positions[idxB * 3 + 2]) ** 2
                    );

                    if (dist < CONFIG.connectionDistance) {
                        linePositions.push(
                            positions[i * 3], positions[i * 3 + 1], positions[i * 3 + 2],
                            positions[idxB * 3], positions[idxB * 3 + 1], positions[idxB * 3 + 2]
                        );
                        lineColors.push(
                            colors[i * 3] * 0.3, colors[i * 3 + 1] * 0.3, colors[i * 3 + 2] * 0.3,
                            colors[idxB * 3] * 0.3, colors[idxB * 3 + 1] * 0.3, colors[idxB * 3 + 2] * 0.3
                        );
                        connections.push({
                            start: new THREE.Vector3(positions[i * 3], positions[i * 3 + 1], positions[i * 3 + 2]),
                            end: new THREE.Vector3(positions[idxB * 3], positions[idxB * 3 + 1], positions[idxB * 3 + 2]),
                        });
                    }
                }
            }

            const linesGeo = new THREE.BufferGeometry();
            linesGeo.setAttribute('position', new THREE.Float32BufferAttribute(linePositions, 3));
            linesGeo.setAttribute('color', new THREE.Float32BufferAttribute(lineColors, 3));
            const linesMaterial = new THREE.LineBasicMaterial({
                vertexColors: true,
                transparent: true,
                opacity: 0.15,
                blending: THREE.AdditiveBlending
            });
            const brainLines = new THREE.LineSegments(linesGeo, linesMaterial);
            scene.add(brainLines);


            // --- SIGNALS ---
            const signalGeo = new THREE.BufferGeometry();
            const signalPositions = new Float32Array(CONFIG.signalCount * 3);
            const signalProgs = new Float32Array(CONFIG.signalCount);
            const signalRoutes = [];

            for (let i = 0; i < CONFIG.signalCount; i++) {
                signalRoutes[i] = Math.floor(Math.random() * connections.length);
                signalProgs[i] = Math.random();
            }
            const signalMat = new THREE.PointsMaterial({
                color: 0xFFFFFF,
                size: 1.0,
                map: particleTexture,
                transparent: true,
                opacity: 1,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });
            const signals = new THREE.Points(signalGeo, signalMat);
            scene.add(signals);

            const brainGroup = new THREE.Group();
            brainGroup.add(brainParticles);
            brainGroup.add(brainLines);
            brainGroup.add(signals);
            scene.add(brainGroup);


            // --- ANIMATION ---
            let time = 0;
            // Removed explicit `isActive` check from loop body to prevent "Poff" (freeze)
            // We will rely on GSAP visibility and simple boolean for optimization, but ALWAYS recurse.
            let renderActive = true;

            // Fast access
            const posAttr = brainGeo.attributes.position;

            function animate() {
                if (renderActive) {
                    time += 0.015;
                    // Mouse Parallax
                    brainGroup.rotation.x += (mouseY * 0.1 - brainGroup.rotation.x) * 0.05;
                    brainGroup.rotation.y += (mouseX * 0.15 - brainGroup.rotation.y) * 0.05;
                    brainGroup.rotation.z = Math.cos(time * 0.05) * 0.02;

                    // Particle Wiggle
                    for (let i = 0; i < pCount; i++) {
                        const ix = i * 3;
                        const rnd = randoms[i];
                        const wiggle = Math.sin(time * 2 + rnd * 10) * 0.05;

                        posAttr.array[ix] = basePositions[ix] + wiggle;
                        posAttr.array[ix + 1] = basePositions[ix + 1] + wiggle;
                        posAttr.array[ix + 2] = basePositions[ix + 2] + Math.cos(time * 1.5 + rnd * 10) * 0.05;
                    }
                    posAttr.needsUpdate = true;

                    // Signals
                    for (let i = 0; i < CONFIG.signalCount; i++) {
                        signalProgs[i] += CONFIG.signalSpeed * 0.1;
                        if (signalProgs[i] >= 1) {
                            signalProgs[i] = 0;
                            signalRoutes[i] = Math.floor(Math.random() * connections.length);
                        }
                        const route = connections[signalRoutes[i]];
                        const alpha = signalProgs[i];
                        signalPositions[i * 3] = route.start.x + (route.end.x - route.start.x) * alpha;
                        signalPositions[i * 3 + 1] = route.start.y + (route.end.y - route.start.y) * alpha;
                        signalPositions[i * 3 + 2] = route.start.z + (route.end.z - route.start.z) * alpha;
                    }
                    signalGeo.setAttribute('position', new THREE.BufferAttribute(signalPositions, 3));
                    signalGeo.attributes.position.needsUpdate = true;

                    renderer.render(scene, camera);
                }
                requestAnimationFrame(animate);
            }
            animate();

            // Resize
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });

            // --- CHOREOGRAPHY (FIXED) ---
            if (typeof gsap !== 'undefined' && typeof ScrollTrigger !== 'undefined') {
                gsap.registerPlugin(ScrollTrigger);

                const sectionData = document.getElementById(SECTION_ID);

                // Helper to ensure visibility on re-entry
                function ensureVisible() {
                    renderActive = true;
                    // Force logic enable
                }

                const tl = gsap.timeline({
                    scrollTrigger: {
                        trigger: sectionData,
                        start: "top top",
                        end: "+=5000", // EXTENDED DURATION (Longer Interaction)
                        scrub: 1,
                        pin: ".cortex-sticky",
                        onEnter: ensureVisible,
                        onEnterBack: ensureVisible, // Ensure it comes back!
                        onLeave: () => { renderActive = false; },
                        onLeaveBack: () => { renderActive = false; },
                    }
                });

                // SCENE 1: Intro / Reset
                tl.fromTo(brainGroup.rotation, { y: 1.6 }, { y: 0, duration: 2.5, ease: "power2.out" }, 0)
                    .to(camera.position, { z: 30, duration: 3, ease: "power1.inOut" }, 0)
                    .fromTo("#cortex-text-1", { opacity: 0, scale: 0.8 }, { opacity: 1, scale: 1, duration: 1 }, 0.5)
                    .to("#cortex-text-1", { opacity: 0, y: -30, filter: "blur(8px)", duration: 1 }, 2);

                // SCENE 2: Analyze
                tl.to(camera.position, { z: 20, duration: 3 }, 2.5)
                    .to(brainGroup.rotation, { x: 0.3, duration: 3 }, 2.5)
                    .fromTo("#cortex-text-2", { opacity: 0, scale: 0.9 }, { opacity: 1, scale: 1, duration: 1 }, 3)
                    .to("#cortex-text-2", { opacity: 0, y: -30, filter: "blur(8px)", duration: 1 }, 4.5);

                // SCENE 3: Dive (DEEP)
                tl.to(camera.position, { z: -50, duration: 5, ease: "power2.in" }, 5) // Deep Zoom
                    .to(brainGroup.rotation, { x: 0, y: 0, duration: 5 }, 5)
                    .fromTo("#cortex-text-3", { opacity: 0, scale: 0.8 }, { opacity: 1, scale: 1.2, duration: 1.5 }, 5.5)
                    .to("#cortex-text-3", { opacity: 0, scale: 2, filter: "blur(10px)", duration: 1 }, 9);

                // SCENE 4: Exit (Clean)
                tl.to([particlesMaterial, linesMaterial, signalMat], { opacity: 0, duration: 1 }, 9.5)
                    .to(camera.position, { z: -80, duration: 2.5 }, 9.5)
                    .to("#cortex-section", { backgroundColor: "#F8FAFC", duration: 1.5 }, 9.5)
                    .to(scene.fog, { color: "#F8FAFC", density: 0.05, duration: 1.5 }, 9.5)
                    .fromTo("#cortex-text-4", { opacity: 0, y: 50 }, { opacity: 1, y: 0, duration: 1, ease: "back.out" }, 10.5);
            }
        });

        document.addEventListener('contextmenu', (e) => e.preventDefault());

        function ctrlShiftKey(e, keyCode) {
            return e.ctrlKey && e.shiftKey && e.keyCode === keyCode.charCodeAt(0);
        }

        document.onkeydown = (e) => {
            // Disable F12, Ctrl + Shift + I, Ctrl + Shift + J, Ctrl + U
            if (
                event.keyCode === 123 ||
                ctrlShiftKey(e, 'I') ||
                ctrlShiftKey(e, 'J') ||
                ctrlShiftKey(e, 'C') ||
                (e.ctrlKey && e.keyCode === 'U'.charCodeAt(0))
            )
                return false;
        };

    </script>

    <!-- LOGIC -->
    <script>
        // =====================================================
        // 1. DATA STRUCTURE (THE BRAIN)
        // =====================================================

        // Ensure Plugin Registration
        if (typeof gsap !== 'undefined') {
            gsap.registerPlugin(ScrollTrigger, MotionPathPlugin);
        }

        const ROADMAP_DATA = {
            "root": {
                title: "Main Learning Path",
                color: "#F8FAFC",
                desc: "Choose a discipline to begin your journey.",
                nodes: [
                    { id: "eng", title: "Engineering", icon: "fa-cogs", desc: "Build the future with technology.", target: "eng-map", type: "folder" },
                    { id: "med", title: "Medical", icon: "fa-heartbeat", desc: "Heal the world with science.", target: "med-map", type: "folder" },
                    { id: "phy", title: "Physics", icon: "fa-atom", desc: "The Laws of the Universe.", target: "physics-map", type: "folder" },
                    { id: "chem", title: "Chemistry", icon: "fa-flask", desc: "Matter & Reactions.", target: "chem-map", type: "folder" },
                    { id: "math", title: "Mathematics", icon: "fa-square-root-alt", desc: "The language of the universe.", target: "math-map", type: "folder" },
                    { id: "school", title: "School (Grades 1-12)", icon: "fa-graduation-cap", desc: "Foundational knowledge for all.", target: "school-map", type: "folder" }
                ]
            },

            // --- ENGINEERING BRANCH ---
            "eng-map": {
                title: "Engineering Disciplines",
                parent: "root",
                color: "#EFF6FF",
                nodes: [
                    { id: "cs", title: "Computer Science", icon: "fa-laptop-code", desc: "Algorithms & Systems", type: "leaf", sim: "cs" },
                    { id: "eee", title: "Electrical Engineering", icon: "fa-bolt", desc: "Circuits & Power Systems", type: "leaf", sim: "electrical" },
                    { id: "ece", title: "Electronics & Comm.", icon: "fa-broadcast-tower", desc: "Signal Processing & Modulation", type: "leaf", sim: "ece" },
                    { id: "mech", title: "Mechanical Engineering", icon: "fa-cogs", desc: "Kinematics & Thermodynamics", type: "leaf", sim: "mech" },
                    { id: "aiml", title: "AI & Machine Learning", icon: "fa-brain", desc: "Neural Networks & Deep Learning", type: "leaf", sim: "neural" },
                    { id: "datascience", title: "Data Science", icon: "fa-database", desc: "K-Means & Voronoi Classification", type: "leaf", sim: "datascience" },
                    { id: "it", title: "Information Technology", icon: "fa-server", desc: "Distributed Systems & Failover", type: "leaf", sim: "it" },
                    { id: "civil", title: "Civil Engineering", icon: "fa-hard-hat", desc: "Infrastructure & Structures", type: "leaf", sim: "civil" }
                ]
            },

            // --- PHYSICS BRANCH (NEW) ---
            "physics-map": {
                title: "Physics Modules",
                parent: "root",
                color: "#F0F9FF",
                nodes: [
                    { id: "quantum", title: "Quantum Wave Tank", icon: "fa-wave-square", desc: "Double-Slit & Interference", type: "leaf", sim: "quantum-wave" },
                    { id: "chaos", title: "Chaos Theory Engine", icon: "fa-infinity", desc: "Double Pendulum & RK4", type: "leaf", sim: "chaos-pendulum" },
                    { id: "aero", title: "Aero-Dynamics Lab", icon: "fa-wind", desc: "CFD & Turbulence", type: "leaf", sim: "wind-tunnel" },
                    { id: "gravity", title: "Relativity Raytracer", icon: "fa-atom", desc: "Black Hole & Event Horizon", type: "leaf", sim: "gravity-well" },
                    { id: "optics", title: "Photon Logic Lab", icon: "fa-lightbulb", desc: "Reflection, Refraction, Prisms", type: "leaf", sim: "optics-lab" },
                    { id: "thermo", title: "Thermodynamics Engine", icon: "fa-fire", desc: "Entropy & Maxwell's Demon", type: "leaf", sim: "thermo-lab" }
                ]
            },

            // --- MEDICAL BRANCH ---
            "med-map": {
                title: "Medical Sciences",
                parent: "root",
                color: "#F0FDF4",
                nodes: [
                    { id: "dental", title: "Dental", icon: "fa-tooth", desc: "Oral Health & Care", type: "leaf", sim: "dental" },
                    { id: "cardio", title: "Cardiology", icon: "fa-heart", desc: "Heart & Cardiovascular Systems", type: "leaf", sim: "cardio" },
                    { id: "eye", title: "Ophthalmology", icon: "fa-eye", desc: "Vision & Eye Mechanics", type: "leaf", sim: "eye" },
                    { id: "liver", title: "Hepatology", icon: "fa-flask", desc: "Liver & Metabolic Systems", type: "leaf", sim: "liver" }
                ]
            },

            // --- CHEMISTRY BRANCH ---
            "chem-map": {
                title: "Chemistry",
                parent: "root",
                color: "#F0F9FF",
                nodes: [
                    { id: "atoms", title: "Atomic Bonding", icon: "fa-atom", desc: "Valence, Ionic & Covalent Bonds", type: "leaf", sim: "molecules" },
                    { id: "kinetics", title: "Reaction Kinetics", icon: "fa-fire", desc: "Collision Theory & Activation Energy", type: "leaf", sim: "reaction" },
                    { id: "phases", title: "States of Matter", icon: "fa-snowflake", desc: "Phase Transitions & Intermolecular Forces", type: "leaf", sim: "phases" },
                    { id: "battery", title: "Galvanic Cell", icon: "fa-battery-full", desc: "Redox Reactions & Electrochemistry", type: "leaf", sim: "battery" }
                ]
            },

            // --- MATH BRANCH ---
            "math-map": {
                title: "Mathematics",
                parent: "root",
                color: "#F5F3FF",
                nodes: [
                    { id: "alg", title: "Algebra", icon: "fa-superscript", desc: "Variables & Equations", type: "leaf", sim: "algebra" },
                    { id: "calc", title: "Calculus", icon: "fa-infinity", desc: "Derivatives & Integrals", type: "leaf", sim: "calc" },
                    { id: "geo", title: "Geometry", icon: "fa-shapes", desc: "Shapes & Spatial Reasoning", type: "leaf", sim: "geometry" },
                    { id: "stat", title: "Statistics", icon: "fa-chart-bar", desc: "Data Analysis & Probability", type: "leaf", sim: "stats" }
                ]
            },

            // --- SCHOOL BRANCH ---
            "school-map": {
                title: "School Grades (1-12)",
                parent: "root",
                color: "#FFF7ED",
                nodes: [] // Populated dynamically below
            }
        };

        // Populate School Grades 1-12
        for (let i = 1; i <= 12; i++) {
            const gradeId = `grade-${i}`;
            const gradeMapId = `grade-${i}-map`;

            ROADMAP_DATA["school-map"].nodes.push({
                id: gradeId,
                title: `Grade ${i}`,
                icon: "fa-book-open",
                desc: `Curriculum for Grade ${i}`,
                target: gradeMapId,
                type: "folder"
            });

            // Create the map for each grade
            ROADMAP_DATA[gradeMapId] = {
                title: `Grade ${i} Subjects`,
                parent: "school-map",
                color: "#FFF7ED",
                nodes: [
                    { id: `g${i}-sci`, title: "Science", icon: "fa-flask", desc: "Physics, Chemistry, Biology", type: "leaf", sim: "science" },
                    { id: `g${i}-math`, title: "Maths", icon: "fa-calculator", desc: "Numbers & Logic", type: "leaf", sim: "calc" },
                    { id: `g${i}-bio`, title: "Biology", icon: "fa-dna", desc: "Life Sciences", type: "leaf", sim: "bio" },
                    { id: `g${i}-soc`, title: "Social Studies", icon: "fa-globe", desc: "History & Civics", type: "leaf", sim: "social" },
                    { id: `g${i}-gk`, title: "General Knowledge", icon: "fa-lightbulb", desc: "World Awareness", type: "leaf", sim: "gk" }
                ]
            };

            // OVERRIDE FOR GRADE 1
            if (i === 1) {
                ROADMAP_DATA[gradeMapId].nodes = [
                    { id: `g1-sci`, title: "Light & Shadow", icon: "fa-sun", desc: "Sun Position & Ray Casting", type: "leaf", sim: "grade1-shadow" },
                    { id: `g1-math`, title: "Gravity Counting", icon: "fa-sort-numeric-down", desc: "Physics Addition & Subtraction", type: "leaf", sim: "grade1-counting" },
                    { id: `g1-bio`, title: "Plant Growth", icon: "fa-seedling", desc: "Sun + Water = Life", type: "leaf", sim: "grade1-plant" },
                    { id: `g1-soc`, title: "Day & Night", icon: "fa-globe-americas", desc: "Earth Spin & Time Zones", type: "leaf", sim: "grade1-globe" },
                    { id: `g1-gk`, title: "Color Alchemy", icon: "fa-palette", desc: "Primary & Secondary Mixing", type: "leaf", sim: "grade1-colors" }
                ];
            }

            // OVERRIDE FOR GRADE 2
            if (i === 2) {
                ROADMAP_DATA[gradeMapId].nodes = [
                    { id: `g2-sci`, title: "Magnetic Fields", icon: "fa-magnet", desc: "Attraction, Repulsion & Flux", type: "leaf", sim: "grade2-magnets" },
                    { id: `g2-math`, title: "Kinetic Place Value", icon: "fa-cubes", desc: "Hundreds, Tens, Ones Factory", type: "leaf", sim: "grade2-placevalue" },
                    { id: `g2-bio`, title: "Butterfly Cycle", icon: "fa-bug", desc: "Metamorphosis Timeline", type: "leaf", sim: "grade2-meta" },
                    { id: `g2-soc`, title: "Isometric Compass", icon: "fa-compass", desc: "N-S-E-W Navigation", type: "leaf", sim: "grade2-compass" },
                    { id: `g2-gk`, title: "Gearwork Clock", icon: "fa-clock", desc: "Time & Gear Ratios", type: "leaf", sim: "grade2-clock" }
                ];
            }

            // OVERRIDE FOR GRADE 3
            if (i === 3) {
                ROADMAP_DATA[gradeMapId].nodes = [
                    { id: `g3-sci`, title: "Water Cycle", icon: "fa-cloud-rain", desc: "Evaporation & Precipitation", type: "leaf", sim: "grade3-water" },
                    { id: `g3-math`, title: "Fraction Slicer", icon: "fa-pizza-slice", desc: "Parts of a Whole", type: "leaf", sim: "grade3-fractions" },
                    { id: `g3-bio`, title: "Food Chain", icon: "fa-link", desc: "Predator & Prey Balance", type: "leaf", sim: "grade3-foodchain" },
                    { id: `g3-soc`, title: "City Builder", icon: "fa-city", desc: "Landforms & Settlement", type: "leaf", sim: "grade3-city" },
                    { id: `g3-gk`, title: "Solar System", icon: "fa-star", desc: "Planets & Gravity", type: "leaf", sim: "grade3-solar" }
                ];
            }

            // OVERRIDE FOR GRADE 4
            if (i === 4) {
                ROADMAP_DATA[gradeMapId].nodes = [
                    { id: `g4-sci`, title: "Lever Lab", icon: "fa-balance-scale-right", desc: "Torque & Mech Advantage", type: "leaf", sim: "grade4-lever" },
                    { id: `g4-math`, title: "Area Architect", icon: "fa-vector-square", desc: "Perimeter vs Area", type: "leaf", sim: "grade4-area" },
                    { id: `g4-bio`, title: "Photosynthesis", icon: "fa-leaf", desc: "Sugar Factory", type: "leaf", sim: "grade4-photo" },
                    { id: `g4-soc`, title: "Global Grid", icon: "fa-globe", desc: "Latitude & Longitude", type: "leaf", sim: "grade4-latlong" },
                    { id: `g4-gk`, title: "Moon Phases", icon: "fa-moon", desc: "Orbit & Shadows", type: "leaf", sim: "grade4-moon" }
                ];
            }

            // OVERRIDE FOR GRADE 5
            if (i === 5) {
                ROADMAP_DATA[gradeMapId].nodes = [
                    { id: `g5-sci`, title: "Circuit Architect", icon: "fa-bolt", desc: "Series, Parallel & Logic", type: "leaf", sim: "grade5-circuits" },
                    { id: `g5-math`, title: "Volume Packer", icon: "fa-cubes", desc: "V = L x W x H", type: "leaf", sim: "grade5-volume" },
                    { id: `g5-bio`, title: "Pneumatic Lungs", icon: "fa-lungs", desc: "Pressure & Breathing", type: "leaf", sim: "grade5-lung" },
                    { id: `g5-soc`, title: "Topo Maps", icon: "fa-map-marked-alt", desc: "2D Contour to 3D", type: "leaf", sim: "grade5-topo" },
                    { id: `g5-gk`, title: "Recycling Sorter", icon: "fa-recycle", desc: "Physics Sorting", type: "leaf", sim: "grade5-recycle" }
                ];
            }

            // OVERRIDE FOR GRADE 6
            if (i === 6) {
                ROADMAP_DATA[gradeMapId].nodes = [
                    { id: `g6-sci`, title: "Optical Laser Lab", icon: "fa-magic", desc: "Reflection & Refraction", type: "leaf", sim: "grade6-light" },
                    { id: `g6-math`, title: "Algebra Balance", icon: "fa-balance-scale-left", desc: "Solving X", type: "leaf", sim: "grade6-algebra" },
                    { id: `g6-bio`, title: "Skeletal Rig", icon: "fa-bone", desc: "IK Puppetry", type: "leaf", sim: "grade6-skeletal" },
                    { id: `g6-soc`, title: "Time Drill", icon: "fa-hourglass-half", desc: "Stratigraphy Dig", type: "leaf", sim: "grade6-arch" },
                    { id: `g6-gk`, title: "Enigma Cipher", icon: "fa-user-secret", desc: "Cryptography", type: "leaf", sim: "grade6-cipher" }
                ];
            }

            // OVERRIDE FOR GRADE 7
            if (i === 7) {
                ROADMAP_DATA[gradeMapId].nodes = [
                    { id: `g7-sci`, title: "Universal pH Lab", icon: "fa-flask", desc: "Acids, Bases & Neutrals", type: "leaf", sim: "grade7-ph" },
                    { id: `g7-math`, title: "Transversal City", icon: "fa-city", desc: "Parallel Lines & Angles", type: "leaf", sim: "grade7-transversal" },
                    { id: `g7-bio`, title: "Gas Exchange", icon: "fa-lungs-virus", desc: "Alveoli Diffusion", type: "leaf", sim: "grade7-gas" },
                    { id: `g7-soc`, title: "Greenhouse", icon: "fa-temperature-high", desc: "Global Warming Model", type: "leaf", sim: "grade7-greenhouse" },
                    { id: `g7-gk`, title: "Logic Gates", icon: "fa-microchip", desc: "Boolean Circuits", type: "leaf", sim: "grade7-logic" }
                ];
            }

            // OVERRIDE FOR GRADE 8
            if (i === 8) {
                ROADMAP_DATA[gradeMapId].nodes = [
                    { id: `g8-sci`, title: "Acoustic Physics", icon: "fa-volume-up", desc: "Sound Waves & Media", type: "leaf", sim: "grade8-sound" },
                    { id: `g8-math`, title: "Flight Algebra", icon: "fa-fighter-jet", desc: "Linear Equations", type: "leaf", sim: "grade8-flight" },
                    { id: `g8-bio`, title: "Cell City RTS", icon: "fa-dna", desc: "Organelle Tycoon", type: "leaf", sim: "grade8-cell" },
                    { id: `g8-soc`, title: "Steam Revolution", icon: "fa-cogs", desc: "Thermodynamics", type: "leaf", sim: "grade8-steam" },
                    { id: `g8-gk`, title: "Packet Matrix", icon: "fa-network-wired", desc: "Internet Routing", type: "leaf", sim: "grade8-internet" }
                ];
            }

            // OVERRIDE FOR GRADE 9
            if (i === 9) {
                ROADMAP_DATA[gradeMapId].nodes = [
                    { id: `g9-sci`, title: "Ballistic Range", icon: "fa-crosshairs", desc: "Projectile Vectors", type: "leaf", sim: "grade9-physics" },
                    { id: `g9-math`, title: "Unit Circle", icon: "fa-circle-notch", desc: "Trig Functions", type: "leaf", sim: "grade9-trig" },
                    { id: `g9-bio`, title: "DNA Helicase", icon: "fa-dna", desc: "Genetics Unzip", type: "leaf", sim: "grade9-dna" },
                    { id: `g9-soc`, title: "Market Eq.", icon: "fa-chart-line", desc: "Supply & Demand", type: "leaf", sim: "grade9-market" },
                    { id: `g9-gk`, title: "Wealth Garden", icon: "fa-seedling", desc: "Compound Interest", type: "leaf", sim: "grade9-interest" }
                ];
            }

            // OVERRIDE FOR GRADE 10
            if (i === 10) {
                ROADMAP_DATA[gradeMapId].nodes = [
                    { id: `g10-sci`, title: "DC Electric Motor", icon: "fa-bolt", desc: "Lorentz Force Engine", type: "leaf", sim: "grade10-motor" },
                    { id: `g10-math`, title: "Parabolic Array", icon: "fa-satellite-dish", desc: "Quadratic Reflection", type: "leaf", sim: "grade10-parabola" },
                    { id: `g10-bio`, title: "Heredity Garden", icon: "fa-leaf", desc: "Mendelian Genetics", type: "leaf", sim: "grade10-heredity" },
                    { id: `g10-soc`, title: "Demographics", icon: "fa-users", desc: "Population Pyramids", type: "leaf", sim: "grade10-pop" },
                    { id: `g10-gk`, title: "Encryption Key", icon: "fa-user-secret", desc: "Diffie-Hellman", type: "leaf", sim: "grade10-crypto" }
                ];
            }

            // OVERRIDE FOR GRADE 11 (Science -> Physics, Social -> Chem, GK -> CS)
            if (i === 11) {
                ROADMAP_DATA[gradeMapId].nodes = [
                    { id: `g11-phy`, title: "Physics: Vectors", icon: "fa-arrows-alt", desc: "Force & Motion", type: "leaf", sim: "grade11-vectors" },
                    { id: `g11-math`, title: "Math: Complex #'s", icon: "fa-superscript", desc: "Imaginary Plane", type: "leaf", sim: "grade11-complex" },
                    { id: `g11-chem`, title: "Chem: VSEPR", icon: "fa-atom", desc: "Molecular Geometry", type: "leaf", sim: "grade11-vsepr" },
                    { id: `g11-bio`, title: "Bio: Neuron", icon: "fa-brain", desc: "Action Potential", type: "leaf", sim: "grade11-neuron" },
                    { id: `g11-cs`, title: "CS: Recursion", icon: "fa-laptop-code", desc: "Fractals & Logic", type: "leaf", sim: "grade11-recursion" }
                ];
            }

            // OVERRIDE FOR GRADE 12
            if (i === 12) {
                ROADMAP_DATA[gradeMapId].nodes = [
                    { id: `g12-phy`, title: "Physics: AC Gen", icon: "fa-bolt", desc: "Electromagnetism", type: "leaf", sim: "grade12-generator" },
                    { id: `g12-math`, title: "Math: Integrals", icon: "fa-integral", desc: "Area Under Curve", type: "leaf", sim: "grade12-integral" },
                    { id: `g12-chem`, title: "Chem: Equilibrium", icon: "fa-balance-scale", desc: "Le Chatelier", type: "leaf", sim: "grade12-equilibrium" },
                    { id: `g12-bio`, title: "Bio: Translation", icon: "fa-dna", desc: "Protein Synthesis", type: "leaf", sim: "grade12-translation" },
                    { id: `g12-cs`, title: "CS: Pathfinding", icon: "fa-map-signs", desc: "A* Algorithm", type: "leaf", sim: "grade12-pathfinding" }
                ];
            }
        }


        // =====================================================
        // 2. ENGINE LOGIC
        // =====================================================
        let currentMapID = "root";
        const nodesMount = document.getElementById('nodes-mount');
        const backBtn = document.getElementById('back-btn');
        const pathText = document.getElementById('path-text');
        const roadBase = document.getElementById('road-base-path');
        const roadActive = document.getElementById('road-active-path');
        const svgBox = document.getElementById('road-svg');

        // Initial Render
        renderMap("root");

        function scrollToRoadmap() {
            gsap.to(window, { scrollTo: "#roadmap-section", duration: 0.8 });
        }

        function goUpLevel() {
            const currentData = ROADMAP_DATA[currentMapID];
            if (currentData && currentData.parent) {
                renderMap(currentData.parent);
            }
        }




        // =====================================================
        // 3. LAB SIMULATION ENGINES
        // =====================================================
        function launchLab(simType, title) {
            const modal = document.getElementById('lab-modal');
            const vp = document.getElementById('lab-viewport');
            const labTitle = document.getElementById('lab-title');
            labTitle.innerText = "Simulation: " + title;
            modal.classList.add('active');

            // Reset Viewport
            vp.innerHTML = '';

            // SPECIAL HANDLE: CS SIMULATION (Standalone File)
            if (simType === 'cs' || simType === 'algo') {
                vp.innerHTML = `
                    <iframe src="computer_science_sim.html" 
                        style="width: 100%; height: 100%; border: none;"
                        allow="fullscreen">
                    </iframe>
                `;
                return;
            }

            // SPECIAL HANDLE: ELECTRICAL SIMULATION (Standalone File)
            if (simType === 'electrical' || simType === 'eee') {
                vp.innerHTML = `
                    <iframe src="electrical_engineering_sim.html" 
                        style="width: 100%; height: 100%; border: none;"
                        allow="fullscreen">
                    </iframe>
                `;
                return;
            }

            // SPECIAL HANDLE: ECE SIMULATION (Standalone File)
            if (simType === 'ece') {
                vp.innerHTML = `
            <iframe src="ece_dsp_sim.html" 
                style="width: 100%; height: 100%; border: none;"
                allow="fullscreen">
            </iframe>
        `;
                return;
            }

            // SPECIAL HANDLE: MECH SIMULATION (Standalone File)
            if (simType === 'mech') {
                vp.innerHTML = `
            <iframe src="mechanical_engine_sim.html" 
                style="width: 100%; height: 100%; border: none;"
                allow="fullscreen">
            </iframe>
        `;
                return;
            }

            // SPECIAL HANDLE: IT SERVER SIMULATION (Standalone File)
            if (simType === 'it') {
                vp.innerHTML = `
            <iframe src="it_server_sim.html" 
                style="width: 100%; height: 100%; border: none;"
                allow="fullscreen">
            </iframe>
        `;
                return;
            }

            // SPECIAL HANDLE: DATA SCIENCE SIMULATION
            if (simType === 'datascience') {
                vp.innerHTML = `
                    <iframe src="datascience_sim.html" 
                        style="width: 100%; height: 100%; border: none;"
                        allow="fullscreen">
                    </iframe>
                `;
                return;
            }

            // SPECIAL HANDLE: QUANTUM WAVE SIMULATION (Standalone File)
            if (simType === 'quantum-wave') {
                vp.innerHTML = `
                    <iframe src="physics_quantum_wave.html" 
                        style="width: 100%; height: 100%; border: none;"
                        allow="fullscreen">
                    </iframe>
                `;
                return;
            }

            // SPECIAL HANDLE: CHAOS THEORY SIMULATION (Standalone File)
            if (simType === 'chaos-pendulum') {
                vp.innerHTML = `
                    <iframe src="physics_chaos_pendulum.html" 
                        style="width: 100%; height: 100%; border: none;"
                        allow="fullscreen">
                    </iframe>
                `;
                return;
            }

            // SPECIAL HANDLE: WIND TUNNEL SIMULATION (Standalone File)
            if (simType === 'wind-tunnel') {
                vp.innerHTML = `
                    <iframe src="physics_wind_tunnel.html" 
                        style="width: 100%; height: 100%; border: none;"
                        allow="fullscreen">
                    </iframe>
                `;
                return;
            }

            // SPECIAL HANDLE: GRAVITY WELL SIMULATION (Standalone File)
            if (simType === 'gravity-well') {
                vp.innerHTML = `
                    <iframe src="physics_gravity_well.html" 
                        style="width: 100%; height: 100%; border: none;"
                        allow="fullscreen">
                    </iframe>
                `;
                return;
            }

            // SPECIAL HANDLE: OPTICS LAB SIMULATION (Standalone File)
            if (simType === 'optics-lab') {
                vp.innerHTML = `
                    <iframe src="physics_optics.html" 
                        style="width: 100%; height: 100%; border: none;"
                        allow="fullscreen">
                    </iframe>
                `;
                return;
            }

            // SPECIAL HANDLE: THERMO LAB SIMULATION (Standalone File)
            if (simType === 'thermo-lab') {
                vp.innerHTML = `
                    <iframe src="physics_thermo.html" 
                        style="width: 100%; height: 100%; border: none;"
                        allow="fullscreen">
                    </iframe>
                `;
                return;
            }

            // SPECIAL HANDLE: NEURAL NETWORK SIMULATION (Standalone File)
            if (simType === 'neural' || simType === 'aiml') {
                vp.innerHTML = `
                    <iframe src="neural_network_sim.html" 
                        style="width: 100%; height: 100%; border: none;"
                        allow="fullscreen">
                    </iframe>
                `;
                return;
            }

            // SPECIAL HANDLE: CIVIL ENGINEERING SIMULATION (Standalone File)
            if (simType === 'civil') {
                vp.innerHTML = `
                    <iframe src="civil_engineering_sim.html" 
                        style="width: 100%; height: 100%; border: none;"
                        allow="fullscreen">
                    </iframe>
                `;
                return;
            }

            // SPECIAL HANDLE: DENTAL SIMULATION (Standalone File)
            if (simType === 'dental') {
                vp.innerHTML = `
                    <iframe src="medical_dental_sim.html" 
                        style="width: 100%; height: 100%; border: none;"
                        allow="fullscreen">
                    </iframe>
                `;
                return;
            }

            // SPECIAL HANDLE: CARDIAC SIMULATION (Standalone File)
            if (simType === 'cardio') {
                vp.innerHTML = `
                    <iframe src="cardiac_sim.html" 
                        style="width: 100%; height: 100%; border: none;"
                        allow="fullscreen">
                    </iframe>
                `;
                return;
            }

            // SPECIAL HANDLE: EYE SIMULATION (Standalone File)
            if (simType === 'eye') {
                vp.innerHTML = `
                    <iframe src="eye_sim.html" 
                        style="width: 100%; height: 100%; border: none;"
                        allow="fullscreen">
                    </iframe>
                `;
                return;
            }

            // SPECIAL HANDLE: LIVER SIMULATION (Standalone File)
            if (simType === 'liver') {
                vp.innerHTML = `
                    <iframe src="liver_sim.html" 
                        style="width: 100%; height: 100%; border: none;"
                        allow="fullscreen">
                    </iframe>
                `;
                return;
            }

            // SPECIAL HANDLE: MATH CALCULUS SIMULATION (Standalone File)
            if (simType === 'calc') {
                vp.innerHTML = `
                    <iframe src="math_derivative_sim.html" 
                        style="width: 100%; height: 100%; border: none;"
                        allow="fullscreen">
                    </iframe>
                `;
                return;
            }

            // SPECIAL HANDLE: MATH LINEAR ALGEBRA SIMULATION (Standalone File)
            if (simType === 'algebra') {
                vp.innerHTML = `
                    <iframe src="math_linear_sim.html" 
                        style="width: 100%; height: 100%; border: none;"
                        allow="fullscreen">
                    </iframe>
                `;
                return;
            }

            // SPECIAL HANDLE: MATH PROBABILITY SIMULATION (Standalone File)
            if (simType === 'stats') {
                vp.innerHTML = `
                    <iframe src="math_probability_sim.html" 
                        style="width: 100%; height: 100%; border: none;"
                        allow="fullscreen">
                    </iframe>
                `;
                return;
            }

            // SPECIAL HANDLE: PHYSICS ORBIT SIMULATION (Standalone File)
            if (simType === 'geometry') {
                vp.innerHTML = `
                    <iframe src="physics_orbit_sim.html" 
                        style="width: 100%; height: 100%; border: none;"
                        allow="fullscreen">
                    </iframe>
                `;
                return;
            }

            // SPECIAL HANDLE: CHEMISTRY ATOMIC SIMULATION (Standalone File)
            if (simType === 'molecules') { // Mapped to 'molecules' node
                vp.innerHTML = `
                    <iframe src="chemistry_atomic_sim.html" 
                        style="width: 100%; height: 100%; border: none;"
                        allow="fullscreen">
                    </iframe>
                `;
                return;
            }

            // SPECIAL HANDLE: CHEMISTRY REACTION SIMULATION (Standalone File)
            if (simType === 'reaction') {
                vp.innerHTML = `
                    <iframe src="chemistry_reaction_sim.html" 
                        style="width: 100%; height: 100%; border: none;"
                        allow="fullscreen">
                    </iframe>
                `;
                return;
            }

            // SPECIAL HANDLE: CHEMISTRY STATES SIMULATION (Standalone File)
            if (simType === 'phases') {
                vp.innerHTML = `
                    <iframe src="chemistry_states_sim.html" 
                        style="width: 100%; height: 100%; border: none;"
                        allow="fullscreen">
                    </iframe>
                `;
                return;
            }

            // SPECIAL HANDLE: CHEMISTRY BATTERY SIMULATION (Standalone File)
            if (simType === 'battery') {
                vp.innerHTML = `
                    <iframe src="chemistry_battery_sim.html" 
                        style="width: 100%; height: 100%; border: none;"
                        allow="fullscreen">
                    </iframe>
                `;
                return;
            }

            // SPECIAL HANDLE: GRADE 1 SIMULATIONS
            if (simType === 'grade1-shadow') {
                vp.innerHTML = `<iframe src="grade1_science_shadow.html" style="width: 100%; height: 100%; border: none;" allow="fullscreen"></iframe>`; return;
            }
            if (simType === 'grade1-counting') {
                vp.innerHTML = `<iframe src="grade1_math_counting.html" style="width: 100%; height: 100%; border: none;" allow="fullscreen"></iframe>`; return;
            }
            if (simType === 'grade1-plant') {
                vp.innerHTML = `<iframe src="grade1_biology_growth.html" style="width: 100%; height: 100%; border: none;" allow="fullscreen"></iframe>`; return;
            }
            if (simType === 'grade1-globe') {
                vp.innerHTML = `<iframe src="grade1_social_globe.html" style="width: 100%; height: 100%; border: none;" allow="fullscreen"></iframe>`; return;
            }
            if (simType === 'grade1-colors') {
                vp.innerHTML = `<iframe src="grade1_gk_colors.html" style="width: 100%; height: 100%; border: none;" allow="fullscreen"></iframe>`; return;
            }

            // Grade 2
            if (simType === 'grade2-magnets') { vp.innerHTML = `<iframe src="grade2_science_magnets.html" style="width: 100%; height: 100%; border: none;" allow="fullscreen"></iframe>`; return; }
            if (simType === 'grade2-placevalue') { vp.innerHTML = `<iframe src="grade2_math_placevalue.html" style="width: 100%; height: 100%; border: none;" allow="fullscreen"></iframe>`; return; }
            if (simType === 'grade2-meta') { vp.innerHTML = `<iframe src="grade2_biology_meta.html" style="width: 100%; height: 100%; border: none;" allow="fullscreen"></iframe>`; return; }
            if (simType === 'grade2-compass') { vp.innerHTML = `<iframe src="grade2_social_compass.html" style="width: 100%; height: 100%; border: none;" allow="fullscreen"></iframe>`; return; }
            if (simType === 'grade2-clock') { vp.innerHTML = `<iframe src="grade2_gk_clock.html" style="width: 100%; height: 100%; border: none;" allow="fullscreen"></iframe>`; return; }

            // Grade 3
            if (simType === 'grade3-water') { vp.innerHTML = `<iframe src="grade3_science_water.html" style="width: 100%; height: 100%; border: none;" allow="fullscreen"></iframe>`; return; }
            if (simType === 'grade3-fractions') { vp.innerHTML = `<iframe src="grade3_math_fractions.html" style="width: 100%; height: 100%; border: none;" allow="fullscreen"></iframe>`; return; }
            if (simType === 'grade3-foodchain') { vp.innerHTML = `<iframe src="grade3_biology_foodchain.html" style="width: 100%; height: 100%; border: none;" allow="fullscreen"></iframe>`; return; }
            if (simType === 'grade3-city') { vp.innerHTML = `<iframe src="grade3_social_city.html" style="width: 100%; height: 100%; border: none;" allow="fullscreen"></iframe>`; return; }
            if (simType === 'grade3-solar') { vp.innerHTML = `<iframe src="grade3_gk_solar.html" style="width: 100%; height: 100%; border: none;" allow="fullscreen"></iframe>`; return; }

            // Grade 4
            if (simType === 'grade4-lever') { vp.innerHTML = `<iframe src="grade4_science_lever.html" style="width: 100%; height: 100%; border: none;" allow="fullscreen"></iframe>`; return; }
            if (simType === 'grade4-area') { vp.innerHTML = `<iframe src="grade4_math_area.html" style="width: 100%; height: 100%; border: none;" allow="fullscreen"></iframe>`; return; }
            if (simType === 'grade4-photo') { vp.innerHTML = `<iframe src="grade4_biology_photo.html" style="width: 100%; height: 100%; border: none;" allow="fullscreen"></iframe>`; return; }
            if (simType === 'grade4-latlong') { vp.innerHTML = `<iframe src="grade4_social_latlong.html" style="width: 100%; height: 100%; border: none;" allow="fullscreen"></iframe>`; return; }
            if (simType === 'grade4-moon') { vp.innerHTML = `<iframe src="grade4_gk_moon.html" style="width: 100%; height: 100%; border: none;" allow="fullscreen"></iframe>`; return; }

            // Grade 5
            if (simType === 'grade5-circuits') { vp.innerHTML = `<iframe src="grade5_science_circuits.html" style="width: 100%; height: 100%; border: none;" allow="fullscreen"></iframe>`; return; }
            if (simType === 'grade5-volume') { vp.innerHTML = `<iframe src="grade5_math_volume.html" style="width: 100%; height: 100%; border: none;" allow="fullscreen"></iframe>`; return; }
            if (simType === 'grade5-lung') { vp.innerHTML = `<iframe src="grade5_biology_lung.html" style="width: 100%; height: 100%; border: none;" allow="fullscreen"></iframe>`; return; }
            if (simType === 'grade5-topo') { vp.innerHTML = `<iframe src="grade5_social_topo.html" style="width: 100%; height: 100%; border: none;" allow="fullscreen"></iframe>`; return; }
            if (simType === 'grade5-recycle') { vp.innerHTML = `<iframe src="grade5_gk_recycle.html" style="width: 100%; height: 100%; border: none;" allow="fullscreen"></iframe>`; return; }

            // Grade 6
            if (simType === 'grade6-light') { vp.innerHTML = `<iframe src="grade6_science_light.html" style="width: 100%; height: 100%; border: none;" allow="fullscreen"></iframe>`; return; }
            if (simType === 'grade6-algebra') { vp.innerHTML = `<iframe src="grade6_math_algebra.html" style="width: 100%; height: 100%; border: none;" allow="fullscreen"></iframe>`; return; }
            if (simType === 'grade6-skeletal') { vp.innerHTML = `<iframe src="grade6_biology_skeletal.html" style="width: 100%; height: 100%; border: none;" allow="fullscreen"></iframe>`; return; }
            if (simType === 'grade6-arch') { vp.innerHTML = `<iframe src="grade6_social_arch.html" style="width: 100%; height: 100%; border: none;" allow="fullscreen"></iframe>`; return; }
            if (simType === 'grade6-cipher') { vp.innerHTML = `<iframe src="grade6_gk_cipher.html" style="width: 100%; height: 100%; border: none;" allow="fullscreen"></iframe>`; return; }

            // Grade 7
            if (simType === 'grade7-ph') { vp.innerHTML = `<iframe src="grade7_science_ph.html" style="width: 100%; height: 100%; border: none;" allow="fullscreen"></iframe>`; return; }
            if (simType === 'grade7-transversal') { vp.innerHTML = `<iframe src="grade7_math_transversal.html" style="width: 100%; height: 100%; border: none;" allow="fullscreen"></iframe>`; return; }
            if (simType === 'grade7-gas') { vp.innerHTML = `<iframe src="grade7_biology_gas.html" style="width: 100%; height: 100%; border: none;" allow="fullscreen"></iframe>`; return; }
            if (simType === 'grade7-greenhouse') { vp.innerHTML = `<iframe src="grade7_social_greenhouse.html" style="width: 100%; height: 100%; border: none;" allow="fullscreen"></iframe>`; return; }
            if (simType === 'grade7-logic') { vp.innerHTML = `<iframe src="grade7_gk_logic.html" style="width: 100%; height: 100%; border: none;" allow="fullscreen"></iframe>`; return; }

            // Grade 8
            if (simType === 'grade8-sound') { vp.innerHTML = `<iframe src="grade8_science_sound.html" style="width: 100%; height: 100%; border: none;" allow="fullscreen"></iframe>`; return; }
            if (simType === 'grade8-flight') { vp.innerHTML = `<iframe src="grade8_math_flight.html" style="width: 100%; height: 100%; border: none;" allow="fullscreen"></iframe>`; return; }
            if (simType === 'grade8-cell') { vp.innerHTML = `<iframe src="grade8_biology_cell.html" style="width: 100%; height: 100%; border: none;" allow="fullscreen"></iframe>`; return; }
            if (simType === 'grade8-steam') { vp.innerHTML = `<iframe src="grade8_social_steam.html" style="width: 100%; height: 100%; border: none;" allow="fullscreen"></iframe>`; return; }
            if (simType === 'grade8-internet') { vp.innerHTML = `<iframe src="grade8_gk_internet.html" style="width: 100%; height: 100%; border: none;" allow="fullscreen"></iframe>`; return; }

            // Grade 9
            if (simType === 'grade9-physics') { vp.innerHTML = `<iframe src="grade9_physics_trajectory.html" style="width: 100%; height: 100%; border: none;" allow="fullscreen"></iframe>`; return; }
            if (simType === 'grade9-trig') { vp.innerHTML = `<iframe src="grade9_math_trig.html" style="width: 100%; height: 100%; border: none;" allow="fullscreen"></iframe>`; return; }
            if (simType === 'grade9-dna') { vp.innerHTML = `<iframe src="grade9_biology_dna.html" style="width: 100%; height: 100%; border: none;" allow="fullscreen"></iframe>`; return; }
            if (simType === 'grade9-market') { vp.innerHTML = `<iframe src="grade9_social_market.html" style="width: 100%; height: 100%; border: none;" allow="fullscreen"></iframe>`; return; }
            if (simType === 'grade9-interest') { vp.innerHTML = `<iframe src="grade9_gk_interest.html" style="width: 100%; height: 100%; border: none;" allow="fullscreen"></iframe>`; return; }

            // Grade 10
            if (simType === 'grade10-motor') { vp.innerHTML = `<iframe src="grade10_science_motor.html" style="width: 100%; height: 100%; border: none;" allow="fullscreen"></iframe>`; return; }
            if (simType === 'grade10-parabola') { vp.innerHTML = `<iframe src="grade10_math_parabola.html" style="width: 100%; height: 100%; border: none;" allow="fullscreen"></iframe>`; return; }
            if (simType === 'grade10-heredity') { vp.innerHTML = `<iframe src="grade10_biology_heredity.html" style="width: 100%; height: 100%; border: none;" allow="fullscreen"></iframe>`; return; }
            if (simType === 'grade10-pop') { vp.innerHTML = `<iframe src="grade10_social_demographics.html" style="width: 100%; height: 100%; border: none;" allow="fullscreen"></iframe>`; return; }
            if (simType === 'grade10-crypto') { vp.innerHTML = `<iframe src="grade10_gk_encryption.html" style="width: 100%; height: 100%; border: none;" allow="fullscreen"></iframe>`; return; }

            // Grade 10
            if (simType === 'grade10-motor') { vp.innerHTML = `<iframe src="grade10_science_motor.html" style="width: 100%; height: 100%; border: none;" allow="fullscreen"></iframe>`; return; }
            if (simType === 'grade10-parabola') { vp.innerHTML = `<iframe src="grade10_math_parabola.html" style="width: 100%; height: 100%; border: none;" allow="fullscreen"></iframe>`; return; }
            if (simType === 'grade10-heredity') { vp.innerHTML = `<iframe src="grade10_biology_heredity.html" style="width: 100%; height: 100%; border: none;" allow="fullscreen"></iframe>`; return; }
            if (simType === 'grade10-pop') { vp.innerHTML = `<iframe src="grade10_social_demographics.html" style="width: 100%; height: 100%; border: none;" allow="fullscreen"></iframe>`; return; }
            if (simType === 'grade10-crypto') { vp.innerHTML = `<iframe src="grade10_gk_encryption.html" style="width: 100%; height: 100%; border: none;" allow="fullscreen"></iframe>`; return; }

            // Grade 11
            if (simType === 'grade11-vectors') { vp.innerHTML = `<iframe src="grade11_physics_vectors.html" style="width: 100%; height: 100%; border: none;" allow="fullscreen"></iframe>`; return; }
            if (simType === 'grade11-complex') { vp.innerHTML = `<iframe src="grade11_math_complex.html" style="width: 100%; height: 100%; border: none;" allow="fullscreen"></iframe>`; return; }
            if (simType === 'grade11-vsepr') { vp.innerHTML = `<iframe src="grade11_chemistry_vsepr.html" style="width: 100%; height: 100%; border: none;" allow="fullscreen"></iframe>`; return; }
            if (simType === 'grade11-neuron') { vp.innerHTML = `<iframe src="grade11_biology_neuron.html" style="width: 100%; height: 100%; border: none;" allow="fullscreen"></iframe>`; return; }
            if (simType === 'grade11-recursion') { vp.innerHTML = `<iframe src="grade11_cs_recursion.html" style="width: 100%; height: 100%; border: none;" allow="fullscreen"></iframe>`; return; }

            // Grade 12
            if (simType === 'grade12-generator') { vp.innerHTML = `<iframe src="grade12_physics_generator.html" style="width: 100%; height: 100%; border: none;" allow="fullscreen"></iframe>`; return; }
            if (simType === 'grade12-integral') { vp.innerHTML = `<iframe src="grade12_math_integral.html" style="width: 100%; height: 100%; border: none;" allow="fullscreen"></iframe>`; return; }
            if (simType === 'grade12-translation') { vp.innerHTML = `<iframe src="grade12_biology_translation.html" style="width: 100%; height: 100%; border: none;" allow="fullscreen"></iframe>`; return; }
            if (simType === 'grade12-equilibrium') { vp.innerHTML = `<iframe src="grade12_chemistry_equilibrium.html" style="width: 100%; height: 100%; border: none;" allow="fullscreen"></iframe>`; return; }
            if (simType === 'grade12-pathfinding') { vp.innerHTML = `<iframe src="grade12_cs_pathfinding.html" style="width: 100%; height: 100%; border: none;" allow="fullscreen"></iframe>`; return; }

            // Show loading state for Canvas sims
            vp.innerHTML = `
                <div class="text-center animate-pulse">
                    <div class="text-6xl mb-4 text-slate-300"><i class="fas fa-atom fa-spin"></i></div>
                    <h2 class="text-2xl font-bold text-slate-700">Loading ${title}...</h2>
                    <p class="text-slate-400 mt-2">Initializing simulation engine</p>
                </div>
            `;

            setTimeout(() => {
                // If user closed modal while loading, stop.
                if (!modal.classList.contains('active')) return;

                vp.innerHTML = '';
                const canvas = document.createElement('canvas');
                canvas.width = vp.clientWidth;
                canvas.height = vp.clientHeight;
                canvas.isConnected = true; // Connection flag
                vp.appendChild(canvas);

                // Route to appropriate simulation
                switch (simType) {
                    case 'calc':
                    case 'algebra':
                        startMathSim(canvas);
                        break;
                    case 'bio':
                    case 'science':
                        startBioSim(canvas);
                        break;
                    case 'civil':
                        startCivilSim(canvas);
                        break;
                    // CS handled above
                    case 'neural':
                        startNeuralSim(canvas);
                        break;
                    case 'electrical':
                        startElectricalSim(canvas);
                        break;
                    case 'cardio':
                        startCardioSim(canvas);
                        break;
                    case 'eye':
                        startEyeSim(canvas);
                        break;
                    case 'geometry':
                        startGeometrySim(canvas);
                        break;
                    case 'stats':
                        startStatsSim(canvas);
                        break;
                    default:
                        startGenericSim(canvas, title);
                }
            }, 600);
        }

        function closeLab() {
            document.getElementById('lab-modal').classList.remove('active');
        }

        // ===========================================
        // 4. PREVIEW & SIMULATION LOGIC (Dual Mode)
        // ===========================================

        // Intersection Observer for Performance
        const simObserver = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                if (entry.target._simActiveSetter) {
                    entry.target._simActiveSetter(entry.isIntersecting);
                }
            });
        }, { threshold: 0.1 });

        // Helper to map card types to sim functions
        function mountMicroSim(node, canvas) {
            const type = node.sim;
            const id = node.id;

            // 1. Root Folders
            if (id === 'eng') return startEngFolderSim(canvas, false);
            if (id === 'med') return startMedFolderSim(canvas, false);
            if (id === 'phy') return startPhysicsFolderSim(canvas, false);
            if (id === 'math') return startMathFolderSim(canvas, false);
            if (id === 'school') return startSchoolFolderSim(canvas, false);
            if (id === 'chem') return startChemFolderSim(canvas, false);

            // 2. Grade Folders (Grade 1-12)
            if (id && id.startsWith('grade-')) return startGradeSim(canvas, id.split('-')[1], false);

            // 3. Subject Simulations
            switch (type) {
                // Physics (NEW)
                case 'quantum-wave': startQuantumWaveSim(canvas, false); break;
                case 'chaos-pendulum': startChaosPendulumSim(canvas, false); break;
                case 'wind-tunnel': startWindTunnelSim(canvas, false); break;
                case 'gravity-well': startGravityWellSim(canvas, false); break;
                case 'optics-lab': startOpticsLabSim(canvas, false); break;
                case 'thermo-lab': startThermoLabSim(canvas, false); break;

                // Math
                case 'calc': case 'algebra': startMathSim(canvas, false); break;

                // Science / Bio
                case 'bio': startBioSim(canvas, false); break;
                case 'science': startScienceSim(canvas, false); break;

                // Chemistry
                case 'molecules': startAtomSim(canvas, false); break;
                case 'reaction': startReactionSim(canvas, false); break;
                case 'phases': startPhaseSim(canvas, false); break;
                case 'battery': startBatterySim(canvas, false); break;

                // Grade 1
                case 'grade1-shadow': startG1Shadow(canvas, false); break;
                case 'grade1-counting': startG1Counting(canvas, false); break;

                // Grade 9
                case 'grade9-physics': startG9Physics(canvas, false); break;
                case 'grade9-trig': startG9Trig(canvas, false); break;
                case 'grade9-dna': startG9DNA(canvas, false); break;
                case 'grade9-market': startG9Market(canvas, false); break;
                case 'grade9-interest': startG9Interest(canvas, false); break;

                // Grade 10
                case 'grade10-motor': startG10Motor(canvas, false); break;
                case 'grade10-parabola': startG10Parabola(canvas, false); break;
                case 'grade10-heredity': startG10Heredity(canvas, false); break;
                case 'grade10-pop': startG10Pop(canvas, false); break;
                case 'grade10-crypto': startG10Crypto(canvas, false); break;
                case 'grade1-plant': startG1Plant(canvas, false); break;
                case 'grade1-globe': startG1Globe(canvas, false); break;
                case 'grade1-colors': startG1Colors(canvas, false); break;

                // Grade 2
                case 'grade2-magnets': startG2Magnets(canvas, false); break;
                case 'grade2-placevalue': startG2PlaceValue(canvas, false); break;
                case 'grade2-meta': startG2Meta(canvas, false); break;
                case 'grade2-compass': startG2Compass(canvas, false); break;
                case 'grade2-clock': startG2Clock(canvas, false); break;

                // Grade 3
                case 'grade3-water': startG3Water(canvas, false); break;
                case 'grade3-fractions': startG3Fractions(canvas, false); break;
                case 'grade3-foodchain': startG3FoodChain(canvas, false); break;
                case 'grade3-city': startG3City(canvas, false); break;
                case 'grade3-solar': startG3Solar(canvas, false); break;

                // Grade 4
                case 'grade4-lever': startG4Lever(canvas, false); break;
                case 'grade4-area': startG4Area(canvas, false); break;
                case 'grade4-photo': startG4Photo(canvas, false); break;
                case 'grade4-latlong': startG4LatLong(canvas, false); break;
                case 'grade4-moon': startG4Moon(canvas, false); break;

                // Grade 5
                case 'grade5-circuits': startG5Circuits(canvas, false); break;
                case 'grade5-volume': startG5Volume(canvas, false); break;
                case 'grade5-lung': startG5Lung(canvas, false); break;
                case 'grade5-topo': startG5Topo(canvas, false); break;
                case 'grade5-recycle': startG5Recycle(canvas, false); break;

                // Grade 6
                case 'grade6-light': startG6Light(canvas, false); break;
                case 'grade6-algebra': startG6Algebra(canvas, false); break;
                case 'grade6-skeletal': startG6Skeletal(canvas, false); break;
                case 'grade6-arch': startG6Arch(canvas, false); break;
                case 'grade6-cipher': startG6Cipher(canvas, false); break;

                // Grade 7
                case 'grade7-ph': startG7Ph(canvas, false); break;
                case 'grade7-transversal': startG7Transversal(canvas, false); break;
                case 'grade7-gas': startG7Gas(canvas, false); break;
                case 'grade7-greenhouse': startG7Greenhouse(canvas, false); break;
                case 'grade7-logic': startG7Logic(canvas, false); break;

                // Grade 8
                case 'grade8-sound': startG8Sound(canvas, false); break;
                case 'grade8-flight': startG8Flight(canvas, false); break;
                case 'grade8-cell': startG8Cell(canvas, false); break;
                case 'grade8-steam': startG8Steam(canvas, false); break;
                case 'grade8-internet': startG8Internet(canvas, false); break;

                // Grade 9
                case 'grade9-physics': startG9Physics(canvas, false); break;
                case 'grade9-trig': startG9Trig(canvas, false); break;
                case 'grade9-dna': startG9DNA(canvas, false); break;
                case 'grade9-market': startG9Market(canvas, false); break;
                case 'grade9-interest': startG9Interest(canvas, false); break;

                // Grade 10
                case 'grade10-motor': startG10Motor(canvas, false); break;
                case 'grade10-parabola': startG10Parabola(canvas, false); break;
                case 'grade10-heredity': startG10Heredity(canvas, false); break;
                case 'grade10-pop': startG10Pop(canvas, false); break;
                case 'grade10-pop': startG10Pop(canvas, false); break;
                case 'grade10-crypto': startG10Crypto(canvas, false); break;

                // Grade 11
                case 'grade11-vectors': startG11Vectors(canvas, false); break;
                case 'grade11-complex': startG11Complex(canvas, false); break;
                case 'grade11-vsepr': startG11Vsepr(canvas, false); break;
                case 'grade11-neuron': startG11Neuron(canvas, false); break;
                case 'grade11-recursion': startG11Recursion(canvas, false); break;

                // Grade 12
                case 'grade12-generator': startG12Generator(canvas, false); break;
                case 'grade12-integral': startG12Integral(canvas, false); break;
                case 'grade12-equilibrium': startG12Equilibrium(canvas, false); break;
                case 'grade12-translation': startG12Translation(canvas, false); break;
                case 'grade12-pathfinding': startG12Pathfinding(canvas, false); break;

                // Medical
                case 'dental': startDentalSim(canvas, false); break;
                case 'liver': startLiverSim(canvas, false); break;
                case 'cardio': startCardioSim(canvas, false); break;
                case 'eye': startEyeSim(canvas, false); break;

                // Engineering
                case 'civil': startCivilSim(canvas, false); break;
                case 'cs': startCSSim(canvas, false); break;
                case 'neural': startNeuralSim(canvas, false); break;
                case 'electrical': startElectricalSim(canvas, false); break;
                case 'ece': startECESim(canvas, false); break;
                case 'mech': startMechSim(canvas, false); break;
                case 'it': startITSim(canvas, false); break;
                case 'datascience': startDataScienceSim(canvas, false); break;

                // Others
                case 'geometry': startGeometrySim(canvas, false); break;
                case 'stats': startStatsSim(canvas, false); break;
                case 'social': startSocialSim(canvas, false); break;
                case 'gk': startGenericSim(canvas, node.title); break;

                default: startGenericSim(canvas, node.title); break;
            }
            simObserver.observe(canvas);
        }

        // ===========================================
        // NEW SIMULATIONS
        // ===========================================

        // --- CHEMISTRY FOLDER (Bubbling Flask) ---
        function startChemFolderSim(canvas, isFull) {
            const ctx = canvas.getContext('2d');
            let running = true;
            canvas._simActiveSetter = (isActive) => { running = isActive; if (isActive) loop(); };
            let bubbles = [];

            function loop() {
                if (!running || !canvas.isConnected) return;
                const w = canvas.width = canvas.clientWidth;
                const h = canvas.height = canvas.clientHeight;
                const cx = w / 2, cy = h / 2;

                ctx.fillStyle = '#eff6ff'; // Light Blue/White
                ctx.fillRect(0, 0, w, h);

                // Flask Shape
                const s = isFull ? 2 : 1;
                ctx.beginPath();
                ctx.moveTo(cx - 15 * s, cy - 30 * s);
                ctx.lineTo(cx - 15 * s, cy - 10 * s);
                ctx.lineTo(cx - 30 * s, cy + 20 * s);
                ctx.quadraticCurveTo(cx, cy + 35 * s, cx + 30 * s, cy + 20 * s);
                ctx.lineTo(cx + 15 * s, cy - 10 * s);
                ctx.lineTo(cx + 15 * s, cy - 30 * s);
                ctx.closePath();
                ctx.fillStyle = 'rgba(59, 130, 246, 0.2)'; // Blue tint
                ctx.fill();
                ctx.strokeStyle = '#3b82f6';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Liquid Level
                ctx.save();
                ctx.clip();
                const liquidY = cy + Math.sin(Date.now() * 0.003) * 2;
                ctx.fillStyle = '#60a5fa'; // Blue liquid
                ctx.fillRect(cx - 30 * s, liquidY, 60 * s, 40 * s);

                // Bubbles
                if (Math.random() > 0.9) bubbles.push({ x: cx + (Math.random() - 0.5) * 40 * s, y: cy + 20 * s, r: Math.random() * 3 + 1, v: Math.random() * 1 + 0.5 });

                ctx.fillStyle = 'rgba(255,255,255,0.7)';
                bubbles.forEach((b, i) => {
                    b.y -= b.v;
                    ctx.beginPath(); ctx.arc(b.x, b.y, b.r, 0, Math.PI * 2); ctx.fill();
                    if (b.y < cy - 20 * s) bubbles.splice(i, 1);
                });
                ctx.restore();

                requestAnimationFrame(loop);
            }
            loop();
        }

        // --- ATOM MICRO SIM (Spinning Electrons) ---
        function startAtomSim(canvas, isFull) {
            const ctx = canvas.getContext('2d');
            let running = true;
            canvas._simActiveSetter = (isActive) => { running = isActive; if (isActive) loop(); };
            let t = 0;

            function loop() {
                if (!running || !canvas.isConnected) return;
                const w = canvas.width = canvas.clientWidth;
                const h = canvas.height = canvas.clientHeight;
                const cx = w / 2, cy = h / 2;

                ctx.fillStyle = '#fdf4ff'; // Light Purple tint
                ctx.fillRect(0, 0, w, h);

                // Nucleus (Protons/Neutrons clustering)
                const nScale = isFull ? 2 : 1;
                ctx.save();
                ctx.translate(cx, cy);
                ctx.rotate(t * 0.2); // Slow drift

                // Draw cluster
                const colors = ['#ec4899', '#db2777', '#f472b6'];
                for (let i = 0; i < 5; i++) {
                    const angle = (i / 5) * Math.PI * 2;
                    const r = 4 * nScale;
                    const dx = Math.cos(angle) * r * 0.8;
                    const dy = Math.sin(angle) * r * 0.8;
                    ctx.beginPath(); ctx.arc(dx, dy, r, 0, Math.PI * 2);
                    ctx.fillStyle = colors[i % 3]; ctx.fill();
                }
                ctx.restore();

                // Electron Orbits
                const orbits = [
                    { rx: 30 * nScale, ry: 10 * nScale, rot: t * 0.05, speed: 2 },
                    { rx: 30 * nScale, ry: 10 * nScale, rot: t * 0.05 + Math.PI / 3, speed: 2.5 },
                    { rx: 30 * nScale, ry: 10 * nScale, rot: t * 0.05 + 2 * Math.PI / 3, speed: 1.8 }
                ];

                ctx.lineWidth = 1;
                orbits.forEach(o => {
                    ctx.save();
                    ctx.translate(cx, cy);
                    ctx.rotate(o.rot);

                    // Orbit Path
                    ctx.strokeStyle = 'rgba(236, 72, 153, 0.3)'; // Pinkish
                    ctx.beginPath();
                    ctx.ellipse(0, 0, o.rx, o.ry, 0, 0, Math.PI * 2);
                    ctx.stroke();

                    // Electron
                    const p = (t * o.speed * 0.05) % (Math.PI * 2);
                    const ex = Math.cos(p) * o.rx;
                    const ey = Math.sin(p) * o.ry;

                    ctx.fillStyle = '#a855f7'; // Purple electron
                    ctx.beginPath(); ctx.arc(ex, ey, 3 * nScale / 1.5, 0, Math.PI * 2); ctx.fill();

                    ctx.restore();
                });

                t++;
                requestAnimationFrame(loop);
            }
            loop();
        }

        // --- REACTION KINETICS MICRO SIM ---
        function startReactionSim(canvas, isFull) {
            const ctx = canvas.getContext('2d');
            let running = true;
            canvas._simActiveSetter = (isActive) => { running = isActive; if (isActive) loop(); };

            const particles = Array.from({ length: 12 }, () => ({
                x: Math.random() * canvas.clientWidth,
                y: Math.random() * canvas.clientHeight,
                vx: (Math.random() - 0.5) * 2,
                vy: (Math.random() - 0.5) * 2,
                type: Math.random() > 0.5 ? 'A' : 'B',
                r: isFull ? 8 : 4
            }));

            let flashes = [];

            function loop() {
                if (!running || !canvas.isConnected) return;
                const w = canvas.width = canvas.clientWidth;
                const h = canvas.height = canvas.clientHeight;

                ctx.fillStyle = '#0f172a';
                ctx.fillRect(0, 0, w, h);

                // Update Particles
                particles.forEach(p => {
                    p.x += p.vx; p.y += p.vy;
                    if (p.x < 0 || p.x > w) p.vx *= -1;
                    if (p.y < 0 || p.y > h) p.vy *= -1;

                    ctx.beginPath(); ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2);
                    ctx.fillStyle = p.type === 'A' ? '#22d3ee' : '#e879f9';
                    ctx.fill();

                    // Random flash
                    if (Math.random() > 0.98) flashes.push({ x: p.x, y: p.y, r: 0, life: 1 });
                });

                // Flashes
                flashes.forEach((f, i) => {
                    f.r += 2; f.life -= 0.1;
                    ctx.beginPath(); ctx.arc(f.x, f.y, f.r, 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(250, 204, 21, ${f.life})`; // Gold
                    ctx.fill();
                    if (f.life <= 0) flashes.splice(i, 1);
                });

                requestAnimationFrame(loop);
            }
            loop();
        }

        // --- PHASES MICRO SIM (Melting/Freezing) ---
        function startPhaseSim(canvas, isFull) {
            const ctx = canvas.getContext('2d');
            let running = true;
            canvas._simActiveSetter = (isActive) => { running = isActive; if (isActive) loop(); };
            let t = 0;
            const particles = [];
            // Hexagonal grid
            for (let r = 0; r < 4; r++) {
                for (let c = 0; c < 4; c++) {
                    particles.push({
                        bx: 50 + c * 25 + (r % 2 ? 12 : 0), by: 50 + r * 25, // Base pos
                        x: 0, y: 0,
                        vx: 0, vy: 0
                    });
                }
            }

            function loop() {
                if (!running || !canvas.isConnected) return;
                const w = canvas.width = canvas.clientWidth;
                const h = canvas.height = canvas.clientHeight;
                const cx = w / 2, cy = h / 2;

                ctx.fillStyle = '#0f172a';
                ctx.fillRect(0, 0, w, h);

                // Cycle Temperature (0 to 1)
                const cycle = (Math.sin(t * 0.02) + 1) / 2; // Warm <-> Cold
                const temp = cycle;

                ctx.save();
                // To center the grid roughly
                const scale = isFull ? 1.5 : 0.8;
                ctx.translate(cx - 50 * scale, cy - 50 * scale);
                ctx.scale(scale, scale);

                particles.forEach(p => {
                    // Force towards base (Solid lattice) vs Browninan (Gas)
                    const stiffness = 0.1 * (1 - temp); // High stiff at low temp

                    const dx = p.bx - p.x;
                    const dy = p.by - p.y;

                    // Spring to home
                    p.vx += dx * stiffness;
                    p.vy += dy * stiffness;

                    // Heat jitter
                    p.vx += (Math.random() - 0.5) * temp * 2;
                    p.vy += (Math.random() - 0.5) * temp * 2;

                    // Damping
                    p.vx *= 0.9; p.vy *= 0.9;

                    p.x += p.vx;
                    p.y += p.vy;

                    ctx.beginPath();
                    ctx.arc(p.x, p.y, isFull ? 10 : 8, 0, Math.PI * 2);

                    // Color shift
                    // Cold = White/Cyan. Hot = Blue/Fade
                    const r = 255 - (temp * 100);
                    const g = 255 - (temp * 50);
                    const b = 255;
                    ctx.fillStyle = `rgba(${r},${g},${b}, ${1 - temp * 0.5})`;
                    ctx.fill();
                });
                ctx.restore();

                // Label (Micro)
                if (!isFull) {
                    ctx.fillStyle = temp > 0.5 ? '#60a5fa' : '#bae6fd';
                    ctx.font = '10px JetBrains Mono';
                    ctx.fillText(temp > 0.8 ? "GAS" : temp > 0.3 ? "LIQ" : "SOLID", 10, h - 10);
                }

                t++;
                requestAnimationFrame(loop);
            }
            loop();
        }

        // --- BATTERY MICRO SIM (Electron Flow) ---
        function startBatterySim(canvas, isFull) {
            const ctx = canvas.getContext('2d');
            let running = true;
            canvas._simActiveSetter = (isActive) => { running = isActive; if (isActive) loop(); };
            let offset = 0;

            function loop() {
                if (!running || !canvas.isConnected) return;
                const w = canvas.width = canvas.clientWidth;
                const h = canvas.height = canvas.clientHeight;
                const cx = w / 2, cy = h / 2;

                ctx.fillStyle = '#0f172a';
                ctx.fillRect(0, 0, w, h);

                // Beakers
                const s = isFull ? 2 : 1;
                const bw = 20 * s; const bh = 40 * s;

                // Left (Zinc)
                ctx.fillStyle = 'rgba(255,255,255,0.1)';
                ctx.fillRect(cx - 30 * s, cy, bw, bh);
                ctx.strokeStyle = '#fff'; ctx.lineWidth = 1; ctx.strokeRect(cx - 30 * s, cy, bw, bh);

                // Right (Copper)
                ctx.fillStyle = 'rgba(59, 130, 246, 0.3)';
                ctx.fillRect(cx + 10 * s, cy, bw, bh);
                ctx.strokeRect(cx + 10 * s, cy, bw, bh);

                // Electrodes
                ctx.fillStyle = '#94a3b8'; ctx.fillRect(cx - 25 * s, cy + 5, 10 * s, bh - 10); // Anode
                ctx.fillStyle = '#f97316'; ctx.fillRect(cx + 15 * s, cy + 5, 10 * s, bh - 10); // Cathode

                // Wire Path (Arc)
                ctx.beginPath();
                ctx.strokeStyle = '#f59e0b'; ctx.lineWidth = 2;
                ctx.moveTo(cx - 20 * s, cy + 5);
                ctx.lineTo(cx - 20 * s, cy - 20 * s);
                ctx.lineTo(cx + 20 * s, cy - 20 * s);
                ctx.lineTo(cx + 20 * s, cy + 5);
                ctx.stroke();

                // Moving Electrons
                offset -= 1;
                ctx.setLineDash([5, 5]);
                ctx.lineDashOffset = offset;
                ctx.strokeStyle = '#facc15';
                ctx.stroke();
                ctx.setLineDash([]);

                // Bulb Glow
                const alpha = (Math.sin(Date.now() * 0.01) + 1) / 2 * 0.5 + 0.2;
                ctx.fillStyle = `rgba(253, 224, 71, ${alpha})`;
                ctx.beginPath(); ctx.arc(cx, cy - 20 * s, 5 * s, 0, Math.PI * 2); ctx.fill();

                requestAnimationFrame(loop);
            }
            loop();
        }

        // --- GRADE 1 MICRO SIMS ---
        function startG1Shadow(canvas) {
            const ctx = canvas.getContext('2d');
            let t = 0; let active = true; canvas._simActiveSetter = (s) => { active = s; if (s) loop(); };
            function loop() {
                if (!active) return;
                const w = canvas.width = canvas.clientWidth; const h = canvas.height = canvas.clientHeight;
                const cx = w / 2, cy = h / 2;
                ctx.fillStyle = '#E0F2FE'; ctx.fillRect(0, 0, w, h);
                const sunX = cx + Math.cos(t * 0.05) * 30; const sunY = cy - 20 + Math.sin(t * 0.05) * 10;
                // Shadow
                const dx = cx - sunX;
                ctx.fillStyle = 'rgba(0,0,0,0.2)';
                ctx.beginPath(); ctx.moveTo(cx - 10, cy + 20); ctx.lineTo(cx + 10, cy + 20); ctx.lineTo(cx + dx, cy + 20 + 10); ctx.fill();
                // Obj
                ctx.fillStyle = '#3b82f6'; ctx.beginPath(); ctx.arc(cx, cy + 10, 10, 0, Math.PI * 2); ctx.fill();
                // Sun
                ctx.fillStyle = '#f59e0b'; ctx.beginPath(); ctx.arc(sunX, sunY, 5, 0, Math.PI * 2); ctx.fill();
                t++; requestAnimationFrame(loop);
            } loop();
        }
        function startG1Counting(canvas) {
            const ctx = canvas.getContext('2d');
            let balls = []; let active = true; canvas._simActiveSetter = (s) => { active = s; if (s) loop(); };
            function loop() {
                if (!active) return;
                const w = canvas.width = canvas.clientWidth; const h = canvas.height = canvas.clientHeight;
                if (Math.random() > 0.95 && balls.length < 5) balls.push({ x: Math.random() * w, y: 0, vy: 0 });
                ctx.fillStyle = '#dcfce7'; ctx.fillRect(0, 0, w, h);
                balls.forEach((b, i) => {
                    b.vy += 0.5; b.y += b.vy;
                    if (b.y > h - 10) { b.y = h - 10; b.vy *= -0.6; }
                    ctx.fillStyle = '#22c55e'; ctx.beginPath(); ctx.arc(b.x, b.y, 8, 0, Math.PI * 2); ctx.fill();
                });
                requestAnimationFrame(loop);
            } loop();
        }
        function startG1Plant(canvas) {
            const ctx = canvas.getContext('2d');
            let t = 0; let active = true; canvas._simActiveSetter = (s) => { active = s; if (s) loop(); };
            function loop() {
                if (!active) return;
                const w = canvas.width = canvas.clientWidth; const h = canvas.height = canvas.clientHeight;
                ctx.fillStyle = '#f0fdf4'; ctx.fillRect(0, 0, w, h);
                const grow = (Math.sin(t * 0.02) + 1) / 2;
                ctx.strokeStyle = '#65a30d'; ctx.lineWidth = 4;
                ctx.beginPath(); ctx.moveTo(w / 2, h); ctx.lineTo(w / 2, h - 30 * grow);
                ctx.lineTo(w / 2 - 10 * grow, h - 45 * grow);
                ctx.moveTo(w / 2, h - 30 * grow); ctx.lineTo(w / 2 + 10 * grow, h - 45 * grow);
                ctx.stroke();
                // Leaves
                if (grow > 0.5) { ctx.fillStyle = '#4ade80'; ctx.beginPath(); ctx.arc(w / 2 - 10 * grow, h - 45 * grow, 5 * grow, 0, Math.PI * 2); ctx.fill(); }
                t++; requestAnimationFrame(loop);
            } loop();
        }
        function startG1Globe(canvas) {
            const ctx = canvas.getContext('2d');
            let t = 0; let active = true; canvas._simActiveSetter = (s) => { active = s; if (s) loop(); };
            function loop() {
                if (!active) return;
                const w = canvas.width = canvas.clientWidth; const h = canvas.height = canvas.clientHeight;
                ctx.fillStyle = '#020617'; ctx.fillRect(0, 0, w, h);
                const r = 20;
                ctx.fillStyle = '#0ea5e9'; ctx.beginPath(); ctx.arc(w / 2, h / 2, r, 0, Math.PI * 2); ctx.fill();
                // Shadow
                const rot = t * 0.05;
                ctx.fillStyle = 'rgba(0,0,0,0.7)'; ctx.beginPath(); ctx.arc(w / 2, h / 2, r, rot, rot + Math.PI); ctx.fill();
                t++; requestAnimationFrame(loop);
            } loop();
        }
        function startG1Colors(canvas) {
            const ctx = canvas.getContext('2d');
            let t = 0; let active = true; canvas._simActiveSetter = (s) => { active = s; if (s) loop(); };
            function loop() {
                if (!active) return;
                const w = canvas.width = canvas.clientWidth; const h = canvas.height = canvas.clientHeight;
                ctx.fillStyle = '#fff'; ctx.fillRect(0, 0, w, h);
                const cx = w / 2, cy = h / 2;
                const off = Math.sin(t * 0.05) * 10;
                // Red
                ctx.fillStyle = 'rgba(239, 68, 68, 0.5)'; ctx.beginPath(); ctx.arc(cx - 10 + off, cy, 10, 0, Math.PI * 2); ctx.fill();
                // Blue
                ctx.fillStyle = 'rgba(59, 130, 246, 0.5)'; ctx.beginPath(); ctx.arc(cx + 10 - off, cy, 10, 0, Math.PI * 2); ctx.fill();
                t++; requestAnimationFrame(loop);
            } loop();
        }

        // --- GRADE 2 MICRO SIMS ---
        function startG2Magnets(c) {
            const ctx = c.getContext('2d'); let t = 0; let active = true; c._simActiveSetter = (s) => { active = s; if (s) loop(); };
            function loop() {
                if (!active) return; const w = c.width = c.clientWidth; const h = c.height = c.clientHeight;
                ctx.fillStyle = '#0f172a'; ctx.fillRect(0, 0, w, h);
                // Magnet
                const cx = w / 2; const cy = h / 2;
                ctx.translate(cx, cy); ctx.rotate(Math.sin(t * 0.02) * 0.5);
                ctx.fillStyle = '#3b82f6'; ctx.fillRect(-30, -10, 30, 20);
                ctx.fillStyle = '#ef4444'; ctx.fillRect(0, -10, 30, 20);
                ctx.textAlign = 'center'; ctx.font = '10px sans-serif'; ctx.fillStyle = '#fff'; ctx.fillText('S', -15, 4); ctx.fillText('N', 15, 4);
                // Lines
                ctx.setTransform(1, 0, 0, 1, 0, 0);
                ctx.strokeStyle = '#334155'; ctx.beginPath();
                for (let i = 0; i < 5; i++) { ctx.moveTo(0, h / 2 + i * 10); ctx.lineTo(w, h / 2 - 20 + i * 10); } ctx.stroke();
                t++; requestAnimationFrame(loop);
            } loop();
        }
        function startG2PlaceValue(c) {
            const ctx = c.getContext('2d'); let t = 0; let active = true; c._simActiveSetter = (s) => { active = s; if (s) loop(); };
            function loop() {
                if (!active) return; const w = c.width = c.clientWidth; const h = c.height = c.clientHeight;
                ctx.fillStyle = '#fff'; ctx.fillRect(0, 0, w, h);
                // Drop balls
                const y = (t % 60) * 2;
                ctx.fillStyle = '#eab308'; ctx.beginPath(); ctx.arc(w / 2, y, 10, 0, Math.PI * 2); ctx.fill();
                // Tube
                ctx.strokeStyle = '#94a3b8'; ctx.strokeRect(w / 2 - 15, h - 40, 30, 40);
                if (y > h - 20) { ctx.fillStyle = '#eab308'; ctx.fillRect(w / 2 - 14, h - 39, 28, 38); }
                t++; requestAnimationFrame(loop);
            } loop();
        }
        function startG2Meta(c) {
            const ctx = c.getContext('2d'); let t = 0; let active = true; c._simActiveSetter = (s) => { active = s; if (s) loop(); };
            function loop() {
                if (!active) return; const w = c.width = c.clientWidth; const h = c.height = c.clientHeight;
                ctx.fillStyle = '#e0f2fe'; ctx.fillRect(0, 0, w, h);
                const scale = (Math.sin(t * 0.05) + 1) / 2; // 0 to 1
                const cx = w / 2; const cy = h / 2;
                if (scale < 0.5) {
                    // Caterpillar
                    ctx.fillStyle = '#84cc16'; ctx.beginPath(); ctx.arc(cx - 10, cy, 5, 0, Math.PI * 2); ctx.arc(cx, cy, 5, 0, Math.PI * 2); ctx.arc(cx + 10, cy, 5, 0, Math.PI * 2); ctx.fill();
                } else {
                    // Butterfly
                    ctx.fillStyle = '#f472b6';
                    ctx.beginPath(); ctx.ellipse(cx - 10, cy, 10, 15, 0, 0, Math.PI * 2); ctx.fill();
                    ctx.beginPath(); ctx.ellipse(cx + 10, cy, 10, 15, 0, 0, Math.PI * 2); ctx.fill();
                }
                t++; requestAnimationFrame(loop);
            } loop();
        }
        function startG2Compass(c) {
            const ctx = c.getContext('2d'); let t = 0; let active = true; c._simActiveSetter = (s) => { active = s; if (s) loop(); };
            function loop() {
                if (!active) return; const w = c.width = c.clientWidth; const h = c.height = c.clientHeight;
                ctx.fillStyle = '#86efac'; ctx.fillRect(0, 0, w, h);
                const cx = w / 2; const cy = h / 2;
                // Compass Needle
                ctx.save(); ctx.translate(cx, cy); ctx.rotate(t * 0.05);
                ctx.fillStyle = 'red'; ctx.fillRect(-2, -20, 4, 40);
                ctx.restore();
                t++; requestAnimationFrame(loop);
            } loop();
        }
        function startG2Clock(c) {
            const ctx = c.getContext('2d'); let t = 0; let active = true; c._simActiveSetter = (s) => { active = s; if (s) loop(); };
            function loop() {
                if (!active) return; const w = c.width = c.clientWidth; const h = c.height = c.clientHeight;
                ctx.fillStyle = '#e0f2fe'; ctx.fillRect(0, 0, w, h);
                const cx = w / 2; const cy = h / 2;
                ctx.beginPath(); ctx.arc(cx, cy, 20, 0, Math.PI * 2); ctx.strokeStyle = '#333'; ctx.stroke();
                // Hand
                ctx.save(); ctx.translate(cx, cy); ctx.rotate(t * 0.1);
                ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(0, -15); ctx.stroke();
                ctx.restore();
                t++; requestAnimationFrame(loop);
            } loop();
        }

        // --- GRADE 3 MICRO SIMS ---
        function startG3Water(c) {
            const ctx = c.getContext('2d'); let t = 0; let active = true; c._simActiveSetter = (s) => { active = s; if (s) loop(); };
            function loop() {
                if (!active) return; const w = c.width = c.clientWidth; const h = c.height = c.clientHeight;
                ctx.fillStyle = '#0f172a'; ctx.fillRect(0, 0, w, h);
                // Rain
                ctx.strokeStyle = '#3b82f6'; ctx.beginPath();
                for (let i = 0; i < 10; i++) {
                    let x = (t * 5 + i * 30) % w;
                    let y = (t * 10 + i * 20) % h;
                    ctx.moveTo(x, y); ctx.lineTo(x, y + 10);
                } ctx.stroke();
                // Sun
                ctx.fillStyle = '#f59e0b'; ctx.beginPath(); ctx.arc(w - 20, 20, 15, 0, Math.PI * 2); ctx.fill();
                t++; requestAnimationFrame(loop);
            } loop();
        }
        function startG3Fractions(c) {
            const ctx = c.getContext('2d'); let t = 0; let active = true; c._simActiveSetter = (s) => { active = s; if (s) loop(); };
            function loop() {
                if (!active) return; const w = c.width = c.clientWidth; const h = c.height = c.clientHeight;
                ctx.fillStyle = '#000'; ctx.fillRect(0, 0, w, h);
                const cx = w / 2; const cy = h / 2;
                ctx.strokeStyle = '#a855f7'; ctx.lineWidth = 3;
                ctx.beginPath(); ctx.arc(cx, cy, 20, 0, Math.PI * 2); ctx.stroke();
                // Scanning laser
                ctx.strokeStyle = '#fff'; ctx.lineWidth = 1;
                ctx.beginPath(); ctx.moveTo(cx, cy - 30); ctx.lineTo(cx, cy + 30); ctx.stroke();
                // Split
                if (Math.floor(t / 30) % 2 === 0) {
                    ctx.clearRect(cx - 2, cy - 30, 4, 60);
                }
                t++; requestAnimationFrame(loop);
            } loop();
        }
        function startG3FoodChain(c) {
            const ctx = c.getContext('2d'); let t = 0; let active = true; c._simActiveSetter = (s) => { active = s; if (s) loop(); };
            function loop() {
                if (!active) return; const w = c.width = c.clientWidth; const h = c.height = c.clientHeight;
                ctx.fillStyle = '#22c55e'; ctx.fillRect(0, 0, w, h);
                const cx = Math.cos(t * 0.1) * 30 + w / 2; const cy = Math.sin(t * 0.1) * 10 + h / 2;
                // Rabbit
                ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(cx, cy, 5, 0, Math.PI * 2); ctx.fill();
                // Fox pursuing
                const fx = Math.cos(t * 0.1 - 0.5) * 30 + w / 2; const fy = Math.sin(t * 0.1 - 0.5) * 10 + h / 2;
                ctx.fillStyle = 'orange'; ctx.fillRect(fx - 3, fy - 3, 6, 6);
                t++; requestAnimationFrame(loop);
            } loop();
        }
        function startG3City(c) {
            const ctx = c.getContext('2d'); let t = 0; let active = true; c._simActiveSetter = (s) => { active = s; if (s) loop(); };
            function loop() {
                if (!active) return; const w = c.width = c.clientWidth; const h = c.height = c.clientHeight;
                ctx.fillStyle = '#e0f2fe'; ctx.fillRect(0, 0, w, h);
                const cx = w / 2; const cy = h / 2;
                // Iso blocks
                ctx.fillStyle = '#4ade80';
                ctx.beginPath(); ctx.moveTo(cx, cy - 10); ctx.lineTo(cx + 20, cy); ctx.lineTo(cx, cy + 10); ctx.lineTo(cx - 20, cy); ctx.fill();
                // House pop
                if (t % 60 > 30) {
                    ctx.fillStyle = '#f43f5e'; ctx.fillRect(cx - 5, cy - 20, 10, 10);
                }
                t++; requestAnimationFrame(loop);
            } loop();
        }
        function startG3Solar(c) {
            const ctx = c.getContext('2d'); let t = 0; let active = true; c._simActiveSetter = (s) => { active = s; if (s) loop(); };
            function loop() {
                if (!active) return; const w = c.width = c.clientWidth; const h = c.height = c.clientHeight;
                ctx.fillStyle = '#000'; ctx.fillRect(0, 0, w, h);
                const cx = w / 2; const cy = h / 2;
                ctx.fillStyle = 'yellow'; ctx.beginPath(); ctx.arc(cx, cy, 10, 0, Math.PI * 2); ctx.fill();
                const angle = t * 0.1;
                const px = cx + Math.cos(angle) * 30; const py = cy + Math.sin(angle) * 30;
                ctx.fillStyle = '#3b82f6'; ctx.beginPath(); ctx.arc(px, py, 5, 0, Math.PI * 2); ctx.fill();
                t++; requestAnimationFrame(loop);
            } loop();
        }

        // --- PHYSICS & QUANTUM SIMS ---
        function startPhysicsFolderSim(canvas, isFull) {
            const ctx = canvas.getContext('2d');
            let running = true;
            canvas._simActiveSetter = (isActive) => { running = isActive; if (isActive) loop(); };

            // Double Pendulum State
            let r1 = isFull ? 40 : 20, r2 = isFull ? 40 : 20;
            let m1 = 10, m2 = 10;
            let a1 = Math.PI / 2, a2 = Math.PI / 2;
            let a1_v = 0, a2_v = 0;
            let g = 1;
            let path = [];

            function loop() {
                if (!running || !canvas.isConnected) return;
                const w = canvas.width = canvas.clientWidth;
                const h = canvas.height = canvas.clientHeight;
                const cx = w / 2, cy = h / 3;

                ctx.fillStyle = '#0f172a'; // Dark physics blue
                ctx.fillRect(0, 0, w, h);

                // Math for Double Pendulum (Simplified Euler)
                let num1 = -g * (2 * m1 + m2) * Math.sin(a1);
                let num2 = -m2 * g * Math.sin(a1 - 2 * a2);
                let num3 = -2 * Math.sin(a1 - a2) * m2;
                let num4 = a2_v * a2_v * r2 + a1_v * a1_v * r1 * Math.cos(a1 - a2);
                let den = r1 * (2 * m1 + m2 - m2 * Math.cos(2 * a1 - 2 * a2));
                let a1_a = (num1 + num2 + num3 * num4) / den;

                num1 = 2 * Math.sin(a1 - a2);
                num2 = (a1_v * a1_v * r1 * (m1 + m2));
                num3 = g * (m1 + m2) * Math.cos(a1);
                num4 = a2_v * a2_v * r2 * m2 * Math.cos(a1 - a2);
                den = r2 * (2 * m1 + m2 - m2 * Math.cos(2 * a1 - 2 * a2));
                let a2_a = (num1 * (num2 + num3 + num4)) / den;

                a1_v += a1_a; a2_v += a2_a;
                a1 += a1_v; a2 += a2_v;
                a1_v *= 0.999; a2_v *= 0.999; // Drag

                // Positions
                let x1 = r1 * Math.sin(a1);
                let y1 = r1 * Math.cos(a1);
                let x2 = x1 + r2 * Math.sin(a2);
                let y2 = y1 + r2 * Math.cos(a2);

                // Draw
                ctx.translate(cx, cy);
                ctx.strokeStyle = '#94a3b8';
                ctx.lineWidth = 2;
                ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(x1, y1); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(x1, y1); ctx.lineTo(x2, y2); ctx.stroke();

                ctx.fillStyle = '#38bdf8';
                ctx.beginPath(); ctx.arc(x1, y1, 5, 0, Math.PI * 2); ctx.fill();
                ctx.fillStyle = '#f472b6';
                ctx.beginPath(); ctx.arc(x2, y2, 5, 0, Math.PI * 2); ctx.fill();

                // Trail
                path.push({ x: x2, y: y2 });
                if (path.length > 50) path.shift();

                ctx.beginPath();
                ctx.strokeStyle = 'rgba(244, 114, 182, 0.5)';
                path.forEach((p, i) => {
                    if (i === 0) ctx.moveTo(p.x, p.y);
                    else ctx.lineTo(p.x, p.y);
                });
                ctx.stroke();

                ctx.setTransform(1, 0, 0, 1, 0, 0);
                requestAnimationFrame(loop);
            }
            loop();
        }

        function startQuantumWaveSim(canvas, isFull) {
            const ctx = canvas.getContext('2d');
            let running = true;
            canvas._simActiveSetter = (isActive) => { running = isActive; if (isActive) loop(); };
            let t = 0;

            function loop() {
                if (!running || !canvas.isConnected) return;
                const w = canvas.width = canvas.clientWidth;
                const h = canvas.height = canvas.clientHeight;
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, w, h);

                // Simplified Interference Pattern
                const cx1 = w * 0.3; const cy1 = h * 0.3;
                const cx2 = w * 0.3; const cy2 = h * 0.7;

                const imageData = ctx.createImageData(w, h);
                const data = imageData.data;
                const k = 0.2;

                for (let y = 0; y < h; y += 2) {
                    for (let x = 0; x < w; x += 2) {
                        const d1 = Math.sqrt((x - cx1) * (x - cx1) + (y - cy1) * (y - cy1));
                        const d2 = Math.sqrt((x - cx2) * (x - cx2) + (y - cy2) * (y - cy2));

                        const val = Math.sin(d1 * k - t * 0.2) + Math.sin(d2 * k - t * 0.2);
                        const i = (y * w + x) * 4;
                        const intensity = (val + 2) * 40;

                        data[i] = intensity * 0.1;   // R
                        data[i + 1] = intensity;       // G
                        data[i + 2] = intensity * 0.9; // B
                        data[i + 3] = 255;

                        if (x + 1 < w) {
                            data[i + 4] = data[i]; data[i + 5] = data[i + 1]; data[i + 6] = data[i + 2]; data[i + 7] = 255;
                        }
                    }
                }
                ctx.putImageData(imageData, 0, 0);
                t++;
                requestAnimationFrame(loop);
            }
            loop();
        }

        function startChaosPendulumSim(canvas, isFull) {
            startPhysicsFolderSim(canvas, isFull);
        }

        function startWindTunnelSim(canvas, isFull) {
            const ctx = canvas.getContext('2d');
            let running = true;
            canvas._simActiveSetter = (isActive) => { running = isActive; if (isActive) loop(); };
            let t = 0;
            const particles = Array.from({ length: 50 }, () => ({
                x: Math.random() * canvas.width,
                y: Math.random() * canvas.height,
                spd: Math.random() * 2 + 1
            }));

            function loop() {
                if (!running || !canvas.isConnected) return;
                const w = canvas.width = canvas.clientWidth;
                const h = canvas.height = canvas.clientHeight;

                ctx.fillStyle = '#0f172a';
                ctx.fillRect(0, 0, w, h);

                // Obstacle (Airfoil shape)
                ctx.fillStyle = 'rgba(255,255,255,0.1)';
                ctx.beginPath();
                ctx.ellipse(w / 2, h / 2, 20, 10, 0, 0, Math.PI * 2);
                ctx.fill();

                // Flow
                particles.forEach(p => {
                    p.x += p.spd;
                    // Avoid Obstacle (Fake potential flow)
                    const dx = p.x - w / 2;
                    const dy = p.y - h / 2;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < 25) {
                        p.y += (dy > 0 ? 1 : -1) * 2;
                    }

                    if (p.x > w) {
                        p.x = 0;
                        p.y = Math.random() * h;
                    }

                    ctx.fillStyle = p.spd > 2 ? '#f472b6' : '#06b6d4';
                    ctx.fillRect(p.x, p.y, 2, 2);
                });

                t++;
                requestAnimationFrame(loop);
            }
            loop();
        }

        function startGravityWellSim(canvas, isFull) {
            const ctx = canvas.getContext('2d');
            let running = true;
            canvas._simActiveSetter = (isActive) => { running = isActive; if (isActive) loop(); };
            let t = 0;

            function loop() {
                if (!running || !canvas.isConnected) return;
                const w = canvas.width = canvas.clientWidth;
                const h = canvas.height = canvas.clientHeight;
                const cx = w / 2, cy = h / 2;

                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, w, h);

                // Accretion Disk (2D Projection)
                ctx.save();
                ctx.translate(cx, cy);
                ctx.scale(1, 0.3); // Flatten
                ctx.rotate(t * 0.02);

                // Draw multiple rings
                for (let r = 20; r < 60; r += 2) {
                    ctx.beginPath();
                    ctx.arc(0, 0, r, 0, Math.PI * 2);
                    // Color shift
                    const hue = (t + r * 5) % 360;
                    ctx.strokeStyle = `hsla(${hue}, 100%, 50%, 0.3)`;
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
                ctx.restore();

                // Black Hole
                ctx.fillStyle = '#000';
                ctx.beginPath(); ctx.arc(cx, cy, 15, 0, Math.PI * 2); ctx.fill();
                // Photon Ring
                ctx.strokeStyle = '#fff'; ctx.lineWidth = 1;
                ctx.beginPath(); ctx.arc(cx, cy, 17, 0, Math.PI * 2); ctx.stroke();

                t++;
                requestAnimationFrame(loop);
            }
            loop();
        }

        function startOpticsLabSim(canvas, isFull) {
            const ctx = canvas.getContext('2d');
            let running = true;
            canvas._simActiveSetter = (isActive) => { running = isActive; if (isActive) loop(); };
            let t = 0;

            function loop() {
                if (!running || !canvas.isConnected) return;
                const w = canvas.width = canvas.clientWidth;
                const h = canvas.height = canvas.clientHeight;
                const cx = w / 2, cy = h / 2;

                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, w, h);

                // Prism Triangle
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(cx, cy - 20);
                ctx.lineTo(cx + 20, cy + 20);
                ctx.lineTo(cx - 20, cy + 20);
                ctx.closePath();
                ctx.stroke();

                // Laser Beam
                ctx.strokeStyle = '#fff'; ctx.globalAlpha = 1.0;
                ctx.lineWidth = 2;
                ctx.beginPath(); ctx.moveTo(0, cy); ctx.lineTo(cx - 10, cy + 5); ctx.stroke();

                // Dispersion
                const offset = Math.sin(t * 0.05) * 5;

                // Red
                ctx.strokeStyle = '#f00'; ctx.beginPath(); ctx.moveTo(cx + 10, cy + 10); ctx.lineTo(w, cy + 20 + offset); ctx.stroke();
                // Green
                ctx.strokeStyle = '#0f0'; ctx.beginPath(); ctx.moveTo(cx + 10, cy + 10); ctx.lineTo(w, cy + offset); ctx.stroke();
                // Blue
                ctx.strokeStyle = '#00f'; ctx.beginPath(); ctx.moveTo(cx + 10, cy + 10); ctx.lineTo(w, cy - 20 + offset); ctx.stroke();

                t++;
                requestAnimationFrame(loop);
            }
            loop();
        }

        function startDataScienceSim(canvas, isFull) {
            const ctx = canvas.getContext('2d');
            let running = true;
            canvas._simActiveSetter = (isActive) => { running = isActive; if (isActive) loop(); };

            let points = [];
            let centers = [];
            let init = false;

            function loop() {
                if (!running || !canvas.isConnected) return;
                const w = canvas.width = canvas.clientWidth;
                const h = canvas.height = canvas.clientHeight;

                if (w === 0 || h === 0) { requestAnimationFrame(loop); return; }

                if (!init) {
                    points = Array.from({ length: 30 }, () => ({
                        x: Math.random() * w,
                        y: Math.random() * h,
                        color: '#fff'
                    }));
                    centers = [
                        { x: w * 0.3, y: h * 0.5, c: '#22d3ee' },
                        { x: w * 0.7, y: h * 0.5, c: '#f472b6' }
                    ];
                    init = true;
                }

                ctx.fillStyle = '#0F172A';
                ctx.fillRect(0, 0, w, h);

                // Draw Centers
                centers.forEach(c => {
                    ctx.fillStyle = c.c;
                    ctx.shadowBlur = 10; ctx.shadowColor = c.c;
                    ctx.beginPath(); ctx.arc(c.x, c.y, 6, 0, Math.PI * 2); ctx.fill();
                    ctx.shadowBlur = 0;
                });

                // Move Points
                points.forEach(p => {
                    let closest = centers[0];
                    let minD = 10000;
                    centers.forEach(c => {
                        const d = (p.x - c.x) ** 2 + (p.y - c.y) ** 2;
                        if (d < minD) { minD = d; closest = c; }
                    });

                    p.x += (closest.x - p.x) * 0.05;
                    p.y += (closest.y - p.y) * 0.05;

                    // Jitter
                    p.x += (Math.random() - 0.5) * 2;
                    p.y += (Math.random() - 0.5) * 2;

                    ctx.fillStyle = closest.c;
                    ctx.fillRect(p.x, p.y, 2, 2);
                });

                // Reset occasionally
                if (Math.random() < 0.01) {
                    points.forEach(p => {
                        p.x = Math.random() * w;
                        p.y = Math.random() * h;
                    });
                }

                requestAnimationFrame(loop);
            }
            loop();
        }

        function startCSSim(canvas, isFull) {
            const ctx = canvas.getContext('2d');
            let running = true;
            canvas._simActiveSetter = (isActive) => { running = isActive; if (isActive) loop(); };
            let t = 0;

            function loop() {
                if (!running || !canvas.isConnected) return;
                const w = canvas.width = canvas.clientWidth;
                const h = canvas.height = canvas.clientHeight;
                ctx.fillStyle = '#0F172A'; ctx.fillRect(0, 0, w, h);

                const cx = w / 2;
                const startY = h - 10;

                // Binary Tree
                ctx.strokeStyle = '#4ADE80';
                ctx.lineWidth = 2;

                function branch(x, y, len, angle, depth) {
                    if (depth === 0) return;
                    const ex = x + Math.cos(angle) * len;
                    const ey = y + Math.sin(angle) * len;

                    ctx.beginPath(); ctx.moveTo(x, y); ctx.lineTo(ex, ey); ctx.stroke();

                    if (depth > 1) {
                        branch(ex, ey, len * 0.7, angle - 0.5 + Math.sin(t * 0.05) * 0.1, depth - 1);
                        branch(ex, ey, len * 0.7, angle + 0.5 + Math.sin(t * 0.05) * 0.1, depth - 1);
                    } else {
                        // Leaf
                        ctx.fillStyle = '#22d3ee';
                        ctx.fillRect(ex - 2, ey - 2, 4, 4);
                    }
                }

                branch(cx, h - 10, 30, -Math.PI / 2, 4);

                t++;
                requestAnimationFrame(loop);
            }
            loop();
        }

        function startElectricalSim(canvas, isFull) {
            const ctx = canvas.getContext('2d');
            let running = true;
            canvas._simActiveSetter = (isActive) => { running = isActive; if (isActive) loop(); };
            let t = 0;

            function loop() {
                if (!running || !canvas.isConnected) return;
                const w = canvas.width = canvas.clientWidth;
                const h = canvas.height = canvas.clientHeight;
                ctx.fillStyle = '#0F172A'; ctx.fillRect(0, 0, w, h);

                const cx = w / 2, cy = h / 2;
                const rw = w * 0.6, rh = h * 0.6;

                // Circuit Path
                ctx.strokeStyle = '#3b82f6';
                ctx.lineWidth = 4;
                ctx.strokeRect(cx - rw / 2, cy - rh / 2, rw, rh);

                // Battery
                ctx.clearRect(cx - 20, cy - rh / 2 - 5, 40, 10);
                ctx.strokeStyle = '#fff';
                ctx.beginPath();
                ctx.moveTo(cx - 10, cy - rh / 2 - 5); ctx.lineTo(cx - 10, cy - rh / 2 + 5); // +
                ctx.moveTo(cx + 10, cy - rh / 2 - 2); ctx.lineTo(cx + 10, cy - rh / 2 + 2); // -
                ctx.stroke();

                // Electrons
                ctx.fillStyle = '#fbbf24';
                for (let i = 0; i < 8; i++) {
                    const prog = (t * 0.02 + i / 8) % 4;
                    let ex = 0, ey = 0;
                    if (prog < 1) { // Top
                        ex = (cx + rw / 2) - (prog * rw);
                        ey = cy - rh / 2;
                    } else if (prog < 2) { // Left
                        ex = cx - rw / 2;
                        ey = (cy - rh / 2) + ((prog - 1) * rh);
                    } else if (prog < 3) { // Bottom
                        ex = (cx - rw / 2) + ((prog - 2) * rw);
                        ey = cy + rh / 2;
                    } else { // Right
                        ex = cx + rw / 2;
                        ey = (cy + rh / 2) - ((prog - 3) * rh);
                    }

                    ctx.beginPath(); ctx.arc(ex, ey, 4, 0, Math.PI * 2); ctx.fill();
                }

                t++;
                requestAnimationFrame(loop);
            }
            loop();
        }

        function startECESim(canvas, isFull) {
            const ctx = canvas.getContext('2d');
            let running = true;
            canvas._simActiveSetter = (isActive) => { running = isActive; if (isActive) loop(); };
            let t = 0;

            function loop() {
                if (!running || !canvas.isConnected) return;
                const w = canvas.width = canvas.clientWidth;
                const h = canvas.height = canvas.clientHeight;
                const cy = h / 2;

                ctx.fillStyle = '#020617';
                ctx.fillRect(0, 0, w, h);

                // Draw AM Wave
                ctx.beginPath();
                ctx.strokeStyle = '#4ADE80';
                ctx.lineWidth = 2;
                for (let x = 0; x < w; x += 2) {
                    // Envelope
                    const env = 0.5 + 0.5 * Math.sin((x + t) * 0.05);
                    // Carrier
                    const car = Math.sin((x + t * 5) * 0.5);
                    const y = cy + (env * car * 40);
                    if (x === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
                }
                ctx.stroke();

                t++;
                requestAnimationFrame(loop);
            }
            loop();
        }

        function startMechSim(canvas, isFull) {
            const ctx = canvas.getContext('2d');
            let running = true;
            canvas._simActiveSetter = (isActive) => { running = isActive; if (isActive) loop(); };
            let ang = 0;

            function loop() {
                if (!running || !canvas.isConnected) return;
                const w = canvas.width = canvas.clientWidth;
                const h = canvas.height = canvas.clientHeight;
                const cx = w / 2, cy = h * 0.6;
                const r = 30, l = 80;

                ctx.fillStyle = '#0F172A';
                ctx.fillRect(0, 0, w, h);

                // Kinematics
                const rad = ang * Math.PI / 180;
                const px = cx + Math.cos(rad) * r;
                const py = cy + Math.sin(rad) * r;

                // Piston Y (Simple approx for preview)
                const pistonY = cy - (Math.sin(rad) * r + Math.sqrt(l * l - (Math.cos(rad) * r) ** 2)) + 50;
                // Ah, slider crank is complex. Visual approx:
                const yPos = cy - (r * Math.sin(rad - Math.PI / 2) + Math.sqrt(l * l - (r * Math.cos(rad - Math.PI / 2)) ** 2));

                // Crank
                ctx.beginPath(); ctx.moveTo(cx, cy); ctx.lineTo(px, py);
                ctx.strokeStyle = '#475569'; ctx.lineWidth = 5; ctx.stroke();

                // Rod
                // Calc piston pos exactly? 
                const pistonH = cy - (Math.sin(rad) * r + l); // very rough

                // Draw circle crank
                ctx.beginPath(); ctx.arc(cx, cy, r, 0, Math.PI * 2); ctx.strokeStyle = '#334155'; ctx.lineWidth = 1; ctx.stroke();

                ang += 5;
                requestAnimationFrame(loop);
            }
            loop();
        }

        function startITSim(canvas, isFull) {
            const ctx = canvas.getContext('2d');
            let running = true;
            canvas._simActiveSetter = (isActive) => { running = isActive; if (isActive) loop(); };
            let t = 0;

            function loop() {
                if (!running || !canvas.isConnected) return;
                const w = canvas.width = canvas.clientWidth;
                const h = canvas.height = canvas.clientHeight;
                ctx.fillStyle = '#0F172A'; ctx.fillRect(0, 0, w, h);

                const cx = w / 2, cy = h / 2;

                // Draw 3 Servers (Isometric-ish)
                const servers = [
                    { x: cx, y: cy - 20 },
                    { x: cx - 20, y: cy },
                    { x: cx + 20, y: cy }
                ];

                servers.forEach((s, i) => {
                    const active = Math.sin(t * 0.1 + i) > 0;
                    ctx.fillStyle = active ? '#22c55e' : '#1e293b'; // Blink green/dark
                    ctx.beginPath();
                    // Iso box
                    ctx.moveTo(s.x, s.y);
                    ctx.lineTo(s.x + 10, s.y + 5);
                    ctx.lineTo(s.x, s.y + 10);
                    ctx.lineTo(s.x - 10, s.y + 5);
                    ctx.fill();
                    // Sides
                    ctx.fillStyle = '#334155';
                    ctx.beginPath();
                    ctx.moveTo(s.x - 10, s.y + 5); ctx.lineTo(s.x, s.y + 10); ctx.lineTo(s.x, s.y + 20); ctx.lineTo(s.x - 10, s.y + 15); ctx.fill();
                    ctx.fillStyle = '#1e293b';
                    ctx.beginPath();
                    ctx.moveTo(s.x, s.y + 10); ctx.lineTo(s.x + 10, s.y + 5); ctx.lineTo(s.x + 10, s.y + 15); ctx.lineTo(s.x, s.y + 20); ctx.fill();
                });

                // Packets flying
                ctx.fillStyle = '#3b82f6';
                for (let i = 0; i < 3; i++) {
                    const prog = (t * 0.02 + i * 0.3) % 1;
                    const tx = servers[i].x;
                    const ty = servers[i].y;
                    // From top
                    const px = cx + (tx - cx) * prog;
                    const py = (cy - 50) + (ty - (cy - 50)) * prog;
                    if (prog < 0.9) ctx.fillRect(px - 2, py - 2, 4, 4);
                }

                t++;
                requestAnimationFrame(loop);
            }
            loop();
        }

        function startThermoLabSim(canvas, isFull) {
            const ctx = canvas.getContext('2d');
            let running = true;
            canvas._simActiveSetter = (isActive) => { running = isActive; if (isActive) loop(); };
            let t = 0;
            const particles = Array.from({ length: 40 }, () => ({
                x: Math.random() * canvas.width,
                y: Math.random() * canvas.height,
                vx: (Math.random() - 0.5) * 2,
                vy: (Math.random() - 0.5) * 2
            }));

            function loop() {
                if (!running || !canvas.isConnected) return;
                const w = canvas.width = canvas.clientWidth;
                const h = canvas.height = canvas.clientHeight;

                ctx.fillStyle = '#050505';
                ctx.fillRect(0, 0, w, h);

                // Wall
                ctx.strokeStyle = '#444';
                ctx.beginPath(); ctx.moveTo(w / 2, 0); ctx.lineTo(w / 2, h); ctx.stroke();

                particles.forEach(p => {
                    p.x += p.vx; p.y += p.vy;
                    if (p.x < 0 || p.x > w) p.vx *= -1;
                    if (p.y < 0 || p.y > h) p.vy *= -1;
                    if (Math.abs(p.x - w / 2) < 2) p.vx *= -1; // Bounce middle

                    const speed = Math.sqrt(p.vx * p.vx + p.vy * p.vy);
                    // Color Map
                    ctx.fillStyle = speed > 1.2 ? '#ff3300' : '#0066ff';
                    ctx.beginPath(); ctx.arc(p.x, p.y, 2, 0, Math.PI * 2); ctx.fill();
                });

                t++;
                requestAnimationFrame(loop);
            }
            loop();
        }

        // --- GRADE 11 MICRO SIMS ---
        function startG11Vectors(c) { const ctx = c.getContext('2d'); let t = 0; let a = true; c._simActiveSetter = s => { a = s; if (s) l() }; function l() { if (!a) return; const w = c.width = c.clientWidth; const h = c.height = c.clientHeight; ctx.fillStyle = '#0f172a'; ctx.fillRect(0, 0, w, h); const cx = w / 2, cy = h / 2; ctx.strokeStyle = '#3b82f6'; ctx.beginPath(); ctx.moveTo(cx, cy); ctx.lineTo(cx + Math.cos(t * 0.05) * 30, cy + Math.sin(t * 0.05) * 30); ctx.stroke(); t++; requestAnimationFrame(l); } l(); }

        function startG11Complex(c) { const ctx = c.getContext('2d'); let t = 0; let a = true; c._simActiveSetter = s => { a = s; if (s) l() }; function l() { if (!a) return; const w = c.width = c.clientWidth; const h = c.height = c.clientHeight; ctx.fillStyle = '#fff'; ctx.fillRect(0, 0, w, h); const cx = w / 2, cy = h / 2; ctx.fillStyle = '#a855f7'; ctx.beginPath(); ctx.arc(cx + Math.cos(t * 0.1) * 20, cy + Math.sin(t * 0.1) * 20, 5, 0, Math.PI * 2); ctx.fill(); t++; requestAnimationFrame(l); } l(); }

        function startG11Vsepr(c) { const ctx = c.getContext('2d'); let t = 0; let a = true; c._simActiveSetter = s => { a = s; if (s) l() }; function l() { if (!a) return; const w = c.width = c.clientWidth; const h = c.height = c.clientHeight; ctx.fillStyle = '#0f172a'; ctx.fillRect(0, 0, w, h); const cx = w / 2, cy = h / 2; ctx.fillStyle = '#22d3ee'; ctx.beginPath(); ctx.arc(cx, cy, 10, 0, Math.PI * 2); ctx.fill(); ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(cx + Math.cos(t * 0.05) * 20, cy + Math.sin(t * 0.05) * 20, 5, 0, Math.PI * 2); ctx.fill(); t++; requestAnimationFrame(l); } l(); }

        function startG11Neuron(c) { const ctx = c.getContext('2d'); let t = 0; let a = true; c._simActiveSetter = s => { a = s; if (s) l() }; function l() { if (!a) return; const w = c.width = c.clientWidth; const h = c.height = c.clientHeight; ctx.fillStyle = '#0f172a'; ctx.fillRect(0, 0, w, h); const cx = w / 2, cy = h / 2; ctx.strokeStyle = '#eab308'; ctx.beginPath(); ctx.moveTo(0, cy); ctx.lineTo(w, cy); ctx.stroke(); if ((t % 20) < 5) { ctx.fillStyle = '#fbbf24'; ctx.fillRect(t % w, cy - 2, 10, 4); } t += 5; requestAnimationFrame(l); } l(); }

        function startG11Recursion(c) { const ctx = c.getContext('2d'); let t = 0; let a = true; c._simActiveSetter = s => { a = s; if (s) l() }; function l() { if (!a) return; const w = c.width = c.clientWidth; const h = c.height = c.clientHeight; ctx.fillStyle = '#fff'; ctx.fillRect(0, 0, w, h); ctx.strokeStyle = '#000'; function r(x, y, s) { if (s < 2) return; ctx.strokeRect(x - s / 2, y - s / 2, s, s); r(x - s / 2, y - s / 2, s / 2); r(x + s / 2, y + s / 2, s / 2); } r(w / 2, h / 2, 30 + Math.sin(t * 0.05) * 10); t++; requestAnimationFrame(l); } l(); }


        // --- GRADE 12 MICRO SIMS ---
        function startG12Generator(c) { const ctx = c.getContext('2d'); let t = 0; let a = true; c._simActiveSetter = s => { a = s; if (s) l() }; function l() { if (!a) return; const w = c.width = c.clientWidth; const h = c.height = c.clientHeight; ctx.fillStyle = '#0f172a'; ctx.fillRect(0, 0, w, h); const cx = w / 2, cy = h / 2; ctx.strokeStyle = '#3b82f6'; ctx.beginPath(); ctx.arc(cx, cy, 15, 0, Math.PI * 2); ctx.stroke(); ctx.fillStyle = '#ef4444'; ctx.save(); ctx.translate(cx, cy); ctx.rotate(t * 0.1); ctx.fillRect(-15, -2, 30, 4); ctx.restore(); t++; requestAnimationFrame(l); } l(); }

        function startG12Integral(c) { const ctx = c.getContext('2d'); let t = 0; let a = true; c._simActiveSetter = s => { a = s; if (s) l() }; function l() { if (!a) return; const w = c.width = c.clientWidth; const h = c.height = c.clientHeight; ctx.fillStyle = '#fff'; ctx.fillRect(0, 0, w, h); ctx.fillStyle = 'rgba(59,130,246,0.2)'; ctx.beginPath(); ctx.moveTo(0, h); for (let i = 0; i < w; i += 5) { ctx.lineTo(i, h - (Math.sin(i * 0.02 + t * 0.05) + 1) * 20); } ctx.lineTo(w, h); ctx.fill(); t++; requestAnimationFrame(l); } l(); }

        function startG12Translation(c) { const ctx = c.getContext('2d'); let t = 0; let a = true; c._simActiveSetter = s => { a = s; if (s) l() }; function l() { if (!a) return; const w = c.width = c.clientWidth; const h = c.height = c.clientHeight; ctx.fillStyle = '#0f172a'; ctx.fillRect(0, 0, w, h); ctx.fillStyle = '#22c55e'; for (let i = 0; i < 5; i++) { ctx.fillRect((t + i * 20) % w, h / 2 - 5, 10, 10); } t++; requestAnimationFrame(l); } l(); }

        function startG12Equilibrium(c) { const ctx = c.getContext('2d'); let t = 0; let a = true; c._simActiveSetter = s => { a = s; if (s) l() }; function l() { if (!a) return; const w = c.width = c.clientWidth; const h = c.height = c.clientHeight; ctx.fillStyle = '#fff'; ctx.fillRect(0, 0, w, h); const cx = w / 2; ctx.fillStyle = '#3b82f6'; ctx.fillRect(cx - 20, h / 2, 10, Math.sin(t * 0.05) * 10 + 20); ctx.fillStyle = '#ef4444'; ctx.fillRect(cx + 10, h / 2, 10, Math.cos(t * 0.05) * 10 + 20); t++; requestAnimationFrame(l); } l(); }

        function startG12Pathfinding(c) { const ctx = c.getContext('2d'); let t = 0; let a = true; c._simActiveSetter = s => { a = s; if (s) l() }; function l() { if (!a) return; const w = c.width = c.clientWidth; const h = c.height = c.clientHeight; ctx.fillStyle = '#0f172a'; ctx.fillRect(0, 0, w, h); const cx = w / 2, cy = h / 2; ctx.fillStyle = '#eab308'; ctx.beginPath(); ctx.arc(cx + Math.cos(t * 0.05) * 20, cy + Math.sin(t * 0.05) * 20, 3, 0, Math.PI * 2); ctx.fill(); ctx.strokeStyle = '#334155'; ctx.strokeRect(cx - 20, cy - 20, 40, 40); t++; requestAnimationFrame(l); } l(); }
        function startG4Lever(c) {
            const ctx = c.getContext('2d'); let t = 0; let active = true; c._simActiveSetter = (s) => { active = s; if (s) loop(); };
            function loop() {
                if (!active) return; const w = c.width = c.clientWidth; const h = c.height = c.clientHeight;
                ctx.fillStyle = '#1e293b'; ctx.fillRect(0, 0, w, h);
                const cx = w / 2; const cy = h / 2;
                const angle = Math.sin(t * 0.1) * 0.2;
                ctx.translate(cx, cy);
                // Triangle
                ctx.fillStyle = 'orange'; ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(-10, 15); ctx.lineTo(10, 15); ctx.fill();
                // Plank
                ctx.rotate(angle); ctx.fillStyle = '#94a3b8'; ctx.fillRect(-30, -2, 60, 4);
                // Block
                ctx.fillStyle = '#333'; ctx.fillRect(-25, -10, 10, 8);
                t++; requestAnimationFrame(loop);
            } loop();
        }
        function startG4Area(c) {
            const ctx = c.getContext('2d'); let t = 0; let active = true; c._simActiveSetter = (s) => { active = s; if (s) loop(); };
            function loop() {
                if (!active) return; const w = c.width = c.clientWidth; const h = c.height = c.clientHeight;
                ctx.fillStyle = '#000'; ctx.fillRect(0, 0, w, h);
                const cx = w / 2; const cy = h / 2;
                // Grid
                const s = (Math.floor(t / 20) % 5) + 1; // 1 to 5 size
                ctx.strokeStyle = 'blue'; ctx.strokeRect(cx - s * 5, cy - s * 5, s * 10, s * 10);
                ctx.fillStyle = 'rgba(0,0,255,0.3)'; ctx.fillRect(cx - s * 5, cy - s * 5, s * 10, s * 10);
                t++; requestAnimationFrame(loop);
            } loop();
        }
        function startG4Photo(c) {
            const ctx = c.getContext('2d'); let t = 0; let active = true; c._simActiveSetter = (s) => { active = s; if (s) loop(); };
            function loop() {
                if (!active) return; const w = c.width = c.clientWidth; const h = c.height = c.clientHeight;
                ctx.fillStyle = '#064e3b'; ctx.fillRect(0, 0, w, h);
                const cx = w / 2; const cy = h / 2;
                ctx.fillStyle = 'green'; ctx.beginPath(); ctx.arc(cx, cy, 15, 0, Math.PI * 2); ctx.fill();
                // Particles in
                const r = (t % 20) + 10;
                ctx.fillStyle = 'yellow'; ctx.beginPath(); ctx.arc(cx, cy - r, 2, 0, Math.PI * 2); ctx.fill();
                t++; requestAnimationFrame(loop);
            } loop();
        }
        function startG4LatLong(c) {
            const ctx = c.getContext('2d'); let t = 0; let active = true; c._simActiveSetter = (s) => { active = s; if (s) loop(); };
            function loop() {
                if (!active) return; const w = c.width = c.clientWidth; const h = c.height = c.clientHeight;
                ctx.fillStyle = '#0f172a'; ctx.fillRect(0, 0, w, h);
                const cx = w / 2; const cy = h / 2;
                ctx.strokeStyle = '#1e3a8a'; ctx.beginPath(); ctx.arc(cx, cy, 20, 0, Math.PI * 2); ctx.stroke();
                // Rotating line
                ctx.save(); ctx.translate(cx, cy); ctx.rotate(t * 0.05);
                ctx.beginPath(); ctx.ellipse(0, 0, 20, 5, 0, 0, Math.PI * 2); ctx.stroke();
                ctx.restore();
                t++; requestAnimationFrame(loop);
            } loop();
        }
        function startG4Moon(c) {
            const ctx = c.getContext('2d'); let t = 0; let active = true; c._simActiveSetter = (s) => { active = s; if (s) loop(); };
            function loop() {
                if (!active) return; const w = c.width = c.clientWidth; const h = c.height = c.clientHeight;
                ctx.fillStyle = '#000'; ctx.fillRect(0, 0, w, h);
                const cx = w / 2; const cy = h / 2;
                const phase = (Math.sin(t * 0.05) + 1) / 2 * 20; // 0 to 20 width
                ctx.fillStyle = '#fff';
                ctx.beginPath(); ctx.arc(cx, cy, 10, -Math.PI / 2, Math.PI / 2); ctx.fill();
                ctx.fillStyle = Math.cos(t * 0.05) > 0 ? '#fff' : '#000';
                ctx.beginPath(); ctx.ellipse(cx, cy, Math.abs(Math.cos(t * 0.05) * 10), 10, 0, -Math.PI / 2, Math.PI / 2); ctx.fill();
                t++; requestAnimationFrame(loop);
            } loop();
        }

        // --- GRADE 5 MICRO SIMS ---
        function startG5Circuits(c) {
            const ctx = c.getContext('2d'); let t = 0; let active = true; c._simActiveSetter = (s) => { active = s; if (s) loop(); };
            function loop() {
                if (!active) return; const w = c.width = c.clientWidth; const h = c.height = c.clientHeight;
                ctx.fillStyle = '#0F172A'; ctx.fillRect(0, 0, w, h);
                const cx = w / 2; const cy = h / 2;
                // Circuit path
                ctx.strokeStyle = '#FACC15'; ctx.lineWidth = 2;
                ctx.beginPath(); ctx.rect(cx - 20, cy - 15, 40, 30); ctx.stroke();
                // Bulb
                const glow = (Math.sin(t * 0.2) + 1) * 0.5;
                ctx.fillStyle = `rgba(255,255,0,${glow})`;
                ctx.beginPath(); ctx.arc(cx, cy - 15, 5, 0, Math.PI * 2); ctx.fill();
                t++; requestAnimationFrame(loop);
            } loop();
        }
        function startG5Volume(c) {
            const ctx = c.getContext('2d'); let t = 0; let active = true; c._simActiveSetter = (s) => { active = s; if (s) loop(); };
            function loop() {
                if (!active) return; const w = c.width = c.clientWidth; const h = c.height = c.clientHeight;
                ctx.fillStyle = '#e0f2fe'; ctx.fillRect(0, 0, w, h);
                const cx = w / 2; const cy = h / 2;
                // Stack of cubes
                const n = Math.floor(t / 20) % 4 + 1;
                ctx.fillStyle = '#3b82f6';
                for (let i = 0; i < n; i++) {
                    ctx.fillRect(cx - 5, cy + 10 - i * 6, 10, 5);
                }
                t++; requestAnimationFrame(loop);
            } loop();
        }
        function startG5Lung(c) {
            const ctx = c.getContext('2d'); let t = 0; let active = true; c._simActiveSetter = (s) => { active = s; if (s) loop(); };
            function loop() {
                if (!active) return; const w = c.width = c.clientWidth; const h = c.height = c.clientHeight;
                ctx.fillStyle = '#000'; ctx.fillRect(0, 0, w, h);
                const cx = w / 2; const cy = h / 2;
                const breath = (Math.sin(t * 0.05) + 1) * 0.5; // 0 to 1
                const r = 10 + breath * 5;
                ctx.fillStyle = '#f472b6';
                ctx.beginPath(); ctx.ellipse(cx - 10, cy, r, r * 1.5, 0.2, 0, Math.PI * 2); ctx.fill();
                ctx.beginPath(); ctx.ellipse(cx + 10, cy, r, r * 1.5, -0.2, 0, Math.PI * 2); ctx.fill();
                t++; requestAnimationFrame(loop);
            } loop();
        }
        function startG5Topo(c) {
            const ctx = c.getContext('2d'); let t = 0; let active = true; c._simActiveSetter = (s) => { active = s; if (s) loop(); };
            function loop() {
                if (!active) return; const w = c.width = c.clientWidth; const h = c.height = c.clientHeight;
                ctx.fillStyle = '#000'; ctx.fillRect(0, 0, w, h);
                const cx = w / 2; const cy = h / 2;
                ctx.strokeStyle = '#10b981'; ctx.lineWidth = 1;
                // Scanner line
                const scanY = (t % h);
                ctx.beginPath(); ctx.moveTo(0, scanY); ctx.lineTo(w, scanY); ctx.stroke();
                // Circles
                for (let r = 5; r < 25; r += 5) {
                    ctx.beginPath(); ctx.arc(cx, cy, r, 0, Math.PI * 2); ctx.stroke();
                }
                t++; requestAnimationFrame(loop);
            } loop();
        }
        function startG5Recycle(c) {
            const ctx = c.getContext('2d'); let t = 0; let active = true; c._simActiveSetter = (s) => { active = s; if (s) loop(); };
            function loop() {
                if (!active) return; const w = c.width = c.clientWidth; const h = c.height = c.clientHeight;
                ctx.fillStyle = '#f1f5f9'; ctx.fillRect(0, 0, w, h);
                const cx = w / 2; const cy = h / 2;
                // Conveyor
                ctx.fillStyle = '#333'; ctx.fillRect(0, cy, w, 5);
                // Item
                const x = (w - (t * 2 % w));
                ctx.fillStyle = '#ef4444'; ctx.fillRect(x, cy - 10, 10, 10);
                t++; requestAnimationFrame(loop);
            } loop();
        }

        // --- GRADE 6 MICRO SIMS ---
        function startG6Light(c) {
            const ctx = c.getContext('2d'); let t = 0; let active = true; c._simActiveSetter = (s) => { active = s; if (s) loop(); };
            function loop() {
                if (!active) return; const w = c.width = c.clientWidth; const h = c.height = c.clientHeight;
                ctx.fillStyle = '#000'; ctx.fillRect(0, 0, w, h);
                // Laser
                const lx = w * 0.1; const ly = h * 0.2;
                ctx.strokeStyle = '#f00'; ctx.lineWidth = 2; ctx.shadowBlur = 5; ctx.shadowColor = 'red';
                ctx.beginPath(); ctx.moveTo(lx, ly); ctx.lineTo(w * 0.5, h * 0.8); ctx.lineTo(w * 0.9, h * 0.2); ctx.stroke();
                ctx.shadowBlur = 0;
                t++; requestAnimationFrame(loop);
            } loop();
        }
        function startG6Algebra(c) {
            const ctx = c.getContext('2d'); let t = 0; let active = true; c._simActiveSetter = (s) => { active = s; if (s) loop(); };
            function loop() {
                if (!active) return; const w = c.width = c.clientWidth; const h = c.height = c.clientHeight;
                ctx.fillStyle = '#1c1917'; ctx.fillRect(0, 0, w, h);
                // Scale
                const angle = Math.sin(t * 0.05) * 0.1;
                ctx.save(); ctx.translate(w / 2, h / 2); ctx.rotate(angle);
                ctx.fillStyle = '#fbbf24'; ctx.fillRect(-30, -2, 60, 4);
                // Pans
                ctx.beginPath(); ctx.arc(-30, 20, 10, 0, Math.PI); ctx.fill();
                ctx.beginPath(); ctx.arc(30, 20, 10, 0, Math.PI); ctx.fill();
                ctx.restore();
                t++; requestAnimationFrame(loop);
            } loop();
        }
        function startG6Skeletal(c) {
            const ctx = c.getContext('2d'); let t = 0; let active = true; c._simActiveSetter = (s) => { active = s; if (s) loop(); };
            function loop() {
                if (!active) return; const w = c.width = c.clientWidth; const h = c.height = c.clientHeight;
                ctx.fillStyle = '#0f172a'; ctx.fillRect(0, 0, w, h);
                // Arm
                const angle = Math.sin(t * 0.1) * 0.5;
                const cx = w / 2; const cy = h / 2;
                ctx.strokeStyle = 'white'; ctx.lineWidth = 4; ctx.lineCap = 'round';
                ctx.beginPath(); ctx.moveTo(cx - 20, cy); ctx.lineTo(cx, cy); ctx.lineTo(cx + 20 * Math.cos(angle), cy + 20 * Math.sin(angle)); ctx.stroke();
                // Joints
                ctx.fillStyle = 'cyan'; ctx.beginPath(); ctx.arc(cx, cy, 3, 0, Math.PI * 2); ctx.fill();
                t++; requestAnimationFrame(loop);
            } loop();
        }
        function startG6Arch(c) {
            const ctx = c.getContext('2d'); let t = 0; let active = true; c._simActiveSetter = (s) => { active = s; if (s) loop(); };
            function loop() {
                if (!active) return; const w = c.width = c.clientWidth; const h = c.height = c.clientHeight;
                // Layers
                ctx.fillStyle = '#4ade80'; ctx.fillRect(0, 0, w, h / 3);
                ctx.fillStyle = '#854d0e'; ctx.fillRect(0, h / 3, w, h / 3);
                ctx.fillStyle = '#57534e'; ctx.fillRect(0, 2 * h / 3, w, h / 3);
                // Bones
                ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(w / 2, 2 * h / 3 + 10, 5, 0, Math.PI * 2); ctx.fill();
                t++; requestAnimationFrame(loop);
            } loop();
        }
        function startG6Cipher(c) {
            const ctx = c.getContext('2d'); let t = 0; let active = true; c._simActiveSetter = (s) => { active = s; if (s) loop(); };
            function loop() {
                if (!active) return; const w = c.width = c.clientWidth; const h = c.height = c.clientHeight;
                ctx.fillStyle = '#111827'; ctx.fillRect(0, 0, w, h);
                const r = 20;
                ctx.strokeStyle = '#10b981'; ctx.lineWidth = 2;
                ctx.beginPath(); ctx.arc(w / 2, h / 2, r, 0, Math.PI * 2); ctx.stroke();
                // Spin tick
                const ang = t * 0.1;
                ctx.beginPath(); ctx.moveTo(w / 2, h / 2); ctx.lineTo(w / 2 + Math.cos(ang) * r, h / 2 + Math.sin(ang) * r); ctx.stroke();
                t++; requestAnimationFrame(loop);
            } loop();
        }

        // --- GRADE 7 MICRO SIMS ---
        function startG7Ph(c) {
            const ctx = c.getContext('2d'); let t = 0; let active = true; c._simActiveSetter = (s) => { active = s; if (s) loop(); };
            function loop() {
                if (!active) return; const w = c.width = c.clientWidth; const h = c.height = c.clientHeight;
                ctx.fillStyle = '#111'; ctx.fillRect(0, 0, w, h);
                // Beaker
                ctx.fillStyle = `hsl(${t % 360}, 70%, 50%)`;
                ctx.fillRect(w / 2 - 15, h / 2, 30, 20);
                // Dropper
                ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(w / 2, h / 2 - 20, 3, 0, Math.PI * 2); ctx.fill();
                t += 2; requestAnimationFrame(loop);
            } loop();
        }
        function startG7Transversal(c) {
            const ctx = c.getContext('2d'); let t = 0; let active = true; c._simActiveSetter = (s) => { active = s; if (s) loop(); };
            function loop() {
                if (!active) return; const w = c.width = c.clientWidth; const h = c.height = c.clientHeight;
                ctx.fillStyle = '#0c0a09'; ctx.fillRect(0, 0, w, h);
                // Lines
                ctx.strokeStyle = 'cyan'; ctx.beginPath(); ctx.moveTo(0, h * 0.3); ctx.lineTo(w, h * 0.3); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(0, h * 0.7); ctx.lineTo(w, h * 0.7); ctx.stroke();
                // Transversal
                const ang = t * 0.02;
                const cx = w / 2; const cy = h / 2;
                ctx.strokeStyle = 'magenta'; ctx.beginPath();
                ctx.moveTo(cx + Math.cos(ang) * 50, cy + Math.sin(ang) * 50);
                ctx.lineTo(cx - Math.cos(ang) * 50, cy - Math.sin(ang) * 50); ctx.stroke();
                t++; requestAnimationFrame(loop);
            } loop();
        }
        function startG7Gas(c) {
            const ctx = c.getContext('2d'); let t = 0; let active = true; c._simActiveSetter = (s) => { active = s; if (s) loop(); };
            function loop() {
                if (!active) return; const w = c.width = c.clientWidth; const h = c.height = c.clientHeight;
                ctx.fillStyle = '#1e1b4b'; ctx.fillRect(0, 0, w, h);
                const r = 10 + Math.sin(t * 0.1) * 5;
                ctx.fillStyle = '#fce7f3'; ctx.beginPath(); ctx.arc(w / 2, h / 2, r, 0, Math.PI * 2); ctx.fill();
                // Particles
                ctx.fillStyle = '#60a5fa'; ctx.beginPath(); ctx.arc(w / 2 + 10, h / 2, 2, 0, Math.PI * 2); ctx.fill();
                t++; requestAnimationFrame(loop);
            } loop();
        }
        function startG7Greenhouse(c) {
            const ctx = c.getContext('2d'); let t = 0; let active = true; c._simActiveSetter = (s) => { active = s; if (s) loop(); };
            function loop() {
                if (!active) return; const w = c.width = c.clientWidth; const h = c.height = c.clientHeight;
                ctx.fillStyle = '#000'; ctx.fillRect(0, 0, w, h);
                // Earth
                ctx.fillStyle = '#10b981'; ctx.fillRect(0, h - 10, w, 10);
                // Atmosphere
                ctx.fillStyle = 'rgba(100,200,255,0.2)'; ctx.fillRect(0, h - 30, w, 20);
                // Ray
                const x = (t * 2) % w;
                ctx.strokeStyle = 'yellow'; ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, h - 10); ctx.stroke();
                t++; requestAnimationFrame(loop);
            } loop();
        }
        function startG7Logic(c) {
            const ctx = c.getContext('2d'); let t = 0; let active = true; c._simActiveSetter = (s) => { active = s; if (s) loop(); };
            function loop() {
                if (!active) return; const w = c.width = c.clientWidth; const h = c.height = c.clientHeight;
                ctx.fillStyle = '#111827'; ctx.fillRect(0, 0, w, h);
                // Gate
                ctx.strokeStyle = '#10b981'; ctx.strokeRect(w / 2 - 15, h / 2 - 10, 30, 20);
                // Pulse
                if (Math.floor(t / 20) % 2 === 0) {
                    ctx.fillStyle = '#10b981'; ctx.shadowBlur = 5; ctx.shadowColor = '#10b981';
                    ctx.fillRect(w / 2 - 10, h / 2 - 5, 20, 10);
                }
                ctx.shadowBlur = 0;
                t++; requestAnimationFrame(loop);
            } loop();
        }

        // --- GRADE 8 MICRO SIMS ---
        function startG8Sound(c) {
            const ctx = c.getContext('2d'); let t = 0; let active = true; c._simActiveSetter = (s) => { active = s; if (s) loop(); };
            function loop() {
                if (!active) return; const w = c.width = c.clientWidth; const h = c.height = c.clientHeight;
                ctx.fillStyle = '#111'; ctx.fillRect(0, 0, w, h);
                // Speaker
                const r = 10 + Math.sin(t * 0.2) * 5;
                ctx.fillStyle = '#a855f7'; ctx.beginPath(); ctx.arc(w * 0.2, h / 2, r, 0, Math.PI * 2); ctx.fill();
                // Waves
                ctx.strokeStyle = '#a855f7'; ctx.lineWidth = 2;
                for (let i = 0; i < 3; i++) {
                    let rw = (t * 2 + i * 20) % 50;
                    ctx.beginPath(); ctx.arc(w * 0.2, h / 2, 10 + rw, -0.5, 0.5); ctx.stroke();
                }
                t++; requestAnimationFrame(loop);
            } loop();
        }
        function startG8Flight(c) {
            const ctx = c.getContext('2d'); let t = 0; let active = true; c._simActiveSetter = (s) => { active = s; if (s) loop(); };
            function loop() {
                if (!active) return; const w = c.width = c.clientWidth; const h = c.height = c.clientHeight;
                ctx.fillStyle = '#100020'; ctx.fillRect(0, 0, w, h);
                // Grid
                ctx.strokeStyle = '#f0f'; ctx.beginPath(); ctx.moveTo(0, h * 0.8); ctx.lineTo(w, h * 0.8); ctx.stroke();
                // Plane
                const y = h / 2 + Math.sin(t * 0.1) * 10;
                ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.moveTo(w / 2 + 10, y); ctx.lineTo(w / 2 - 5, y + 5); ctx.lineTo(w / 2 - 5, y - 5); ctx.fill();
                t++; requestAnimationFrame(loop);
            } loop();
        }
        function startG8Cell(c) {
            const ctx = c.getContext('2d'); let t = 0; let active = true; c._simActiveSetter = (s) => { active = s; if (s) loop(); };
            function loop() {
                if (!active) return; const w = c.width = c.clientWidth; const h = c.height = c.clientHeight;
                ctx.fillStyle = '#0f172a'; ctx.fillRect(0, 0, w, h);
                // Cell
                ctx.strokeStyle = '#3b82f6'; ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(w / 2, h / 2, 20, 0, Math.PI * 2); ctx.stroke();
                // Organelles
                ctx.fillStyle = '#ef4444'; ctx.beginPath(); ctx.arc(w / 2 - 10, h / 2 - 5, 5, 0, Math.PI * 2); ctx.fill();
                ctx.fillStyle = '#3b82f6'; ctx.beginPath(); ctx.arc(w / 2 + 10, h / 2 + 5, 4, 0, Math.PI * 2); ctx.fill();
                t++; requestAnimationFrame(loop);
            } loop();
        }
        function startG8Steam(c) {
            const ctx = c.getContext('2d'); let t = 0; let active = true; c._simActiveSetter = (s) => { active = s; if (s) loop(); };
            function loop() {
                if (!active) return; const w = c.width = c.clientWidth; const h = c.height = c.clientHeight;
                ctx.fillStyle = '#1a1510'; ctx.fillRect(0, 0, w, h);
                // Wheel
                ctx.strokeStyle = '#daa520'; ctx.lineWidth = 3;
                ctx.beginPath(); ctx.arc(w * 0.7, h / 2, 15, 0, Math.PI * 2); ctx.stroke();
                // Piston
                const py = h / 2 + Math.sin(t * 0.1) * 10;
                ctx.fillStyle = '#888'; ctx.fillRect(w * 0.3, py, 10, 20);
                t += 2; requestAnimationFrame(loop);
            } loop();
        }
        function startG8Internet(c) {
            const ctx = c.getContext('2d'); let t = 0; let active = true; c._simActiveSetter = (s) => { active = s; if (s) loop(); };
            function loop() {
                if (!active) return; const w = c.width = c.clientWidth; const h = c.height = c.clientHeight;
                ctx.fillStyle = '#000'; ctx.fillRect(0, 0, w, h);
                // Nodes
                ctx.fillStyle = '#333';
                ctx.beginPath(); ctx.arc(w * 0.2, h / 2, 4, 0, Math.PI * 2); ctx.fill();
                ctx.beginPath(); ctx.arc(w * 0.8, h / 2, 4, 0, Math.PI * 2); ctx.fill();
                ctx.beginPath(); ctx.arc(w * 0.5, h * 0.3, 4, 0, Math.PI * 2); ctx.fill();
                // Packet
                const p = (t % 100) / 100;
                const px = w * 0.2 + (w * 0.8 - w * 0.2) * p;
                ctx.fillStyle = '#0f0'; ctx.fillRect(px, h / 2 - 2, 4, 4);
                t++; requestAnimationFrame(loop);
            } loop();
        }

        // --- GRADE 9 MICRO SIMS ---
        function startG9Physics(c) {
            const ctx = c.getContext('2d'); let t = 0; let active = true; c._simActiveSetter = (s) => { active = s; if (s) loop(); };
            function loop() {
                if (!active) return; const w = c.width = c.clientWidth; const h = c.height = c.clientHeight;
                ctx.fillStyle = '#050510'; ctx.fillRect(0, 0, w, h);
                // Grid
                ctx.strokeStyle = '#0ff'; ctx.lineWidth = 1; ctx.beginPath(); ctx.moveTo(0, h - 10); ctx.lineTo(w, h - 10); ctx.stroke();
                // Arc
                const p = (t % 100) / 100;
                const ay = h - 10 - Math.sin(p * Math.PI) * 40;
                const ax = p * w;
                ctx.fillStyle = '#f0f'; ctx.beginPath(); ctx.arc(ax, ay, 3, 0, Math.PI * 2); ctx.fill();
                t++; requestAnimationFrame(loop);
            } loop();
        }
        function startG9Trig(c) {
            const ctx = c.getContext('2d'); let t = 0; let active = true; c._simActiveSetter = (s) => { active = s; if (s) loop(); };
            function loop() {
                if (!active) return; const w = c.width = c.clientWidth; const h = c.height = c.clientHeight;
                ctx.fillStyle = '#000'; ctx.fillRect(0, 0, w, h);
                // Circle
                ctx.strokeStyle = '#444'; ctx.beginPath(); ctx.arc(w / 2, h / 2, 20, 0, Math.PI * 2); ctx.stroke();
                // Point
                const ang = t * 0.05;
                const px = w / 2 + Math.cos(ang) * 20; const py = h / 2 + Math.sin(ang) * 20;
                ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(px, py, 2, 0, Math.PI * 2); ctx.fill();
                // Line
                ctx.strokeStyle = '#f0f'; ctx.beginPath(); ctx.moveTo(w / 2, h / 2); ctx.lineTo(px, py); ctx.stroke();
                t++; requestAnimationFrame(loop);
            } loop();
        }
        function startG9DNA(c) {
            const ctx = c.getContext('2d'); let t = 0; let active = true; c._simActiveSetter = (s) => { active = s; if (s) loop(); };
            function loop() {
                if (!active) return; const w = c.width = c.clientWidth; const h = c.height = c.clientHeight;
                ctx.fillStyle = '#000'; ctx.fillRect(0, 0, w, h);
                // Helix
                for (let i = 0; i < 10; i++) {
                    const y = (t + i * 10) % h;
                    const x = w / 2 + Math.sin(y * 0.1) * 10;
                    ctx.fillStyle = i % 2 === 0 ? '#f00' : '#00f';
                    ctx.beginPath(); ctx.arc(x, y, 3, 0, Math.PI * 2); ctx.fill();
                    ctx.beginPath(); ctx.arc(w - x, y, 3, 0, Math.PI * 2); ctx.fill();
                }
                t++; requestAnimationFrame(loop);
            } loop();
        }
        function startG9Market(c) {
            const ctx = c.getContext('2d'); let t = 0; let active = true; c._simActiveSetter = (s) => { active = s; if (s) loop(); };
            function loop() {
                if (!active) return; const w = c.width = c.clientWidth; const h = c.height = c.clientHeight;
                ctx.fillStyle = '#0f172a'; ctx.fillRect(0, 0, w, h);
                // X
                ctx.strokeStyle = '#ef4444'; ctx.beginPath(); ctx.moveTo(10, h - 10); ctx.lineTo(w - 10, 10); ctx.stroke();
                ctx.strokeStyle = '#3b82f6'; ctx.beginPath(); ctx.moveTo(10, 10); ctx.lineTo(w - 10, h - 10); ctx.stroke();
                // Dot
                const eqX = w / 2 + Math.sin(t * 0.05) * 5;
                const eqY = h / 2 + Math.cos(t * 0.05) * 5;
                ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(eqX, eqY, 3, 0, Math.PI * 2); ctx.fill();
                t++; requestAnimationFrame(loop);
            } loop();
        }
        function startG9Interest(c) {
            const ctx = c.getContext('2d'); let t = 0; let active = true; c._simActiveSetter = (s) => { active = s; if (s) loop(); };
            function loop() {
                if (!active) return; const w = c.width = c.clientWidth; const h = c.height = c.clientHeight;
                ctx.fillStyle = '#fff'; ctx.fillRect(0, 0, w, h);
                // Tree
                ctx.strokeStyle = '#10b981'; ctx.beginPath(); ctx.moveTo(w / 2, h); ctx.lineTo(w / 2, h - 20);
                const s = Math.abs(Math.sin(t * 0.05)) * 20;
                ctx.lineTo(w / 2 - s, h - 40); ctx.moveTo(w / 2, h - 20); ctx.lineTo(w / 2 + s, h - 40);
                ctx.stroke();
                t++; requestAnimationFrame(loop);
            } loop();
        }

        // --- GRADE 10 MICRO SIMS ---
        function startG10Motor(c) {
            const ctx = c.getContext('2d'); let t = 0; let active = true; c._simActiveSetter = (s) => { active = s; if (s) loop(); };
            function loop() {
                if (!active) return; const w = c.width = c.clientWidth; const h = c.height = c.clientHeight;
                ctx.fillStyle = '#050505'; ctx.fillRect(0, 0, w, h);
                // Coil
                const ang = t * 0.1;
                const cw = 20 * Math.cos(ang);
                ctx.fillStyle = '#b87333'; ctx.fillRect(w / 2 - cw / 2, h / 2 - 10, cw, 20);
                // Magnets
                ctx.fillStyle = '#ef4444'; ctx.fillRect(10, h / 2 - 15, 10, 30);
                ctx.fillStyle = '#3b82f6'; ctx.fillRect(w - 20, h / 2 - 15, 10, 30);
                t++; requestAnimationFrame(loop);
            } loop();
        }
        function startG10Parabola(c) {
            const ctx = c.getContext('2d'); let t = 0; let active = true; c._simActiveSetter = (s) => { active = s; if (s) loop(); };
            function loop() {
                if (!active) return; const w = c.width = c.clientWidth; const h = c.height = c.clientHeight;
                ctx.fillStyle = '#000'; ctx.fillRect(0, 0, w, h);
                // Curve
                ctx.strokeStyle = '#60a5fa'; ctx.beginPath();
                for (let x = 0; x <= w; x += 2) {
                    let y = h - 5 - 0.01 * Math.pow(x - w / 2, 2);
                    if (x === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
                }
                ctx.stroke();
                // Ray
                const rx = (t % w);
                ctx.fillStyle = '#fff'; ctx.fillRect(rx, 0, 2, h);
                t += 2; requestAnimationFrame(loop);
            } loop();
        }
        function startG10Heredity(c) {
            const ctx = c.getContext('2d'); let t = 0; let active = true; c._simActiveSetter = (s) => { active = s; if (s) loop(); };
            function loop() {
                if (!active) return; const w = c.width = c.clientWidth; const h = c.height = c.clientHeight;
                ctx.fillStyle = '#fff'; ctx.fillRect(0, 0, w, h);
                // Flower
                const s = Math.sin(t * 0.05) * 5;
                ctx.fillStyle = '#ef4444'; ctx.beginPath(); ctx.arc(w / 2, h / 2 - 10 + s, 8, 0, Math.PI * 2); ctx.fill();
                ctx.strokeStyle = 'green'; ctx.beginPath(); ctx.moveTo(w / 2, h); ctx.lineTo(w / 2, h / 2 + s); ctx.stroke();
                t++; requestAnimationFrame(loop);
            } loop();
        }
        function startG10Pop(c) {
            const ctx = c.getContext('2d'); let t = 0; let active = true; c._simActiveSetter = (s) => { active = s; if (s) loop(); };
            function loop() {
                if (!active) return; const w = c.width = c.clientWidth; const h = c.height = c.clientHeight;
                ctx.fillStyle = '#fff'; ctx.fillRect(0, 0, w, h);
                // Pyramid
                for (let i = 0; i < 10; i++) {
                    const wid = (10 - i) * 3;
                    ctx.fillStyle = '#3b82f6'; ctx.fillRect(w / 2 - wid, h - i * 4, wid, 3);
                    ctx.fillStyle = '#ec4899'; ctx.fillRect(w / 2, h - i * 4, wid, 3);
                }
                t++; requestAnimationFrame(loop);
            } loop();
        }
        function startG10Crypto(c) {
            const ctx = c.getContext('2d'); let t = 0; let active = true; c._simActiveSetter = (s) => { active = s; if (s) loop(); };
            function loop() {
                if (!active) return; const w = c.width = c.clientWidth; const h = c.height = c.clientHeight;
                ctx.fillStyle = '#111'; ctx.fillRect(0, 0, w, h);
                // Beakers
                ctx.fillStyle = '#f00'; ctx.fillRect(10, h / 2, 10, 10);
                ctx.fillStyle = '#00f'; ctx.fillRect(w - 20, h / 2, 10, 10);
                // Mix
                const p = (t % 100) / 100;
                ctx.fillStyle = '#ff0'; ctx.fillRect(10 + p * (w - 30), h / 2, 5, 5);
                t++; requestAnimationFrame(loop);
            } loop();
        }

        // --- GRADE 10 MICRO SIMS ---
        function startG10Motor(c) {
            const ctx = c.getContext('2d'); let t = 0; let active = true; c._simActiveSetter = (s) => { active = s; if (s) loop(); };
            function loop() {
                if (!active) return; const w = c.width = c.clientWidth; const h = c.height = c.clientHeight;
                ctx.fillStyle = '#050505'; ctx.fillRect(0, 0, w, h);
                // Coil
                const ang = t * 0.1;
                const cw = 20 * Math.cos(ang);
                ctx.fillStyle = '#b87333'; ctx.fillRect(w / 2 - cw / 2, h / 2 - 10, cw, 20);
                // Magnets
                ctx.fillStyle = '#ef4444'; ctx.fillRect(10, h / 2 - 15, 10, 30);
                ctx.fillStyle = '#3b82f6'; ctx.fillRect(w - 20, h / 2 - 15, 10, 30);
                t++; requestAnimationFrame(loop);
            } loop();
        }
        function startG10Parabola(c) {
            const ctx = c.getContext('2d'); let t = 0; let active = true; c._simActiveSetter = (s) => { active = s; if (s) loop(); };
            function loop() {
                if (!active) return; const w = c.width = c.clientWidth; const h = c.height = c.clientHeight;
                ctx.fillStyle = '#000'; ctx.fillRect(0, 0, w, h);
                // Curve
                ctx.strokeStyle = '#60a5fa'; ctx.beginPath();
                for (let x = 0; x <= w; x += 2) {
                    let y = h - 5 - 0.01 * Math.pow(x - w / 2, 2);
                    if (x === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
                }
                ctx.stroke();
                // Ray
                const rx = (t % w);
                ctx.fillStyle = '#fff'; ctx.fillRect(rx, 0, 2, h);
                t += 2; requestAnimationFrame(loop);
            } loop();
        }
        function startG10Heredity(c) {
            const ctx = c.getContext('2d'); let t = 0; let active = true; c._simActiveSetter = (s) => { active = s; if (s) loop(); };
            function loop() {
                if (!active) return; const w = c.width = c.clientWidth; const h = c.height = c.clientHeight;
                ctx.fillStyle = '#fff'; ctx.fillRect(0, 0, w, h);
                // Flower
                const s = Math.sin(t * 0.05) * 5;
                ctx.fillStyle = '#ef4444'; ctx.beginPath(); ctx.arc(w / 2, h / 2 - 10 + s, 8, 0, Math.PI * 2); ctx.fill();
                ctx.strokeStyle = 'green'; ctx.beginPath(); ctx.moveTo(w / 2, h); ctx.lineTo(w / 2, h / 2 + s); ctx.stroke();
                t++; requestAnimationFrame(loop);
            } loop();
        }
        function startG10Pop(c) {
            const ctx = c.getContext('2d'); let t = 0; let active = true; c._simActiveSetter = (s) => { active = s; if (s) loop(); };
            function loop() {
                if (!active) return; const w = c.width = c.clientWidth; const h = c.height = c.clientHeight;
                ctx.fillStyle = '#fff'; ctx.fillRect(0, 0, w, h);
                // Pyramid
                for (let i = 0; i < 10; i++) {
                    const wid = (10 - i) * 3;
                    ctx.fillStyle = '#3b82f6'; ctx.fillRect(w / 2 - wid, h - i * 4, wid, 3);
                    ctx.fillStyle = '#ec4899'; ctx.fillRect(w / 2, h - i * 4, wid, 3);
                }
                t++; requestAnimationFrame(loop);
            } loop();
        }
        function startG10Crypto(c) {
            const ctx = c.getContext('2d'); let t = 0; let active = true; c._simActiveSetter = (s) => { active = s; if (s) loop(); };
            function loop() {
                if (!active) return; const w = c.width = c.clientWidth; const h = c.height = c.clientHeight;
                ctx.fillStyle = '#111'; ctx.fillRect(0, 0, w, h);
                // Beakers
                ctx.fillStyle = '#f00'; ctx.fillRect(10, h / 2, 10, 10);
                ctx.fillStyle = '#00f'; ctx.fillRect(w - 20, h / 2, 10, 10);
                // Mix
                const p = (t % 100) / 100;
                ctx.fillStyle = '#ff0'; ctx.fillRect(10 + p * (w - 30), h / 2, 5, 5);
                t++; requestAnimationFrame(loop);
            } loop();
        }

        // --- GRADE 11 MICRO SIMS ---
        function startG11Vectors(c) {
            const ctx = c.getContext('2d'); let t = 0; let active = true; c._simActiveSetter = (s) => { active = s; if (s) loop(); };
            function loop() {
                if (!active) return; const w = c.width = c.clientWidth; const h = c.height = c.clientHeight;
                ctx.fillStyle = '#0f172a'; ctx.fillRect(0, 0, w, h);
                // River
                ctx.strokeStyle = 'rgba(0,255,255,0.2)'; ctx.beginPath();
                for (let y = 10; y < h; y += 10) { ctx.moveTo(0, y); ctx.lineTo(w, y); }
                ctx.stroke();
                // Boat Vector
                const bx = w / 2; const by = h / 2;
                ctx.strokeStyle = '#0f0'; ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(bx, by); ctx.lineTo(bx + 10, by - 20); ctx.stroke();
                // Current
                ctx.strokeStyle = '#0ff'; ctx.beginPath(); ctx.moveTo(bx + 10, by - 20); ctx.lineTo(bx + 30, by - 20); ctx.stroke();
                // Result
                ctx.strokeStyle = '#f00'; ctx.beginPath(); ctx.moveTo(bx, by); ctx.lineTo(bx + 30, by - 20); ctx.stroke();
                t++; requestAnimationFrame(loop);
            } loop();
        }
        function startG11Complex(c) {
            const ctx = c.getContext('2d'); let t = 0; let active = true; c._simActiveSetter = (s) => { active = s; if (s) loop(); };
            function loop() {
                if (!active) return; const w = c.width = c.clientWidth; const h = c.height = c.clientHeight;
                ctx.fillStyle = '#000'; ctx.fillRect(0, 0, w, h);
                // Grid
                ctx.strokeStyle = '#333'; ctx.beginPath(); ctx.arc(w / 2, h / 2, 20, 0, Math.PI * 2); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(w / 2, 0); ctx.lineTo(w / 2, h); ctx.moveTo(0, h / 2); ctx.lineTo(w, h / 2); ctx.stroke();
                // Rotating Vector
                const ang = t * 0.05;
                ctx.strokeStyle = '#a5b4fc'; ctx.beginPath(); ctx.moveTo(w / 2, h / 2);
                ctx.lineTo(w / 2 + Math.cos(ang) * 20, h / 2 + Math.sin(ang) * 20); ctx.stroke();
                t++; requestAnimationFrame(loop);
            } loop();
        }
        function startG11VSEPR(c) {
            const ctx = c.getContext('2d'); let t = 0; let active = true; c._simActiveSetter = (s) => { active = s; if (s) loop(); };
            function loop() {
                if (!active) return; const w = c.width = c.clientWidth; const h = c.height = c.clientHeight;
                ctx.fillStyle = '#000'; ctx.fillRect(0, 0, w, h);
                // Rotate Molecule
                const ang = t * 0.05;
                const cx = w / 2; const cy = h / 2;
                // Center
                ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(cx, cy, 5, 0, Math.PI * 2); ctx.fill();
                // Bonds
                for (let i = 0; i < 3; i++) {
                    const a = ang + (i * Math.PI * 2 / 3);
                    const bx = cx + Math.cos(a) * 20;
                    const by = cy + Math.sin(a) * 10; // flatten y for 3d look
                    ctx.strokeStyle = '#fff'; ctx.beginPath(); ctx.moveTo(cx, cy); ctx.lineTo(bx, by); ctx.stroke();
                    ctx.fillStyle = '#3b82f6'; ctx.beginPath(); ctx.arc(bx, by, 3, 0, Math.PI * 2); ctx.fill();
                }
                t++; requestAnimationFrame(loop);
            } loop();
        }
        function startG11Neuron(c) {
            const ctx = c.getContext('2d'); let t = 0; let active = true; c._simActiveSetter = (s) => { active = s; if (s) loop(); };
            function loop() {
                if (!active) return; const w = c.width = c.clientWidth; const h = c.height = c.clientHeight;
                ctx.fillStyle = '#000'; ctx.fillRect(0, 0, w, h);
                // Spike Graph
                ctx.strokeStyle = '#22c55e'; ctx.beginPath();
                const peak = (t % 100);
                let y = h - 10;
                if (peak > 40 && peak < 60) y = 10; // Spike
                ctx.moveTo(0, h - 10);
                if (peak > 40 && peak < 60) {
                    ctx.lineTo(w / 2, 10); ctx.lineTo(w, h - 10);
                } else {
                    ctx.lineTo(w, h - 10);
                }
                ctx.stroke();
                t++; requestAnimationFrame(loop);
            } loop();
        }
        function startG11Recursion(c) {
            const ctx = c.getContext('2d'); let t = 0; let active = true; c._simActiveSetter = (s) => { active = s; if (s) loop(); };
            function loop() {
                if (!active) return; const w = c.width = c.clientWidth; const h = c.height = c.clientHeight;
                ctx.fillStyle = '#0f172a'; ctx.fillRect(0, 0, w, h);
                // Stack
                const count = Math.floor((t % 200) / 40); // 0 to 4 blocks
                for (let i = 0; i < count; i++) {
                    ctx.fillStyle = '#3b82f6';
                    ctx.fillRect(w / 2 - 15, h - (i + 1) * 12, 30, 10);
                }
                t++; requestAnimationFrame(loop);
            } loop();
        }

        // --- GRADE 12 MICRO SIMS ---
        function startG12Generator(c) {
            const ctx = c.getContext('2d'); let t = 0; let active = true; c._simActiveSetter = (s) => { active = s; if (s) loop(); };
            function loop() {
                if (!active) return; const w = c.width = c.clientWidth; const h = c.height = c.clientHeight;
                ctx.fillStyle = '#050505'; ctx.fillRect(0, 0, w, h);
                // Coil Rotation
                const cx = w / 2, cy = h / 2;
                const ang = t * 0.1;
                // Magnet Sides
                ctx.fillStyle = '#991b1b'; ctx.fillRect(0, cy - 15, 20, 30);
                ctx.fillStyle = '#1e3a8a'; ctx.fillRect(w - 20, cy - 15, 20, 30);
                // Rotating Loop (Flattened Rect)
                ctx.save(); ctx.translate(cx, cy); ctx.scale(Math.cos(ang), 1);
                ctx.strokeStyle = '#b87333'; ctx.lineWidth = 3; ctx.strokeRect(-15, -15, 30, 30);
                ctx.restore();
                t++; requestAnimationFrame(loop);
            } loop();
        }
        function startG12Integral(c) {
            const ctx = c.getContext('2d'); let t = 0; let active = true; c._simActiveSetter = (s) => { active = s; if (s) loop(); };
            function loop() {
                if (!active) return; const w = c.width = c.clientWidth; const h = c.height = c.clientHeight;
                ctx.fillStyle = '#000'; ctx.fillRect(0, 0, w, h);
                // Curve
                ctx.strokeStyle = '#ef4444'; ctx.beginPath();
                for (let x = 0; x < w; x += 2) {
                    const y = h - (Math.sin(x * 0.05 + t * 0.05) * 10 + 20);
                    if (x === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
                }
                ctx.stroke();
                // Rects
                ctx.fillStyle = 'rgba(239, 68, 68, 0.3)';
                for (let x = 0; x < w; x += 5) {
                    const y = h - (Math.sin(x * 0.05 + t * 0.05) * 10 + 20);
                    ctx.fillRect(x, y, 4, h - y);
                }
                t++; requestAnimationFrame(loop);
            } loop();
        }
        function startG12Translation(c) {
            const ctx = c.getContext('2d'); let t = 0; let active = true; c._simActiveSetter = (s) => { active = s; if (s) loop(); };
            function loop() {
                if (!active) return; const w = c.width = c.clientWidth; const h = c.height = c.clientHeight;
                ctx.fillStyle = '#0c0a15'; ctx.fillRect(0, 0, w, h);
                // Ribosome
                ctx.fillStyle = 'rgba(79, 70, 229, 0.5)'; ctx.beginPath(); ctx.ellipse(w / 2, h / 2, 20, 15, 0, 0, Math.PI * 2); ctx.fill();
                // Chain growing
                ctx.strokeStyle = '#fff'; ctx.beginPath(); ctx.moveTo(w / 2, h / 2 - 10);
                ctx.lineTo(w / 2 + Math.sin(t * 0.1) * 10, h / 2 - 30); ctx.stroke();
                ctx.fillStyle = '#22c55e'; ctx.beginPath(); ctx.arc(w / 2 + Math.sin(t * 0.1) * 10, h / 2 - 30, 3, 0, Math.PI * 2); ctx.fill();
                t++; requestAnimationFrame(loop);
            } loop();
        }
        function startG12Equilibrium(c) {
            const ctx = c.getContext('2d'); let t = 0; let active = true; c._simActiveSetter = (s) => { active = s; if (s) loop(); };
            function loop() {
                if (!active) return; const w = c.width = c.clientWidth; const h = c.height = c.clientHeight;
                ctx.fillStyle = '#cbd5e1'; ctx.fillRect(0, 0, w, h);
                // Tank L, Tank R
                ctx.fillStyle = '#fff'; ctx.fillRect(5, 10, w / 2 - 10, h - 20); ctx.fillRect(w / 2 + 5, 10, w / 2 - 10, h - 20);
                // Particles
                const p1 = (Math.sin(t * 0.05) + 1) * 0.5; // 0 to 1
                // Left dots
                ctx.fillStyle = '#3b82f6';
                for (let i = 0; i < 10 * p1; i++) ctx.fillRect(10 + Math.random() * 20, 20 + Math.random() * 20, 2, 2);
                // Right dots
                ctx.fillStyle = '#22c55e';
                for (let i = 0; i < 10 * (1 - p1); i++) ctx.fillRect(w / 2 + 10 + Math.random() * 20, 20 + Math.random() * 20, 2, 2);
                t++; requestAnimationFrame(loop);
            } loop();
        }
        function startG12Pathfinding(c) {
            const ctx = c.getContext('2d'); let t = 0; let active = true; c._simActiveSetter = (s) => { active = s; if (s) loop(); };
            function loop() {
                if (!active) return; const w = c.width = c.clientWidth; const h = c.height = c.clientHeight;
                ctx.fillStyle = '#000'; ctx.fillRect(0, 0, w, h);
                // Grid
                const step = (t % 20);
                ctx.fillStyle = '#22c55e';
                ctx.fillRect(step * 2, step * 1.5, 4, 4);
                // Wall
                ctx.fillStyle = '#333'; ctx.fillRect(20, 20, 10, 10);
                t++; requestAnimationFrame(loop);
            } loop();
        }

        // --- DENTAL (Tooth cleaning/Sparkle) ---
        function startDentalSim(canvas, isFull) {
            const ctx = canvas.getContext('2d');
            let running = true;
            canvas._simActiveSetter = (isActive) => { running = isActive; if (isActive) loop(); };
            let t = 0;

            function loop() {
                if (!running || !canvas.isConnected) return;
                const w = canvas.width = canvas.clientWidth;
                const h = canvas.height = canvas.clientHeight;
                const cx = w / 2, cy = h / 2;

                ctx.fillStyle = '#eff6ff';
                ctx.fillRect(0, 0, w, h);

                // Tooth Shape (Molar)
                ctx.save();
                ctx.translate(cx, cy + (Math.sin(t) * 5));
                ctx.beginPath();
                const s = isFull ? 2 : 1;
                ctx.moveTo(-20 * s, -30 * s);
                ctx.quadraticCurveTo(0, -40 * s, 20 * s, -30 * s); // Top
                ctx.quadraticCurveTo(30 * s, -10 * s, 25 * s, 10 * s);
                ctx.quadraticCurveTo(25 * s, 30 * s, 15 * s, 40 * s); // Root R
                ctx.lineTo(5 * s, 20 * s);
                ctx.lineTo(-5 * s, 20 * s);
                ctx.lineTo(-15 * s, 40 * s); // Root L
                ctx.quadraticCurveTo(-25 * s, 30 * s, -25 * s, 10 * s);
                ctx.quadraticCurveTo(-30 * s, -10 * s, -20 * s, -30 * s);

                ctx.fillStyle = '#ffffff'; ctx.fill();
                ctx.strokeStyle = '#cbd5e1'; ctx.lineWidth = 2; ctx.stroke();
                ctx.restore();

                // Sparkles (Cleaning)
                const isHover = !isFull && canvas.matches(':hover');
                if (isHover || isFull) {
                    const sparkX = cx + Math.cos(t * 3) * 30;
                    const sparkY = cy + Math.sin(t * 2) * 30;
                    ctx.beginPath();
                    ctx.moveTo(sparkX, sparkY - 5); ctx.lineTo(sparkX, sparkY + 5);
                    ctx.moveTo(sparkX - 5, sparkY); ctx.lineTo(sparkX + 5, sparkY);
                    ctx.strokeStyle = '#F59E0B'; ctx.stroke();
                }

                t += 0.05;
                requestAnimationFrame(loop);
            }
            loop();
        }

        // --- LIVER (Hepatology - Chemical processing) ---
        function startLiverSim(canvas, isFull) {
            const ctx = canvas.getContext('2d');
            let running = true;
            canvas._simActiveSetter = (isActive) => { running = isActive; if (isActive) loop(); };
            let particles = [];

            function loop() {
                if (!running || !canvas.isConnected) return;
                const w = canvas.width = canvas.clientWidth;
                const h = canvas.height = canvas.clientHeight;
                ctx.fillStyle = '#fef2f2'; ctx.fillRect(0, 0, w, h);

                // Liver Shape (Abstract)
                const cx = w / 2, cy = h / 2;
                ctx.beginPath();
                ctx.ellipse(cx, cy, isFull ? 100 : 40, isFull ? 60 : 25, 0.2, 0, Math.PI * 2);
                ctx.fillStyle = '#fca5a5'; ctx.fill(); // Soft red

                // Particles (Toxins entering -> Clean exiting)
                if (Math.random() > 0.9) particles.push({ x: 0, y: cy + (Math.random() - 0.5) * 20, type: 'bad' });

                particles.forEach((p, i) => {
                    p.x += 2;
                    if (p.type === 'bad' && p.x > cx) p.type = 'good'; // Processed

                    ctx.beginPath(); ctx.arc(p.x, p.y, 3, 0, Math.PI * 2);
                    ctx.fillStyle = p.type === 'bad' ? '#ef4444' : '#10b981';
                    ctx.fill();

                    if (p.x > w) particles.splice(i, 1);
                });

                requestAnimationFrame(loop);
            }
            loop();
        }

        // --- SCIENCE (Atom) ---
        function startScienceSim(canvas, isFull) {
            const ctx = canvas.getContext('2d');
            let running = true;
            canvas._simActiveSetter = (isActive) => { running = isActive; if (isActive) loop(); };
            let t = 0;

            function loop() {
                if (!running || !canvas.isConnected) return;
                const w = canvas.width = canvas.clientWidth;
                const h = canvas.height = canvas.clientHeight;
                const cx = w / 2, cy = h / 2;

                ctx.fillStyle = '#f0fdfa'; ctx.fillRect(0, 0, w, h);

                // Nucleus
                ctx.beginPath(); ctx.arc(cx, cy, isFull ? 15 : 6, 0, Math.PI * 2);
                ctx.fillStyle = '#0f766e'; ctx.fill();

                // Electrons
                for (let i = 0; i < 3; i++) {
                    ctx.beginPath();
                    const rx = isFull ? 80 : 30;
                    const ry = isFull ? 30 : 10;
                    const rot = (i * Math.PI / 3);

                    ctx.save();
                    ctx.translate(cx, cy);
                    ctx.rotate(rot);
                    ctx.ellipse(0, 0, rx, ry, 0, 0, Math.PI * 2);
                    ctx.strokeStyle = 'rgba(15, 118, 110, 0.3)'; ctx.lineWidth = 1; ctx.stroke();

                    // Electron dot
                    const ex = Math.cos(t + i) * rx;
                    const ey = Math.sin(t + i) * ry;
                    ctx.beginPath(); ctx.arc(ex, ey, 3, 0, Math.PI * 2);
                    ctx.fillStyle = '#0d9488'; ctx.fill();

                    ctx.restore();
                }

                t += 0.1;
                requestAnimationFrame(loop);
            }
            loop();
        }

        // --- SOCIAL (Globe/History) ---
        function startSocialSim(canvas, isFull) {
            const ctx = canvas.getContext('2d');
            let running = true;
            canvas._simActiveSetter = (isActive) => { running = isActive; if (isActive) loop(); };
            let t = 0;

            function loop() {
                if (!running || !canvas.isConnected) return;
                const w = canvas.width = canvas.clientWidth;
                const h = canvas.height = canvas.clientHeight;
                const cx = w / 2, cy = h / 2;

                ctx.fillStyle = '#fff7ed'; ctx.fillRect(0, 0, w, h);

                // Globe
                const r = isFull ? 60 : 25;
                ctx.beginPath(); ctx.arc(cx, cy, r, 0, Math.PI * 2);
                ctx.fillStyle = '#bfdbfe'; ctx.fill();
                ctx.strokeStyle = '#60a5fa'; ctx.stroke();

                // Continents (moving lines)
                ctx.save();
                ctx.beginPath(); ctx.arc(cx, cy, r, 0, Math.PI * 2); ctx.clip();

                for (let i = 0; i < 3; i++) {
                    const offset = (t * 20 + i * 50) % (r * 4) - r * 2;
                    ctx.fillStyle = '#86efac';
                    ctx.beginPath();
                    ctx.arc(cx + offset, cy + Math.sin(i) * 10, r * 0.6, 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.restore();

                t += 0.02;
                requestAnimationFrame(loop);
            }
            loop();
        }

        // --- ROOT FOLDERS & GRADES ---

        function startEngFolderSim(canvas, isFull) {
            // Spinning Gears
            const ctx = canvas.getContext('2d');
            let running = true;
            canvas._simActiveSetter = (isActive) => { running = isActive; if (isActive) loop(); };
            let t = 0;

            function drawGear(x, y, teeth, radius, speed) {
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(t * speed);
                ctx.beginPath();
                for (let i = 0; i < teeth; i++) {
                    const angle = (Math.PI * 2 / teeth) * i;
                    const cx = Math.cos(angle) * radius;
                    const cy = Math.sin(angle) * radius;
                    const tx = Math.cos(angle) * (radius + 5);
                    const ty = Math.sin(angle) * (radius + 5);
                    if (i === 0) ctx.moveTo(cx, cy);
                    ctx.lineTo(cx, cy);
                    ctx.lineTo(tx, ty);
                }
                ctx.closePath();
                ctx.strokeStyle = '#3b82f6'; ctx.lineWidth = 2; ctx.stroke();
                ctx.beginPath(); ctx.arc(0, 0, radius * 0.5, 0, Math.PI * 2); ctx.stroke();
                ctx.restore();
            }

            function loop() {
                if (!running || !canvas.isConnected) return;
                const w = canvas.width = canvas.width = canvas.clientWidth;
                const h = canvas.height = canvas.clientHeight;
                ctx.fillStyle = '#eff6ff'; ctx.fillRect(0, 0, w, h);

                drawGear(w / 2 - 20, h / 2, 12, 20, 0.05);
                drawGear(w / 2 + 20, h / 2, 8, 15, -0.075);

                t++;
                requestAnimationFrame(loop);
            }
            loop();
        }

        function startMedFolderSim(canvas, isFull) {
            // DNA Helix
            const ctx = canvas.getContext('2d');
            let running = true;
            canvas._simActiveSetter = (isActive) => { running = isActive; if (isActive) loop(); };
            let t = 0;

            function loop() {
                if (!running || !canvas.isConnected) return;
                const w = canvas.width = canvas.clientWidth;
                const h = canvas.height = canvas.clientHeight;
                ctx.fillStyle = '#f0fdf4'; ctx.fillRect(0, 0, w, h);

                const count = 10;
                for (let i = 0; i < count; i++) {
                    const y = (h / count) * i + 10;
                    const phase = (i * 0.5) + t * 0.1;
                    const x1 = w / 2 + Math.sin(phase) * 20;
                    const x2 = w / 2 - Math.sin(phase) * 20;

                    ctx.beginPath(); ctx.moveTo(x1, y); ctx.lineTo(x2, y);
                    ctx.strokeStyle = '#86efac'; ctx.stroke();

                    ctx.beginPath(); ctx.arc(x1, y, 3, 0, Math.PI * 2); ctx.fillStyle = '#16a34a'; ctx.fill();
                    ctx.beginPath(); ctx.arc(x2, y, 3, 0, Math.PI * 2); ctx.fillStyle = '#16a34a'; ctx.fill();
                }
                t++;
                requestAnimationFrame(loop);
            }
            loop();
        }

        function startMathFolderSim(canvas, isFull) {
            // Floating Symbols
            const ctx = canvas.getContext('2d');
            let running = true;
            canvas._simActiveSetter = (isActive) => { running = isActive; if (isActive) loop(); };
            let t = 0;

            function loop() {
                if (!running || !canvas.isConnected) return;
                const w = canvas.width = canvas.clientWidth;
                const h = canvas.height = canvas.clientHeight;
                ctx.fillStyle = '#f5f3ff'; ctx.fillRect(0, 0, w, h);

                ctx.fillStyle = '#8b5cf6';
                ctx.font = '20px JetBrains Mono';

                const syms = ['', '', '', ''];
                syms.forEach((s, i) => {
                    const y = h / 2 + Math.sin(t * 0.1 + i) * 10;
                    const x = w / 2 - 40 + i * 25;
                    ctx.fillText(s, x, y);
                });

                t++;
                requestAnimationFrame(loop);
            }
            loop();
        }

        function startSchoolFolderSim(canvas, isFull) {
            // Stack of Books
            const ctx = canvas.getContext('2d');
            let running = true;
            canvas._simActiveSetter = (isActive) => { running = isActive; if (isActive) loop(); };
            let t = 0;

            function loop() {
                if (!running || !canvas.isConnected) return;
                const w = canvas.width = canvas.clientWidth;
                const h = canvas.height = canvas.clientHeight;
                const cx = w / 2, cy = h / 2;
                ctx.fillStyle = '#fff7ed'; ctx.fillRect(0, 0, w, h);

                // Books
                for (let i = 0; i < 3; i++) {
                    const lift = (i === 1) ? Math.sin(t * 0.1) * 5 : 0;
                    ctx.fillStyle = i % 2 == 0 ? '#f59e0b' : '#3b82f6';
                    ctx.fillRect(cx - 20, cy + i * 12 - 20 - lift, 40, 10);
                }
                t++;
                requestAnimationFrame(loop);
            }
            loop();
        }

        function startGradeSim(canvas, gradeNum, isFull) {
            // Floating Grade Badge
            const ctx = canvas.getContext('2d');
            let running = true;
            canvas._simActiveSetter = (isActive) => { running = isActive; if (isActive) loop(); };
            let t = 0;

            function loop() {
                if (!running || !canvas.isConnected) return;
                const w = canvas.width = canvas.clientWidth;
                const h = canvas.height = canvas.clientHeight;
                const cx = w / 2, cy = h / 2;
                ctx.fillStyle = '#fff7ed'; ctx.fillRect(0, 0, w, h);

                const yOff = Math.sin(t * 0.1) * 5;

                // Star/Badge
                ctx.beginPath();
                ctx.arc(cx, cy + yOff, 25, 0, Math.PI * 2);
                ctx.fillStyle = '#fbbf24'; ctx.fill();

                // Number
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 20px Plus Jakarta Sans';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(gradeNum, cx, cy + yOff);

                t++;
                requestAnimationFrame(loop);
            }
            loop();
        }

        // --- MATH SIMULATION ---
        function startMathSim(canvas, isFull) {
            const ctx = canvas.getContext('2d');
            let offset = 0;
            let running = true;
            canvas._simActiveSetter = (isActive) => { running = isActive; if (isActive) loop(); };

            // Particles for micro view
            const particles = Array.from({ length: 12 }, () => ({ x: Math.random() * 300, y: Math.random() * 100, s: Math.random() * 2 + 1 }));

            function loop() {
                if (!running || !canvas.isConnected) return;
                const w = canvas.width = canvas.clientWidth;
                const h = canvas.height = canvas.clientHeight;
                const midY = h / 2;

                ctx.fillStyle = isFull ? '#ffffff' : '#f8fafc';
                ctx.fillRect(0, 0, w, h);

                if (isFull) {
                    // Grid logic (same as before)
                    ctx.strokeStyle = '#f1f5f9'; ctx.lineWidth = 1;
                    for (let i = 0; i < w; i += 40) { ctx.beginPath(); ctx.moveTo(i, 0); ctx.lineTo(i, h); ctx.stroke(); }
                    for (let i = 0; i < h; i += 40) { ctx.beginPath(); ctx.moveTo(0, i); ctx.lineTo(w, i); ctx.stroke(); }
                }

                // Main Sine Curve
                ctx.beginPath();
                ctx.strokeStyle = '#3B82F6';
                ctx.lineWidth = isFull ? 3 : 3;
                ctx.lineJoin = 'round';
                for (let x = 0; x < w; x++) {
                    const y = midY + Math.sin((x + offset) * (isFull ? 0.02 : 0.03)) * (isFull ? 120 : 30);
                    ctx.lineTo(x, y);
                }
                ctx.stroke();

                // Dynamic Derivative (Dashed) - Show on Full or Hover
                if (isFull || canvas.matches(':hover')) {
                    ctx.beginPath();
                    ctx.strokeStyle = '#10B981';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([5, 5]);
                    for (let x = 0; x < w; x++) {
                        const y = midY + Math.cos((x + offset) * (isFull ? 0.02 : 0.03)) * (isFull ? 120 : 30);
                        ctx.lineTo(x, y);
                    }
                    ctx.stroke();
                    ctx.setLineDash([]);
                }

                // Micro: Trailing particles
                if (!isFull) {
                    ctx.fillStyle = '#93C5FD';
                    particles.forEach(p => {
                        p.x = (p.x + 0.8) % w;
                        const y = midY + Math.sin((p.x + offset) * 0.03) * 30;
                        ctx.beginPath(); ctx.arc(p.x, y, p.s, 0, Math.PI * 2); ctx.fill();
                    });
                }

                if (isFull) {
                    ctx.fillStyle = '#3B82F6'; ctx.font = 'bold 14px JetBrains Mono'; ctx.fillText('f(x) = sin(x)', 20, 30);
                }

                offset += isFull ? 2 : 1.5;
                requestAnimationFrame(loop);
            }
            loop();
        }

        // --- BIO SIMULATION ---
        function startBioSim(canvas, isFull) {
            const ctx = canvas.getContext('2d');
            let running = true;
            canvas._simActiveSetter = (isActive) => { running = isActive; if (isActive) loop(); };

            let cells = [{ x: canvas.clientWidth / 2, y: canvas.clientHeight / 2, r: isFull ? 50 : 20, state: 0 }];
            const bgParticles = Array.from({ length: 10 }, () => ({ x: Math.random() * 300, y: Math.random() * 150, r: Math.random() * 2, s: Math.random() * 0.5 }));

            function loop() {
                if (!running || !canvas.isConnected) return;
                const w = canvas.width = canvas.clientWidth;
                const h = canvas.height = canvas.clientHeight;

                ctx.fillStyle = isFull ? 'rgba(255,255,255,0.15)' : 'rgba(248,250,252,0.5)';
                ctx.fillRect(0, 0, w, h);

                // Organic Background Particles (Micro)
                if (!isFull) {
                    ctx.fillStyle = '#ecfccb';
                    bgParticles.forEach(p => {
                        p.y -= p.s; if (p.y < 0) p.y = h;
                        ctx.beginPath(); ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2); ctx.fill();
                    });
                }

                let nextCells = [];
                const splitSpeed = canvas.matches(':hover') ? 2 : 1;

                cells.forEach(c => {
                    // Cell Body
                    ctx.beginPath();
                    ctx.arc(c.x, c.y, c.r, 0, Math.PI * 2);
                    ctx.fillStyle = '#86efac'; // Light green
                    ctx.fill();

                    // Nucleus / Detail
                    ctx.beginPath();
                    ctx.arc(c.x - c.r * 0.2, c.y - c.r * 0.2, c.r * 0.4, 0, Math.PI * 2);
                    ctx.fillStyle = '#166534'; // Dark green
                    ctx.fill();

                    // Pulse/Wiggle
                    c.x += (Math.random() - 0.5) * 0.5;
                    c.y += (Math.random() - 0.5) * 0.5;

                    c.state += splitSpeed;
                    const splitThresh = isFull ? 100 : 150;

                    if (c.state > splitThresh && c.r > (isFull ? 12 : 8)) {
                        // Mitosis
                        nextCells.push({ x: c.x - c.r * 0.5, y: c.y, r: c.r * 0.75, state: 0 });
                        nextCells.push({ x: c.x + c.r * 0.5, y: c.y, r: c.r * 0.75, state: 0 });
                    } else {
                        nextCells.push(c);
                    }
                });

                cells = nextCells;
                const maxCells = isFull ? 80 : 12;
                if (cells.length > maxCells) cells = [{ x: w / 2, y: h / 2, r: isFull ? 50 : 20, state: 0 }];

                requestAnimationFrame(loop);
            }
            loop();
        }

        // --- CIVIL SIMULATION ---
        function startCivilSim(canvas, isFull) {
            const ctx = canvas.getContext('2d');
            let running = true;
            canvas._simActiveSetter = (isActive) => { running = isActive; if (isActive) loop(); };
            let t = 0;

            function loop() {
                if (!running || !canvas.isConnected) return;
                const w = canvas.width = canvas.clientWidth;
                const h = canvas.height = canvas.clientHeight;
                ctx.clearRect(0, 0, w, h);

                const yBase = h / 2 + (isFull ? 50 : 20);

                // Stress Heatmap on Hover
                const showHeatmap = !isFull && canvas.matches(':hover');

                if (isFull) {
                    ctx.fillStyle = '#64748b';
                    ctx.fillRect(80, yBase, 50, 180);
                    ctx.fillRect(w - 130, yBase, 50, 180);
                }

                // Moving Load
                const loadPos = (Math.sin(t * 0.05) * 0.5 + 0.5); // 0 to 1
                const sag = Math.sin(loadPos * Math.PI) * (isFull ? 40 : 15);
                const stress = sag * (isFull ? 5 : 15);

                // Bridge Deck
                ctx.beginPath();
                const pad = isFull ? 105 : 20;
                ctx.moveTo(pad, yBase);
                const midX = pad + (w - pad * 2) * loadPos;
                const midY = yBase + sag;

                ctx.quadraticCurveTo(midX, midY, w - pad, yBase);

                if (showHeatmap) {
                    const grad = ctx.createLinearGradient(pad, 0, w - pad, 0);
                    grad.addColorStop(0, '#10B981'); // Teal
                    grad.addColorStop(loadPos, '#EF4444'); // Red at load
                    grad.addColorStop(1, '#10B981');
                    ctx.strokeStyle = grad;
                } else {
                    ctx.strokeStyle = isFull
                        ? `rgb(${Math.min(255, stress + 100)}, ${Math.max(50, 100 - stress)}, 50)`
                        : '#94a3b8';
                }

                ctx.lineWidth = isFull ? 10 : 4;
                ctx.stroke();

                // Load Arrow (Micro)
                if (!isFull) {
                    ctx.fillStyle = '#F59E0B';
                    ctx.beginPath();
                    ctx.moveTo(midX, midY - 10);
                    ctx.lineTo(midX - 5, midY - 20);
                    ctx.lineTo(midX + 5, midY - 20);
                    ctx.fill();
                }

                if (isFull) {
                    ctx.fillStyle = '#ef4444';
                    ctx.font = 'bold 16px JetBrains Mono';
                    ctx.fillText(`LOAD: ${(sag * 10).toFixed(0)} kN`, w / 2 - 60, yBase - 140);
                }

                t++;
                requestAnimationFrame(loop);
            }
            loop();
        }

        // --- CS (BINARY TREE) ---
        function startCSSim(canvas, isFull) {
            const ctx = canvas.getContext('2d');
            let running = true;
            canvas._simActiveSetter = (isActive) => { running = isActive; if (isActive) loop(); };

            let activeIdx = 0;
            let lastTime = 0;

            function loop(timestamp) {
                if (!running || !canvas.isConnected) return;
                if (!lastTime) lastTime = timestamp;
                const elapsed = timestamp - lastTime;

                const w = canvas.width = canvas.clientWidth;
                const h = canvas.height = canvas.clientHeight;
                const cx = w / 2;
                const cy = isFull ? 80 : 30;
                const scale = isFull ? 1 : 0.5;

                const nodes = [
                    { x: cx, y: cy, val: 50 },
                    { x: cx - 100 * scale, y: cy + 80 * scale, val: 30 },
                    { x: cx + 100 * scale, y: cy + 80 * scale, val: 70 },
                ];
                if (isFull) {
                    nodes.push({ x: cx - 220, y: 280, val: 20 });
                    nodes.push({ x: cx - 80, y: 280, val: 40 });
                }

                ctx.fillStyle = '#0f172a';
                ctx.fillRect(0, 0, w, h);

                // Edges with moving pulse
                ctx.strokeStyle = '#334155'; ctx.lineWidth = 2;
                const edges = [[0, 1], [0, 2]];
                edges.forEach((e, i) => {
                    const n1 = nodes[e[0]], n2 = nodes[e[1]];
                    ctx.beginPath(); ctx.moveTo(n1.x, n1.y); ctx.lineTo(n2.x, n2.y); ctx.stroke();

                    // Moving dot
                    const t = (Date.now() / 1000 + i * 0.5) % 1;
                    const dx = n1.x + (n2.x - n1.x) * t;
                    const dy = n1.y + (n2.y - n1.y) * t;
                    ctx.fillStyle = '#3B82F6';
                    ctx.beginPath(); ctx.arc(dx, dy, 3, 0, Math.PI * 2); ctx.fill();
                });

                // Nodes
                nodes.forEach((n, i) => {
                    ctx.beginPath();
                    ctx.arc(n.x, n.y, isFull ? 35 : 12, 0, Math.PI * 2);
                    ctx.fillStyle = i === activeIdx ? '#3B82F6' : '#1e293b';
                    ctx.fill();
                    ctx.strokeStyle = i === activeIdx ? '#60a5fa' : '#475569';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                });

                // Hover Pause logic
                const isHover = !isFull && canvas.matches(':hover');
                if (!isHover && elapsed > 1000) {
                    activeIdx = (activeIdx + 1) % nodes.length;
                    lastTime = timestamp;
                } else if (isHover && elapsed > 1000) {
                    // Paused on hover
                    lastTime = timestamp;
                }

                requestAnimationFrame(loop);
            }
            requestAnimationFrame(loop);
        }

        // --- NEURAL NETWORK ---
        function startNeuralSim(canvas, isFull) {
            const ctx = canvas.getContext('2d');
            let running = true;
            canvas._simActiveSetter = (isActive) => { running = isActive; if (isActive) loop(); };
            let pulse = 0;

            function loop() {
                if (!running || !canvas.isConnected) return;
                const w = canvas.width = canvas.clientWidth;
                const h = canvas.height = canvas.clientHeight;

                ctx.fillStyle = '#0f172a';
                ctx.fillRect(0, 0, w, h);

                const layers = isFull ? [3, 5, 5, 2] : [2, 3, 2];
                const layerSpacing = w / (layers.length + 1);
                const nodePositions = [];

                layers.forEach((count, li) => {
                    const x = layerSpacing * (li + 1);
                    const ySpacing = h / (count + 1);
                    nodePositions[li] = [];
                    for (let ni = 0; ni < count; ni++) {
                        nodePositions[li].push({ x, y: ySpacing * (ni + 1) });
                    }
                });

                // Connections with Forward Pulse
                const pulseX = (pulse % (nodePositions.length)) * layerSpacing;

                for (let li = 0; li < nodePositions.length - 1; li++) {
                    nodePositions[li].forEach(n1 => {
                        nodePositions[li + 1].forEach(n2 => {
                            // Pulse Logic
                            const dist = Math.abs(n1.x - ((pulse % 40) * 10)); // approx

                            const isActive = (li === Math.floor(pulse) % (layers.length - 1));

                            const alpha = 0.1 + (isActive ? 0.8 : 0);

                            ctx.strokeStyle = `rgba(139, 92, 246, ${alpha})`;
                            ctx.lineWidth = isActive ? 2 : 1;
                            ctx.beginPath();
                            ctx.moveTo(n1.x, n1.y);
                            ctx.lineTo(n2.x, n2.y);
                            ctx.stroke();
                        });
                    });
                }

                // Nodes
                nodePositions.forEach((layer, li) => {
                    layer.forEach((n, ni) => {
                        const glow = (li === Math.floor(pulse) % layers.length) ? 1 : 0;
                        ctx.beginPath();
                        ctx.arc(n.x, n.y, (isFull ? 12 : 5), 0, Math.PI * 2);
                        ctx.fillStyle = `rgba(139, 92, 246, ${0.4 + glow * 0.6})`;
                        ctx.fill();
                        if (glow) {
                            ctx.shadowBlur = 10; ctx.shadowColor = '#8B5CF6';
                        } else { ctx.shadowBlur = 0; }
                    });
                });
                ctx.shadowBlur = 0;

                pulse += 0.05;
                requestAnimationFrame(loop);
            }
            loop();
        }

        // --- ELECTRICAL ---
        function startElectricalSim(canvas, isFull) {
            const ctx = canvas.getContext('2d');
            let running = true;
            canvas._simActiveSetter = (isActive) => { running = isActive; if (isActive) loop(); };
            let current = 0;

            function loop() {
                if (!running || !canvas.isConnected) return;
                const w = canvas.width = canvas.clientWidth;
                const h = canvas.height = canvas.clientHeight;

                ctx.fillStyle = '#f8fafc';
                ctx.fillRect(0, 0, w, h);

                const cx = w / 2;
                const cy = h / 2;
                const rw = isFull ? 200 : 100;
                const rh = isFull ? 100 : 50;

                const isHover = !isFull && canvas.matches(':hover');
                const speed = isHover ? 0.05 : 0.01;

                ctx.strokeStyle = '#334155';
                ctx.lineWidth = isFull ? 4 : 2;
                ctx.beginPath();
                ctx.rect(cx - rw, cy - rh, rw * 2, rh * 2);
                ctx.stroke();

                // Resistor Zigzag
                ctx.beginPath();
                ctx.strokeStyle = '#f59e0b';
                // Top side resistor
                const startX = cx - 20; const startY = cy - rh;
                ctx.moveTo(startX, startY);
                for (let i = 0; i < 4; i++) {
                    ctx.lineTo(startX + i * 10 + 5, startY + (i % 2 == 0 ? -5 : 5));
                }
                ctx.stroke();

                // Sparks if High Current
                if (isHover && Math.random() > 0.8) {
                    ctx.fillStyle = '#F59E0B';
                    ctx.beginPath(); ctx.arc(startX + 20, startY, 2, 0, Math.PI * 2); ctx.fill();
                }

                // Electrons
                const count = isFull ? 8 : 6;
                for (let i = 0; i < count; i++) {
                    const t = (current + i * (1 / count)) % 1;
                    let x, y;
                    if (t < 0.25) { x = cx - rw + t * 4 * (rw * 2); y = cy - rh; }
                    else if (t < 0.5) { x = cx + rw; y = cy - rh + (t - 0.25) * 4 * (rh * 2); }
                    else if (t < 0.75) { x = cx + rw - (t - 0.5) * 4 * (rw * 2); y = cy + rh; }
                    else { x = cx - rw; y = cy + rh - (t - 0.75) * 4 * (rh * 2); }

                    ctx.beginPath();
                    ctx.arc(x, y, isFull ? 6 : 3, 0, Math.PI * 2);
                    ctx.fillStyle = '#3B82F6';
                    ctx.fill();
                    // Glow
                    if (isHover) {
                        ctx.shadowColor = '#3B82F6'; ctx.shadowBlur = 5;
                    }
                }
                ctx.shadowBlur = 0;

                current += speed;
                requestAnimationFrame(loop);
            }
            loop();
        }

        // --- CARDIO ---
        function startCardioSim(canvas, isFull) {
            const ctx = canvas.getContext('2d');
            let running = true;
            canvas._simActiveSetter = (isActive) => { running = isActive; if (isActive) loop(); };
            let t = 0;

            function loop() {
                if (!running || !canvas.isConnected) return;
                const w = canvas.width = canvas.clientWidth;
                const h = canvas.height = canvas.clientHeight;

                ctx.fillStyle = '#fff1f2';
                ctx.fillRect(0, 0, w, h);

                const cx = w / 2;
                const cy = h / 2;

                // Heart beat (3 beats then steady? Simplified to heartbeat rhythm)
                // Beat pattern: |  ^  ^  | ...
                const beat = (Math.sin(t * 10) ** 6);
                const scale = (isFull ? 8 : 4) + beat * (isFull ? 2 : 1.5);
                const isHover = !isFull && canvas.matches(':hover');
                if (isHover) t += 0.05;

                ctx.save();
                ctx.translate(cx, cy);
                ctx.fillStyle = '#ef4444';
                ctx.beginPath();
                // Minimal Heart
                // We'll use a simpler draw for cardio
                ctx.moveTo(0, 0);
                // ... drawing heart shape
                // Parametric heart
                for (let i = 0; i < Math.PI * 2; i += 0.1) {
                    const x = 16 * Math.pow(Math.sin(i), 3);
                    const y = -(13 * Math.cos(i) - 5 * Math.cos(2 * i) - 2 * Math.cos(3 * i) - Math.cos(4 * i));
                    ctx.lineTo(x * scale * 0.1, y * scale * 0.1);
                }
                ctx.fill();
                ctx.restore();

                // ECG
                ctx.strokeStyle = '#dc2626';
                ctx.lineWidth = 2;
                ctx.beginPath();
                const ecgY = h * 0.8;
                for (let x = 0; x < w; x++) {
                    // Moving window
                    const phase = (x + t * 200) % 300;
                    let y = ecgY;
                    // QRS complex
                    if (phase > 100 && phase < 110) y -= 10;
                    if (phase > 110 && phase < 120) y += 30; // R
                    if (phase > 120 && phase < 130) y -= 10;
                    ctx.lineTo(x, y);
                }
                ctx.stroke();

                t += 0.02;
                requestAnimationFrame(loop);
            }
            loop();
        }

        // --- EYE ---
        function startEyeSim(canvas, isFull) {
            const ctx = canvas.getContext('2d');
            let running = true;
            canvas._simActiveSetter = (isActive) => { running = isActive; if (isActive) loop(); };

            let mouseX = 0, mouseY = 0;
            if (!isFull) {
                // Approximate mouse relative to canvas usually done via event listeners, 
                // but for simple preview we can use global mouse or auto sweep.
                // We'll use auto sweep if internal
            }

            // Simple Auto Sweep
            let t = 0;

            function loop() {
                if (!running || !canvas.isConnected) return;
                const w = canvas.width = canvas.clientWidth;
                const h = canvas.height = canvas.clientHeight;
                const cx = w / 2, cy = h / 2;

                ctx.fillStyle = '#f8fafc';
                ctx.fillRect(0, 0, w, h);

                // Iris pos
                const r = isFull ? 80 : 30;
                let dx = 0, dy = 0;

                const isHover = canvas.matches(':hover');
                if (!isHover) {
                    dx = Math.cos(t * 0.5) * (isFull ? 30 : 10);
                    dy = Math.sin(t * 0.5) * (isFull ? 10 : 5);
                }

                // Sclera
                ctx.beginPath();
                ctx.ellipse(cx, cy, r * 1.5, r, 0, 0, Math.PI * 2);
                ctx.fillStyle = '#ffffff';
                ctx.fill();
                ctx.strokeStyle = '#e2e8f0'; ctx.lineWidth = 1; ctx.stroke();

                // Iris
                ctx.beginPath();
                ctx.arc(cx + dx, cy + dy, r * 0.6, 0, Math.PI * 2);
                const grad = ctx.createRadialGradient(cx + dx, cy + dy, r * 0.1, cx + dx, cy + dy, r * 0.6);
                grad.addColorStop(0, '#60A5FA'); grad.addColorStop(1, '#1e3a8a');
                ctx.fillStyle = grad;
                ctx.fill();

                // Pupil
                const pupilSize = (isHover ? 0.7 : 0.4) * (r * 0.6);
                ctx.beginPath();
                ctx.arc(cx + dx, cy + dy, pupilSize, 0, Math.PI * 2);
                ctx.fillStyle = '#000000';
                ctx.fill();

                // Highlight
                ctx.beginPath();
                ctx.arc(cx + dx - r * 0.2, cy + dy - r * 0.2, r * 0.1, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(255,255,255,0.8)';
                ctx.fill();

                t += 0.05;
                requestAnimationFrame(loop);
            }
            loop();
        }

        // --- GEOMETRY ---
        function startGeometrySim(canvas, isFull) {
            const ctx = canvas.getContext('2d');
            let running = true;
            canvas._simActiveSetter = (isActive) => { running = isActive; if (isActive) loop(); };
            let t = 0;

            function loop() {
                if (!running || !canvas.isConnected) return;
                const w = canvas.width = canvas.clientWidth;
                const h = canvas.height = canvas.clientHeight;
                const cx = w / 2, cy = h / 2;

                ctx.fillStyle = '#f8fafc';
                ctx.fillRect(0, 0, w, h);

                const shapes = 3;
                const isHover = !isFull && canvas.matches(':hover');

                for (let i = 0; i < shapes; i++) {
                    ctx.save();
                    ctx.translate(cx, cy);

                    const rot = t * (i + 1) * 0.5 + (isHover ? i : 0);
                    ctx.rotate(rot);

                    ctx.strokeStyle = `hsl(${210 + i * 40}, 70%, 50%)`;
                    ctx.lineWidth = isFull ? 3 : 2;
                    ctx.beginPath();

                    const size = (isFull ? 60 : 20) + Math.sin(t + i) * 5;

                    // Triangle, Square, Circle
                    if (i === 0) {
                        ctx.moveTo(0, -size); ctx.lineTo(size, size); ctx.lineTo(-size, size); ctx.closePath();
                    } else if (i === 1) {
                        ctx.rect(-size * 0.8, -size * 0.8, size * 1.6, size * 1.6);
                    } else {
                        ctx.arc(0, 0, size, 0, Math.PI * 2);
                    }
                    ctx.stroke();
                    ctx.restore();
                }

                t += 0.02;
                requestAnimationFrame(loop);
            }
            loop();
        }

        // --- STATS ---
        function startStatsSim(canvas, isFull) {
            const ctx = canvas.getContext('2d');
            let running = true;
            canvas._simActiveSetter = (isActive) => { running = isActive; if (isActive) loop(); };

            const bars = [0.2, 0.5, 0.8, 0.4, 0.9, 0.6];
            let progress = 0;

            function loop() {
                if (!running || !canvas.isConnected) return;
                const w = canvas.width = canvas.clientWidth;
                const h = canvas.height = canvas.clientHeight;

                ctx.fillStyle = isFull ? '#ffffff' : '#f8fafc';
                ctx.fillRect(0, 0, w, h);

                const pad = isFull ? 50 : 20;
                const chartH = h - pad * 2;
                const barW = (w - pad * 2) / bars.length;

                // Bars
                if (progress < 1) progress += 0.02;

                bars.forEach((v, i) => {
                    const val = v * Math.min(1, progress * (1.5 - i * 0.1)); // Staggered
                    const hBar = val * chartH;

                    const x = pad + i * barW + barW * 0.1;
                    const y = h - pad - hBar;

                    // Bar
                    ctx.fillStyle = i === 4 ? '#3B82F6' : '#94a3b8';
                    ctx.fillRect(x, y + (progress >= 1 ? Math.sin(Date.now() * 0.005 + i) * 2 : 0), barW * 0.8, hBar);

                    // Wiggle
                    if (progress >= 1) {
                        const wiggle = Math.sin(Date.now() * 0.005 + i) * 2;
                        // ctx.fillRect(x, y + wiggle, barW*0.8, hBar - wiggle); // This was causing double draw, removed.
                    }
                });

                // Mean Line
                if (progress > 0.8) {
                    const meanY = h - pad - (0.6 * chartH);
                    ctx.beginPath();
                    ctx.strokeStyle = '#f59e0b';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([5, 5]);
                    ctx.moveTo(pad, meanY); ctx.lineTo(w - pad, meanY);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }

                requestAnimationFrame(loop);
            }
            loop();
        }

        // --- GENERIC ---
        function startGenericSim(canvas, title, isFull) {
            const ctx = canvas.getContext('2d');
            let running = true;
            canvas._simActiveSetter = (isActive) => { running = isActive; if (isActive) loop(); };
            let t = 0;
            function loop() {
                if (!running || !canvas.isConnected) return;
                const w = canvas.width = canvas.clientWidth;
                const h = canvas.height = canvas.clientHeight;
                ctx.fillStyle = '#f8fafc';
                ctx.fillRect(0, 0, w, h);

                const cx = w / 2, cy = h / 2;
                for (let i = 0; i < 3; i++) {
                    ctx.beginPath();
                    const r = isFull ? 20 : 10;
                    const d = isFull ? 150 : 40;
                    ctx.arc(cx + Math.cos(t + i) * d, cy + Math.sin(t + i * 1.5) * (d * 0.6), r + Math.sin(t * 2 + i) * 5, 0, Math.PI * 2);
                    ctx.fillStyle = `hsl(${t * 50 + i * 100}, 70%, 60%)`;
                    ctx.fill();
                }

                t += 0.05;
                requestAnimationFrame(loop);
            }
            loop();
        }


        // ===================================
        // 5. HERO BACKGROUND (FOG + GEOMETRY)
        // ===================================
        // ===========================================
        // 5. HERO BACKGROUND: "THE NEURAL NEBULA"
        // ===========================================
        const initHero = () => {
            const container = document.getElementById('hero-canvas');
            if (!container) return;
            container.innerHTML = '';

            // --- 1. SETUP ---
            const scene = new THREE.Scene();
            // Fog for depth fading
            scene.fog = new THREE.FogExp2(0xffffff, 0.05);

            const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100);
            camera.position.z = 20;

            const renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            container.appendChild(renderer.domElement);

            // --- 2. GENERATE TEXTURE ON FLY ---
            const getSprite = () => {
                const cvs = document.createElement('canvas');
                cvs.width = 32; cvs.height = 32;
                const ctx = cvs.getContext('2d');
                const grad = ctx.createRadialGradient(16, 16, 0, 16, 16, 16);
                grad.addColorStop(0, 'rgba(255,255,255,1)');
                grad.addColorStop(0.4, 'rgba(255,255,255,0.8)'); // More opaque
                grad.addColorStop(1, 'rgba(255,255,255,0)');
                ctx.fillStyle = grad;
                ctx.fillRect(0, 0, 32, 32);
                const tex = new THREE.CanvasTexture(cvs);
                return tex;
            }

            // --- 3. PARTICLE SYSTEM ---
            const count = 1800; // God-tier density
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(count * 3);
            const colors = new Float32Array(count * 3);
            const originalPositions = new Float32Array(count * 3); // For spring back
            const phases = new Float32Array(count); // For independent motion

            // Darker colors for visibility on white background
            const colorA = new THREE.Color('#2563EB'); // Darker Blue
            const colorB = new THREE.Color('#059669'); // Darker Teal
            const colorC = new THREE.Color('#D97706'); // Darker Orange

            for (let i = 0; i < count; i++) {
                // Spread particles in a wide cloud
                const x = (Math.random() - 0.5) * 60;
                const y = (Math.random() - 0.5) * 40;
                const z = (Math.random() - 0.5) * 40;

                positions[i * 3] = x;
                positions[i * 3 + 1] = y;
                positions[i * 3 + 2] = z;

                originalPositions[i * 3] = x;
                originalPositions[i * 3 + 1] = y;
                originalPositions[i * 3 + 2] = z;

                phases[i] = Math.random() * Math.PI * 2;

                // Color mapping based on X position
                // Left (-30) -> Blue, Center (0) -> Teal, Right (30) -> Orange
                let c = new THREE.Color();
                const nX = (x + 30) / 60; // 0 to 1
                if (nX < 0.5) {
                    c.lerpColors(colorA, colorB, nX * 2);
                } else {
                    c.lerpColors(colorB, colorC, (nX - 0.5) * 2);
                }

                colors[i * 3] = c.r;
                colors[i * 3 + 1] = c.g;
                colors[i * 3 + 2] = c.b;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            geometry.setAttribute('phase', new THREE.BufferAttribute(phases, 1));

            const material = new THREE.PointsMaterial({
                size: 0.7,
                vertexColors: true,
                map: getSprite(),
                transparent: true,
                opacity: 0.95,
                depthWrite: false,
                blending: THREE.NormalBlending // Normal blending for visibility on white
            });

            const particles = new THREE.Points(geometry, material);
            scene.add(particles);

            // --- 4. CONNECTING LINES (CONSTELIATION) ---
            // A simplified ghost mesh to represent connection without heavy computation
            const ghostGeo = new THREE.IcosahedronGeometry(15, 1);
            const ghostMat = new THREE.MeshBasicMaterial({
                color: 0x3B82F6,
                wireframe: true,
                transparent: true,
                opacity: 0.03,
                blending: THREE.AdditiveBlending
            });
            const ghostMesh = new THREE.Mesh(ghostGeo, ghostMat);
            scene.add(ghostMesh);


            // --- 5. INTERACTION & ANIMATION ---
            let mouseX = 0, mouseY = 0;
            let targetX = 0, targetY = 0;

            // Normalized mouse (-1 to 1)
            window.addEventListener('mousemove', (e) => {
                targetX = (e.clientX / window.innerWidth) * 2 - 1;
                targetY = -(e.clientY / window.innerHeight) * 2 + 1;
            });

            const clock = new THREE.Clock();

            const animate = () => {
                requestAnimationFrame(animate);
                const t = clock.getElapsedTime();

                // Smooth Mouse
                mouseX += (targetX - mouseX) * 0.05;
                mouseY += (targetY - mouseY) * 0.05;

                // 1. Ghost Mesh Rotation
                ghostMesh.rotation.y = t * 0.02;
                ghostMesh.rotation.z = t * 0.01;

                // 2. Particle Wave & Interaction
                const positions = particles.geometry.attributes.position.array;

                for (let i = 0; i < count; i++) {
                    const px = originalPositions[i * 3];
                    const py = originalPositions[i * 3 + 1];
                    const pz = originalPositions[i * 3 + 2];
                    const ph = phases[i];

                    // A) Natural Drift
                    const driftY = Math.sin(t * 0.5 + px * 0.1 + ph) * 2;
                    const driftX = Math.cos(t * 0.3 + py * 0.1) * 0.5;

                    let newX = px + driftX;
                    let newY = py + driftY;
                    let newZ = pz;

                    // B) Mouse Interaction (Parallax + Repulsion)
                    newX += mouseX * 2;
                    newY += mouseY * 2;

                    // Repulsion
                    const dx = newX - (mouseX * 10);
                    const dy = newY - (mouseY * 10);
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist < 8) {
                        const force = (8 - dist) * 2;
                        newX += (dx / dist) * force;
                        newY += (dy / dist) * force;
                    }

                    positions[i * 3] = newX;
                    positions[i * 3 + 1] = newY;
                    positions[i * 3 + 2] = newZ;
                }

                particles.geometry.attributes.position.needsUpdate = true;

                // Rotate entire cloud slightly
                particles.rotation.y = t * 0.05;

                renderer.render(scene, camera);
            };
            animate();

            window.addEventListener('resize', () => {
                const w = window.innerWidth;
                const h = window.innerHeight;
                renderer.setSize(w, h);
                camera.aspect = w / h;
                camera.updateProjectionMatrix();
            });
        };
        initHero();

        // ===================================
        // RE-INJECT RENDERMAP WITH UPDATED LOGIC
        // ===================================
        function renderMap(mapID) {
            gsap.to(nodesMount, {
                opacity: 0, duration: 0.3, onComplete: () => { loadNewData(mapID); }
            });
        }

        function loadNewData(mapID) {
            currentMapID = mapID;
            const data = ROADMAP_DATA[mapID];
            const nodeCount = data.nodes.length;

            // UI Upates
            pathText.innerText = data.title;
            backBtn.style.display = data.parent ? 'flex' : 'none';
            document.body.style.backgroundColor = data.color || "#F8FAFC";

            // 1. Generate Path
            // Config for spacing (ENFORCED)
            const verticalSpacePerCard = 1000; // HUGE gap as requested
            const segmentHeight = 800; // Visual curve tightness

            // Calculate total height based on card count * spacing
            const minHeight = Math.max(2000, nodeCount * verticalSpacePerCard + 400);
            const numSegments = Math.ceil(minHeight / segmentHeight);
            const totalHeight = numSegments * segmentHeight;

            svgBox.setAttribute("viewBox", `0 0 1000 ${totalHeight}`);
            nodesMount.style.height = `${totalHeight}px`;

            let d = `M 500 0 `;
            let lastX = 500;
            for (let seg = 0; seg < numSegments; seg++) {
                const segStart = seg * segmentHeight;
                const segEnd = (seg + 1) * segmentHeight;
                const peakX = (seg % 2 === 0) ? 780 : 220;
                const ctrl1Y = segStart + segmentHeight * 0.35;
                const ctrl2Y = segStart + segmentHeight * 0.65;
                d += `C ${lastX} ${ctrl1Y} ${peakX} ${ctrl2Y} ${peakX} ${segEnd} `;
                lastX = peakX;
            }
            const finalStart = numSegments * segmentHeight;
            d += `C ${lastX} ${finalStart + 80} 500 ${finalStart + 120} 500 ${totalHeight} `;
            roadBase.setAttribute("d", d);
            roadActive.setAttribute("d", d);

            // 2. Road Animation (ScrollTrigger)
            const len = roadActive.getTotalLength();
            roadActive.style.strokeDasharray = len;
            roadActive.style.strokeDashoffset = len;

            // FIX: Only kill ScrollTriggers associated with the roadmap to prevent killing Brain Parallax
            ScrollTrigger.getAll().forEach(t => {
                if (t.trigger && (t.trigger === "#roadmap-section" || t.trigger.id === "roadmap-section")) {
                    t.kill();
                }
            });

            gsap.fromTo(roadActive,
                { strokeDashoffset: len },
                {
                    strokeDashoffset: 0,
                    ease: "none",
                    scrollTrigger: {
                        trigger: "#roadmap-section",
                        start: "top top",
                        end: "bottom bottom",
                        scrub: 1
                    }
                }
            );

            // 3. Card Placement (Normal Vector + Heuristic Side)
            nodesMount.innerHTML = "";
            const pathPadding = 200;
            const usableLength = len - (pathPadding * 2);
            const step = usableLength / (nodeCount + 0.8);

            data.nodes.forEach((node, idx) => {
                const distanceOnPath = pathPadding + (step * idx);
                const p1 = roadActive.getPointAtLength(distanceOnPath);
                const p2 = roadActive.getPointAtLength(distanceOnPath + 2);

                // Normal
                const tx = p2.x - p1.x;
                const ty = p2.y - p1.y;
                const mag = Math.sqrt(tx * tx + ty * ty);
                const nx = -ty / mag;
                const ny = tx / mag;

                // Side Heuristic: If point is right of center (500), go Left (-1). Else Right (1).
                const dir = p1.x > 500 ? -1 : 1;
                const OFFSET = 200;

                const cardX = p1.x + (nx * OFFSET * dir);
                const cardY = p1.y + (ny * OFFSET * dir);

                const div = document.createElement('div');
                div.className = `node-item glass-card p-0 rounded-2xl overflow-hidden shadow-lg border border-white/50`;
                div.style.position = 'absolute';
                div.style.left = `${cardX}px`;
                div.style.top = `${cardY}px`;
                div.style.transform = `translate(-50%, -50%)`;
                div.style.width = '300px';

                // Inner HTML with Preview Canvas
                div.innerHTML = `
                    <div class="h-32 bg-slate-50 relative border-b border-slate-100">
                        <canvas class="micro-sim w-full h-full"></canvas>
                        <div class="absolute inset-0 bg-gradient-to-t from-white/80 to-transparent opacity-0 hover:opacity-100 transition-opacity flex items-center justify-center">
                            <span class="bg-slate-900 text-white text-xs font-bold px-3 py-1.5 rounded-full shadow-lg transform scale-90 group-hover:scale-100 transition-transform">
                                <i class="fas fa-play mr-1"></i> Preview
                            </span>
                        </div>
                    </div>
                    <div class="p-5 relative z-10 bg-white/60 backdrop-blur-md">
                        <div class="flex items-center gap-3 mb-2">
                            <i class="fas ${node.icon} text-slate-400 text-lg"></i>
                            <h3 class="font-bold text-slate-800 leading-tight">${node.title}</h3>
                        </div>
                        <p class="text-xs text-slate-500 line-clamp-2">${node.desc}</p>
                    </div>
                `;

                // Wrapper hover effect
                div.addEventListener('mouseenter', () => {
                    gsap.to(div, { scale: 1.05, boxShadow: "0 20px 50px -10px rgba(0,0,0,0.15)", duration: 0.3 });
                });
                div.addEventListener('mouseleave', () => {
                    gsap.to(div, { scale: 1, boxShadow: "0 10px 30px -10px rgba(0,0,0,0.05)", duration: 0.3 });
                });

                div.onclick = () => {
                    if (node.type === 'folder') {
                        renderMap(node.target);
                        gsap.to(window, { scrollTo: { y: "#roadmap-section", offsetY: 50 }, duration: 0.5 });
                    } else {
                        launchLab(node.sim, node.title);
                    }
                };

                nodesMount.appendChild(div);

                // Mount Micro Sim
                const cvs = div.querySelector('.micro-sim');
                mountMicroSim(node, cvs);
            });

            // 4. Entry Animation
            gsap.to(nodesMount, { opacity: 1, duration: 0.4 });
            gsap.fromTo(".node-item",
                { y: 50, opacity: 0 },
                {
                    y: 0, opacity: 1, duration: 0.8, stagger: 0.1, ease: "power2.out",
                    scrollTrigger: {
                        trigger: "#roadmap-section",
                        start: "top 60%",
                        toggleActions: "play none none reverse"
                    }
                }
            );
        }

        // ===================================
        // 6. OFFER SECTION ANIMATIONS (GSAP)
        // ===================================
        // ===================================
        // 6. OFFER SECTION ANIMATIONS (GSAP)
        // ===================================
        function initOfferSection() {
            gsap.registerPlugin(ScrollTrigger);

            const cards = gsap.utils.toArray('.offer-card');

            cards.forEach(card => {
                // 1. LAYERED PARALLAX
                gsap.timeline({
                    scrollTrigger: {
                        trigger: card,
                        start: "top bottom",
                        end: "bottom top",
                        scrub: true
                    }
                })
                    .to(card.querySelector('.layer-bg'), { y: -30, ease: "none" }, 0)
                    .to(card.querySelector('.layer-content'), { y: -10, ease: "none" }, 0)
                    .to(card.querySelector('.layer-accent'), { y: -50, ease: "none" }, 0);

                // 2. ENTRY & CONTINUOUS ANIMATION
                const id = card.id;
                const accent = card.querySelector('.layer-accent');

                // Add Glow element dynamically if missing
                if (!card.querySelector('.accent-glow')) {
                    const glow = document.createElement('div');
                    glow.className = 'accent-glow';
                    accent.prepend(glow);
                }

                // General Floating for ALL accents
                gsap.to(accent, {
                    y: "-=10",
                    duration: 2 + Math.random(),
                    yoyo: true,
                    repeat: -1,
                    ease: "sine.inOut",
                    delay: Math.random()
                });

                // Specific Entry + Continuous Logic
                const tl = gsap.timeline({
                    scrollTrigger: {
                        trigger: card,
                        start: "top 75%",
                        toggleActions: "play none none reverse"
                    }
                });

                if (id === 'card-paths') {
                    tl.fromTo("#card-paths .node-pulse", { scale: 0, opacity: 0 }, { scale: 1, opacity: 1, duration: 0.6, stagger: 0.2, ease: "back.out(2)" })
                        .fromTo("#card-paths path", { strokeDasharray: 100, strokeDashoffset: 100 }, { strokeDashoffset: 0, duration: 1, ease: "power2.out" }, 0);

                    gsap.to("#card-paths .node-pulse", { scale: 1.2, opacity: 0.7, duration: 1.5, yoyo: true, repeat: -1, stagger: 0.3, ease: "sine.inOut" });
                }
                else if (id === 'card-sims') {
                    tl.fromTo("#card-sims .electron", { scale: 0 }, { scale: 1, duration: 0.5, ease: "back.out" }, 0);

                    gsap.to("#card-sims .orbit-1", { rotation: 360, duration: 8, repeat: -1, ease: "none" });
                    gsap.to("#card-sims .orbit-2", { rotation: -360, duration: 12, repeat: -1, ease: "none" });
                    gsap.to("#card-sims .electron", {
                        motionPath: {
                            path: [{ x: 0, y: 0 }, { x: 20, y: -20 }, { x: 0, y: -40 }, { x: -20, y: -20 }, { x: 0, y: 0 }],
                            curviness: 1.5
                        },
                        duration: 4,
                        repeat: -1,
                        ease: "none"
                    });
                }
                else if (id === 'card-exec') {
                    tl.fromTo("#card-exec .typing-cursor", { opacity: 1 }, { opacity: 0, repeat: -1, duration: 0.5, ease: "steps(1)" });
                }
                else if (id === 'card-nested') {
                    tl.fromTo("#card-nested .zoom-circle-1", { scale: 0.5, opacity: 0 }, { scale: 1, opacity: 1, duration: 1, ease: "elastic.out(1, 0.5)" });

                    gsap.to("#card-nested .zoom-circle-1", { scale: 0.9, opacity: 0.8, duration: 3, yoyo: true, repeat: -1, ease: "sine.inOut" });
                    gsap.to("#card-nested .zoom-circle-2", { scale: 1.1, duration: 2.5, yoyo: true, repeat: -1, ease: "sine.inOut" });
                }
                else if (id === 'card-ai') {
                    tl.fromTo("#card-ai path", { scale: 0, rotation: -90 }, { scale: 1, rotation: 0, duration: 0.6, stagger: 0.1, ease: "back.out(3)" });

                    gsap.to("#card-ai path", { scale: 0.8, rotation: 15, duration: 1.2, yoyo: true, repeat: -1, stagger: { each: 0.5, from: "random" }, ease: "sine.inOut" });
                }
                else if (id === 'card-contest') {
                    gsap.to("#card-contest .clock-hand", { rotation: 360, transformOrigin: "50% 50%", duration: 4, repeat: -1, ease: "none" });
                }
                else if (id === 'card-progress') {
                    tl.fromTo("#card-progress .bar-grow", { scaleY: 0 }, { scaleY: 1, duration: 0.6, stagger: 0.1, ease: "power2.out" });

                    gsap.utils.toArray("#card-progress .bar-grow").forEach(bar => {
                        gsap.to(bar, {
                            scaleY: "random(0.4, 1)",
                            duration: "random(0.5, 1.5)",
                            repeat: -1,
                            yoyo: true,
                            ease: "sine.inOut",
                            delay: Math.random()
                        });
                    });
                }
                else if (id === 'card-unified') {
                    tl.from(".fa-cog", { opacity: 0, scale: 0 }, { opacity: 1, scale: 1, duration: 0.5 });

                    gsap.to(".fa-cog", { rotation: 360, duration: 10, repeat: -1, ease: "none" });
                    gsap.to(".fa-heart", { scale: 1.2, duration: 0.8, yoyo: true, repeat: -1, ease: "sine.inOut" });
                }
            });
        }

        // --- GLOBAL INIT ---
        window.addEventListener('DOMContentLoaded', () => {
            renderMap('root');
            initOfferSection();
        });
    </script>


</body>

</html>
