<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Skila.ai | Water Cycle</title>
    <link href="https://fonts.googleapis.com/css2?family=Fredoka:wght@400;700&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #0f172a;
            font-family: 'Fredoka', sans-serif;
        }

        #canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        .ui {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            padding: 20px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            max-width: 250px;
        }

        .temp-ctrl {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 10px;
        }
    </style>
</head>

<body>
    <canvas id="canvas"></canvas>

    <div class="ui">
        <h1 class="text-xl font-bold mb-2">Living Terrarium ðŸ’§</h1>
        <p class="text-xs opacity-70">Drag the Sun closer to evaporate water. Watch clouds form and rain fall.</p>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let width, height;
        let PARTICLES = [];
        let SUN = { x: 100, y: 100, r: 40, dragging: false };
        let BUBBLE = { x: 0, y: 0, r: 0 };

        // Colors
        const WATER_COLOR = '#0ea5e9';
        const STEAM_COLOR = 'rgba(255,255,255,0.4)';
        const CLOUD_COLOR = 'rgba(255,255,255,0.8)';
        const RAIN_COLOR = '#3b82f6';

        function resize() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
            BUBBLE.x = width / 2;
            BUBBLE.y = height / 2;
            BUBBLE.r = Math.min(width, height) * 0.4;

            // Init Water
            if (PARTICLES.length === 0) {
                for (let i = 0; i < 300; i++) {
                    PARTICLES.push({
                        x: BUBBLE.x + (Math.random() - 0.5) * BUBBLE.r * 1.5,
                        y: BUBBLE.y + BUBBLE.r - Math.random() * 50, // Bottom pool
                        vx: 0, vy: 0,
                        state: 'water', // water, steam, cloud, rain
                        life: 0
                    });
                }
            }
        }
        window.addEventListener('resize', resize);
        resize();

        // Sun Drag
        canvas.addEventListener('mousedown', e => {
            const dx = e.clientX - SUN.x; const dy = e.clientY - SUN.y;
            if (Math.sqrt(dx * dx + dy * dy) < SUN.r + 20) SUN.dragging = true;
        });
        window.addEventListener('mouseup', () => SUN.dragging = false);
        window.addEventListener('mousemove', e => {
            if (SUN.dragging) { SUN.x = e.clientX; SUN.y = e.clientY; }
        });

        function loop() {
            ctx.fillStyle = '#1e293b';
            ctx.fillRect(0, 0, width, height);

            // Draw Glass Sphere Back
            ctx.beginPath(); ctx.arc(BUBBLE.x, BUBBLE.y, BUBBLE.r, 0, Math.PI * 2);
            ctx.fillStyle = '#0f172a'; ctx.fill();
            // Soil
            ctx.beginPath();
            // ctx.arc based clip? simplified

            // Logic
            // Sun Heat
            // Distance from Sun to Water Pool (Bottom)
            const poolY = BUBBLE.y + BUBBLE.r - 20;
            const sunDist = Math.hypot(SUN.x - BUBBLE.x, SUN.y - poolY);
            const heat = Math.max(0, 1 - sunDist / 500); // 0 to 1

            PARTICLES.forEach(p => {
                // Constraints (Bubble)
                const dx = p.x - BUBBLE.x;
                const dy = p.y - BUBBLE.y;
                const d = Math.sqrt(dx * dx + dy * dy);

                if (d > BUBBLE.r - 5 && p.state !== 'rain') {
                    // Keep in circle
                    const ang = Math.atan2(dy, dx);
                    p.x = BUBBLE.x + Math.cos(ang) * (BUBBLE.r - 5);
                    p.y = BUBBLE.y + Math.sin(ang) * (BUBBLE.r - 5);
                    p.vx *= -0.5; p.vy *= -0.5;
                }

                if (p.state === 'water') {
                    // Gravity to bottom
                    if (p.y < BUBBLE.y + BUBBLE.r - 10) p.vy += 0.2;
                    p.vx *= 0.9; p.vy *= 0.5; // Damping

                    // Evaporate?
                    if (heat > 0.2 && Math.random() < 0.02 * heat) {
                        p.state = 'steam';
                        p.vy = -1; // Rise
                    }
                }
                else if (p.state === 'steam') {
                    p.vy -= 0.05; // Rise
                    p.vx += (Math.random() - 0.5) * 0.2;

                    // Condense at top
                    if (p.y < BUBBLE.y - BUBBLE.r / 2) {
                        p.state = 'cloud';
                        p.vx *= 0.1; p.vy *= 0.1;
                    }
                }
                else if (p.state === 'cloud') {
                    // Float interaction
                    // Wander
                    p.vx += (Math.random() - 0.5) * 0.1;
                    p.vy = Math.sin(Date.now() * 0.001) * 0.1;

                    // Clumping?
                    // Simplified: If many clouds, turn to rain
                    p.life++;
                    if (p.life > 300 && Math.random() < 0.01) {
                        p.state = 'rain';
                        p.life = 0;
                    }
                }
                else if (p.state === 'rain') {
                    p.vy += 0.2; // Fall
                    // Hit ground -> Water
                    if (p.y > BUBBLE.y + BUBBLE.r - 50) {
                        p.state = 'water';
                    }
                }

                p.x += p.vx;
                p.y += p.vy;
            });

            // Render
            PARTICLES.forEach(p => {
                if (p.state === 'water') { ctx.fillStyle = WATER_COLOR; ctx.beginPath(); ctx.arc(p.x, p.y, 4, 0, Math.PI * 2); ctx.fill(); }
                if (p.state === 'steam') { ctx.fillStyle = STEAM_COLOR; ctx.beginPath(); ctx.arc(p.x, p.y, 3, 0, Math.PI * 2); ctx.fill(); }
                if (p.state === 'cloud') { ctx.fillStyle = CLOUD_COLOR; ctx.beginPath(); ctx.arc(p.x, p.y, 8, 0, Math.PI * 2); ctx.fill(); }
                if (p.state === 'rain') { ctx.strokeStyle = RAIN_COLOR; ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(p.x, p.y); ctx.lineTo(p.x, p.y + 6); ctx.stroke(); }
            });

            // Draw Sun
            ctx.fillStyle = '#f59e0b';
            ctx.shadowColor = '#f59e0b'; ctx.shadowBlur = 40;
            ctx.beginPath(); ctx.arc(SUN.x, SUN.y, SUN.r, 0, Math.PI * 2); ctx.fill();
            ctx.shadowBlur = 0;

            // Draw Glass Front
            ctx.fillStyle = 'rgba(255,255,255,0.1)';
            ctx.beginPath(); ctx.arc(BUBBLE.x, BUBBLE.y, BUBBLE.r, 0, Math.PI * 2); ctx.fill();
            ctx.strokeStyle = 'rgba(255,255,255,0.3)'; ctx.lineWidth = 4; ctx.stroke();

            // Plants (Procedural Growth on Rain)
            // Just faint green at bottom

            requestAnimationFrame(loop);
        }
        loop();

    </script>
</body>

</html>