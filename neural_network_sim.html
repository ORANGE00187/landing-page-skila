<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Skila.ai | Neural Network Visualization</title>
    <!-- FONTS -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Plus+Jakarta+Sans:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap"
        rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body,
        html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #F8FAFC;
            /* Paper White */
            font-family: 'Plus Jakarta Sans', sans-serif;
        }

        /* Ambient Background */
        .bg-mesh {
            position: absolute;
            inset: 0;
            background-image:
                radial-gradient(circle at 10% 10%, rgba(124, 58, 237, 0.03) 0%, transparent 40%),
                radial-gradient(circle at 90% 90%, rgba(6, 182, 212, 0.03) 0%, transparent 40%);
            z-index: 0;
            pointer-events: none;
        }

        .hex-grid {
            position: absolute;
            inset: 0;
            background-image: url("data:image/svg+xml,%3Csvg width='60' height='60' viewBox='0 0 60 60' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M30 0l25.98 15v30L30 60 4.02 45V15z' fill-opacity='0.02' fill='%2364748B' fill-rule='evenodd'/%3E%3C/svg%3E");
            z-index: 0;
            opacity: 0.5;
            pointer-events: none;
        }

        #sim-canvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 10;
        }

        /* UI Overlay */
        .ui-overlay {
            position: absolute;
            top: 2rem;
            left: 2rem;
            z-index: 20;
            pointer-events: none;
        }

        .glass-panel {
            background: rgba(255, 255, 255, 0.85);
            backdrop-filter: blur(16px);
            -webkit-backdrop-filter: blur(16px);
            border: 1px solid rgba(255, 255, 255, 0.9);
            box-shadow: 0 20px 40px -10px rgba(124, 58, 237, 0.1);
            border-radius: 20px;
            padding: 1.5rem;
            max-width: 300px;
            pointer-events: auto;
            transition: transform 0.3s ease;
        }

        .glass-panel:hover {
            transform: translateY(-2px);
        }

        .stat-badge {
            display: inline-flex;
            align-items: center;
            padding: 4px 10px;
            border-radius: 99px;
            font-size: 0.7rem;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-right: 0.5rem;
        }

        .badge-training {
            background: rgba(244, 63, 94, 0.1);
            color: #F43F5E;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .badge-training.active {
            opacity: 1;
        }

        .layer-label {
            position: absolute;
            bottom: 2rem;
            text-align: center;
            font-size: 0.75rem;
            /* Tiny */
            font-weight: 700;
            color: #94A3B8;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            pointer-events: none;
            width: 100px;
            transform: translateX(-50%);
        }
    </style>
</head>

<body>

    <div class="bg-mesh"></div>
    <div class="hex-grid"></div>

    <canvas id="sim-canvas"></canvas>

    <!-- Labels (Positioned by JS) -->
    <div id="labels-container"></div>

    <div class="ui-overlay">
        <div class="glass-panel">
            <div class="flex items-center justify-between mb-2">
                <h1 class="text-sm font-bold text-slate-800">Deep Neural Network</h1>
                <div class="w-2 h-2 rounded-full bg-green-400 animate-pulse"></div>
            </div>

            <div class="text-[11px] text-slate-500 font-mono mb-4 leading-relaxed">
                Architecture: 4 Layers (FC)<br>
                Activation: ReLU / Softmax<br>
                Status: <span id="status-text" class="text-slate-800 font-bold">Inference</span>
            </div>

            <div class="flex items-center">
                <div class="stat-badge badge-training" id="training-badge">
                    <i class="fas fa-sync fa-spin mr-1"></i> Backprop
                </div>
            </div>

            <div class="mt-4 pt-4 border-t border-slate-100 text-[10px] text-slate-400">
                Hover left nodes to fire.<br>Click to re-wire weights.
            </div>
        </div>
    </div>

    <!-- FontAwesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

    <script>
        /**
         * SKILA.ai - Neural Network Simulation (Digital Cortex)
         * - 4 Layer MLP Visualization
         * - Particle Based Forward Propagation
         * - Shockwave Backpropagation
         * - 3D Parallax & Mouse Repulsion physics
         */

        const canvas = document.getElementById('sim-canvas');
        const ctx = canvas.getContext('2d', { alpha: true });

        let width, height;
        let mouseX = 0, mouseY = 0;
        let time = 0;

        // --- CONFIG ---
        const CONFIG = {
            layers: [5, 8, 8, 4], // Node counts
            nodeRadius: 12,
            colors: {
                nodeInactive: '#E2E8F0',
                nodeActive: '#7C3AED', // Violet
                synapse: '#CBD5E1',
                particle: '#06B6D4',   // Cyan
                backprop: '#F43F5E'    // Magenta
            },
            physics: {
                spring: 0.05,
                friction: 0.9,
                repulsion: 100
            }
        };

        // --- ENTITIES ---
        const nodes = [];
        const synapses = [];
        const particles = [];
        let backpropWave = { active: false, x: 0, speed: 15 };

        class Node {
            constructor(layerIdx, index, totalInLayer) {
                this.layer = layerIdx;
                this.index = index;

                // Position logic
                // Spread layers across width
                const xStep = window.innerWidth / (CONFIG.layers.length + 0.5);
                this.baseX = xStep * (layerIdx + 0.8);

                // Spread nodes vertically
                const yStep = window.innerHeight / (totalInLayer + 1);
                this.baseY = yStep * (index + 1);

                this.x = this.baseX;
                this.y = this.baseY;

                // Physics State
                this.vx = 0;
                this.vy = 0;

                // Visual State
                this.activation = 0; // 0 to 1
                this.flash = 0;      // Instant flash
            }

            update() {
                // 1. Spring back to base
                const dx = this.baseX - this.x;
                const dy = this.baseY - this.y;

                this.vx += dx * CONFIG.physics.spring;
                this.vy += dy * CONFIG.physics.spring;

                // 2. Mouse Repulsion
                const mdx = mouseX - this.x;
                const mdy = mouseY - this.y;
                const dist = Math.sqrt(mdx * mdx + mdy * mdy);

                if (dist < 150) {
                    const force = (150 - dist) / 150;
                    this.vx -= (mdx / dist) * force * 2;
                    this.vy -= (mdy / dist) * force * 2;
                }

                // 3. Float (Parallax / Breathing)
                this.vx += Math.sin(time * 0.05 + this.index) * 0.05;
                this.vy += Math.cos(time * 0.03 + this.layer) * 0.05;

                // Physics Apply
                this.vx *= CONFIG.physics.friction;
                this.vy *= CONFIG.physics.friction;
                this.x += this.vx;
                this.y += this.vy;

                // Decay Activation
                this.activation *= 0.95;
                this.flash *= 0.85;

                // Input Trigger (Layer 0)
                if (this.layer === 0 && dist < 40) {
                    this.fire();
                }
            }

            fire() {
                if (this.activation > 0.5) return; // Debounce

                this.activation = 1;
                this.flash = 1;

                // Spawn Particles to next layer
                const nextLayerNodes = nodes.filter(n => n.layer === this.layer + 1);
                nextLayerNodes.forEach(target => {
                    particles.push(new Particle(this, target));
                });
            }

            draw() {
                // Glass Orb
                ctx.beginPath();
                ctx.arc(this.x, this.y, CONFIG.nodeRadius + (this.activation * 5), 0, Math.PI * 2);

                // Fill
                const activeColor = this.layer === CONFIG.layers.length - 1 ? '#06B6D4' : CONFIG.colors.nodeActive;

                if (this.activation > 0.01) {
                    ctx.fillStyle = hexToRgba(activeColor, 0.2 + this.activation * 0.8);
                    ctx.shadowColor = activeColor;
                    ctx.shadowBlur = this.activation * 20;
                } else {
                    ctx.fillStyle = CONFIG.colors.nodeInactive;
                    ctx.shadowBlur = 0;
                }
                ctx.fill();
                ctx.shadowBlur = 0; // Reset

                // Inner Core
                ctx.beginPath();
                ctx.arc(this.x, this.y, CONFIG.nodeRadius * 0.4, 0, Math.PI * 2);
                ctx.fillStyle = 'white';
                ctx.fill();
            }
        }

        class Synapse {
            constructor(source, target) {
                this.source = source;
                this.target = target;
                this.weight = Math.random(); // 0 to 1 visual thickness
            }

            draw(backpropX) {
                // Bezier Curve
                const cp1x = this.source.x + (this.target.x - this.source.x) * 0.5;
                const cp1y = this.source.y;
                const cp2x = this.source.x + (this.target.x - this.source.x) * 0.5;
                const cp2y = this.target.y;

                ctx.beginPath();
                ctx.moveTo(this.source.x, this.source.y);
                ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, this.target.x, this.target.y);

                // Style
                let alpha = 0.1 + (this.source.activation * 0.4);
                let color = CONFIG.colors.synapse;
                let width = 1 + this.weight * 2;

                // Backprop Shockwave Effect
                // Check if curve intersects the vertical backprop wave line approximately
                const midX = (this.source.x + this.target.x) / 2;
                if (Math.abs(midX - backpropX) < 20) {
                    color = CONFIG.colors.backprop;
                    alpha = 0.8;
                    width = 4;
                    // Jiggle nodes
                    this.source.vx -= 2;
                    this.target.vx += 2;
                }

                ctx.strokeStyle = hexToRgba(color, alpha);
                ctx.lineWidth = width;
                ctx.stroke();
            }
        }

        class Particle {
            constructor(source, target) {
                this.source = source;
                this.target = target;
                this.progress = 0;
                this.speed = 0.02 + Math.random() * 0.01;
            }

            update() {
                this.progress += this.speed;
                if (this.progress >= 1) {
                    this.target.fire();
                    return false; // Kill
                }
                return true;
            }

            draw() {
                // Interpolate along Bezier
                const t = this.progress;
                const sx = this.source.x, sy = this.source.y;
                const tx = this.target.x, ty = this.target.y;

                // Standard Cubic Bezier calculation
                // For simplicity using a simplified localized curve or just reuse logic
                const cx1 = sx + (tx - sx) * 0.5;
                const cy1 = sy;
                const cx2 = sx + (tx - sx) * 0.5;
                const cy2 = ty;

                // De Casteljau's algorithm / Cubic formula
                const x = Math.pow(1 - t, 3) * sx + 3 * Math.pow(1 - t, 2) * t * cx1 + 3 * (1 - t) * Math.pow(t, 2) * cx2 + Math.pow(t, 3) * tx;
                const y = Math.pow(1 - t, 3) * sy + 3 * Math.pow(1 - t, 2) * t * cy1 + 3 * (1 - t) * Math.pow(t, 2) * cy2 + Math.pow(t, 3) * ty;

                ctx.beginPath();
                ctx.arc(x, y, 3, 0, Math.PI * 2);
                ctx.fillStyle = CONFIG.colors.particle;
                ctx.fill();

                // Trail
                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.lineTo(x - (tx - sx) * 0.05, y - (ty - sy) * 0.05); // Rough trail
                ctx.strokeStyle = CONFIG.colors.particle;
                ctx.stroke();
            }
        }

        // --- INIT ---
        function init() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;

            nodes.length = 0;
            synapses.length = 0;
            particles.length = 0;

            // Create Nodes
            CONFIG.layers.forEach((count, lIdx) => {
                for (let i = 0; i < count; i++) {
                    nodes.push(new Node(lIdx, i, count));
                }

                // Labels
                const label = document.createElement('div');
                label.className = 'layer-label';
                if (lIdx === 0) label.innerText = "Input";
                else if (lIdx === CONFIG.layers.length - 1) label.innerText = "Output";
                else label.innerText = `Hidden ${lIdx}`;

                const xStep = width / (CONFIG.layers.length + 0.5);
                label.style.left = `${xStep * (lIdx + 0.8)}px`;
                document.getElementById('labels-container').appendChild(label);
            });

            // Create Synapses (Fully connected)
            for (let l = 0; l < CONFIG.layers.length - 1; l++) {
                const layerNodes = nodes.filter(n => n.layer === l);
                const nextLayerNodes = nodes.filter(n => n.layer === l + 1);

                layerNodes.forEach(src => {
                    nextLayerNodes.forEach(tgt => {
                        synapses.push(new Synapse(src, tgt));
                    });
                });
            }
        }

        // --- LOOP ---
        function loop() {
            ctx.clearRect(0, 0, width, height);

            // Backprop Logic
            if (time % 300 === 0) { // Every ~5 seconds
                triggerBackprop();
            }

            if (backpropWave.active) {
                backpropWave.x -= backpropWave.speed;
                if (backpropWave.x < 0) {
                    backpropWave.active = false;
                    document.getElementById('training-badge').classList.remove('active');
                    document.getElementById('status-text').innerText = "Inference";
                }
            }

            // Draw Synapses
            synapses.forEach(s => s.draw(backpropWave.active ? backpropWave.x : -100));

            // Draw Nodes
            nodes.forEach(n => {
                n.update();
                n.draw();
            });

            // Draw Particles
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                const alive = p.update();
                if (alive) p.draw();
                else particles.splice(i, 1);
            }

            time++;
            requestAnimationFrame(loop);
        }

        function triggerBackprop() {
            backpropWave.active = true;
            backpropWave.x = width; // Start from right
            document.getElementById('training-badge').classList.add('active');
            document.getElementById('status-text').innerText = "Training...";

            // Re-randomize weights slightly for visual effect
            synapses.forEach(s => {
                if (Math.random() > 0.5) s.weight = Math.random();
            });
        }

        function hexToRgba(hex, alpha) {
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }

        // --- EVENTS ---
        window.addEventListener('mousemove', e => {
            mouseX = e.clientX;
            mouseY = e.clientY;
        });

        window.addEventListener('click', () => {
            // Global Rewire
            init();
            // Pulse effect
            nodes.forEach(n => {
                n.vx = (Math.random() - 0.5) * 50;
                n.vy = (Math.random() - 0.5) * 50;
            });
        });

        window.addEventListener('resize', () => {
            document.getElementById('labels-container').innerHTML = '';
            init();
        });

        init();
        loop();

    </script>
</body>

</html>