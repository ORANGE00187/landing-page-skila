<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Skila.ai | Logic Gates</title>
    <link href="https://fonts.googleapis.com/css2?family=Share+Tech+Mono&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #111827;
            font-family: 'Share Tech Mono', monospace;
        }

        #canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        .toolbox {
            position: absolute;
            left: 20px;
            top: 100px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .part {
            width: 80px;
            height: 60px;
            background: #1f2937;
            border: 1px solid #4b5563;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: grab;
            user-select: none;
        }

        .part:hover {
            border-color: #10b981;
        }
    </style>
</head>

<body>
    <canvas id="canvas"></canvas>

    <div class="toolbox">
        <div class="part" onmousedown="spawn('AND')">AND</div>
        <div class="part" onmousedown="spawn('OR')">OR</div>
        <div class="part" onmousedown="spawn('NOT')">NOT</div>
        <div class="part" onmousedown="spawn('SWITCH')">SWITCH</div>
        <div class="part" onmousedown="spawn('LIGHT')">LIGHT</div>
    </div>

    <div style="position:absolute; top: 20px; left: 20px; color: #10b981;">
        <h1 class="text-2xl">LOGIC LAB</h1>
        <p class="text-xs text-gray-400">Drag parts. Hover pins to wire.</p>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let width, height;
        let NODES = []; // Gates/Components
        let WIRES = []; // Connections {from: {node, pin}, to: {node, pin}}

        // Sim
        let DRAG = null; let DRAG_OFFX = 0; let DRAG_OFFY = 0;
        let WIRING = null; // {node, pin, type: 'in'|'out'}

        function resize() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
            // Examples
            const s1 = { type: 'SWITCH', x: 100, y: 300, w: 60, h: 40, state: false, id: 1 };
            const l1 = { type: 'LIGHT', x: 600, y: 300, w: 60, h: 60, state: false, id: 2 };
            NODES.push(s1, l1);
        }
        window.addEventListener('resize', resize);
        resize();

        window.spawn = (type) => {
            NODES.push({
                type, x: 200, y: 200, w: type === 'LIGHT' || type === 'SWITCH' ? 60 : 80, h: 50,
                state: false, id: Date.now()
            });
        };

        // Input
        canvas.addEventListener('mousedown', e => {
            const mx = e.clientX; const my = e.clientY;
            // 1. Check Pins (Wiring)
            // Pins are relative to node
            for (let n of NODES) {
                const pins = getPins(n);
                // In pins
                for (let i = 0; i < pins.in.length; i++) {
                    const p = pins.in[i];
                    if (Math.hypot(mx - p.x, my - p.y) < 10) {
                        WIRING = { node: n, pin: i, dir: 'in', x: p.x, y: p.y }; return;
                    }
                }
                // Out pins
                for (let i = 0; i < pins.out.length; i++) {
                    const p = pins.out[i];
                    if (Math.hypot(mx - p.x, my - p.y) < 10) {
                        WIRING = { node: n, pin: i, dir: 'out', x: p.x, y: p.y }; return;
                    }
                }
            }

            // 2. Check Body (Drag / Toggle)
            for (let i = NODES.length - 1; i >= 0; i--) {
                let n = NODES[i];
                if (mx > n.x && mx < n.x + n.w && my > n.y && my < n.y + n.h) {
                    if (n.type === 'SWITCH') {
                        n.state = !n.state; // Toggle
                    } else {
                        DRAG = n;
                        DRAG_OFFX = mx - n.x;
                        DRAG_OFFY = my - n.y;
                    }
                    return;
                }
            }
        });

        canvas.addEventListener('mousemove', e => {
            if (DRAG) {
                DRAG.x = e.clientX - DRAG_OFFX;
                DRAG.y = e.clientY - DRAG_OFFY;
            }
            if (WIRING) {
                // visual drag line
            }
        });

        window.addEventListener('mouseup', e => {
            if (WIRING) {
                // Find target pin
                // Logic: Connect Out to In ideally
                const mx = e.clientX; const my = e.clientY;
                for (let n of NODES) {
                    const pins = getPins(n);
                    // Check reciprocal
                    // If started In, look for Out
                    if (WIRING.dir === 'in') {
                        pins.out.forEach((p, i) => {
                            if (Math.hypot(mx - p.x, my - p.y) < 15) {
                                // Link WIRING(pin in) tp THIS(pin out)
                                WIRES.push({ from: { node: n, pin: i }, to: { node: WIRING.node, pin: WIRING.pin } });
                            }
                        });
                    } else {
                        pins.in.forEach((p, i) => {
                            if (Math.hypot(mx - p.x, my - p.y) < 15) {
                                WIRES.push({ from: { node: WIRING.node, pin: WIRING.pin }, to: { node: n, pin: i } });
                            }
                        });
                    }
                }
                WIRING = null;
            }
            DRAG = null;
        });

        function getPins(n) {
            // Returns absolute positions
            // IN: Left side. OUT: Right side.
            let ins = [], outs = [];
            if (n.type === 'AND' || n.type === 'OR') {
                ins = [{ x: n.x, y: n.y + 15 }, { x: n.x, y: n.y + 35 }];
                outs = [{ x: n.x + n.w, y: n.y + 25 }];
            } else if (n.type === 'NOT') {
                ins = [{ x: n.x, y: n.y + 25 }];
                outs = [{ x: n.x + n.w, y: n.y + 25 }];
            } else if (n.type === 'SWITCH') {
                outs = [{ x: n.x + n.w, y: n.y + 20 }];
            } else if (n.type === 'LIGHT') {
                ins = [{ x: n.x, y: n.y + 30 }];
            }
            return { in: ins, out: outs };
        }

        function sim() {
            // Reset calc states (except switches)
            // ideally topological sort or multi-pass
            // Simple multi-pass
            for (let pass = 0; pass < 5; pass++) {
                NODES.forEach(n => {
                    if (n.type === 'SWITCH') return; // Source

                    // Gather Inputs
                    // Find wires connected to my IN pins
                    let pinStates = [false, false]; // max 2 pins

                    WIRES.forEach(w => {
                        if (w.to.node === n) {
                            // Find state of source
                            // If source node is state true?
                            // Logic gates need output value per pin?
                            // Simplify: Nodes have one output state "n.state"
                            if (w.from.node.state) pinStates[w.to.pin] = true;
                        }
                    });

                    // Logic
                    if (n.type === 'AND') n.state = pinStates[0] && pinStates[1];
                    if (n.type === 'OR') n.state = pinStates[0] || pinStates[1];
                    if (n.type === 'NOT') n.state = !pinStates[0];
                    if (n.type === 'LIGHT') n.state = pinStates[0];
                });
            }
        }

        function loop() {
            sim();

            ctx.fillStyle = '#111827';
            ctx.fillRect(0, 0, width, height);

            // Draw Wires
            WIRES.forEach(w => {
                const p1 = getPins(w.from.node).out[w.from.pin];
                const p2 = getPins(w.to.node).in[w.to.pin];

                // Active Color?
                ctx.strokeStyle = w.from.node.state ? '#10b981' : '#374151';
                ctx.lineWidth = 4;
                if (w.from.node.state) { ctx.shadowBlur = 10; ctx.shadowColor = '#10b981'; } else ctx.shadowBlur = 0;

                ctx.beginPath();
                ctx.moveTo(p1.x, p1.y);
                // Bezier
                ctx.bezierCurveTo(p1.x + 50, p1.y, p2.x - 50, p2.y, p2.x, p2.y);
                ctx.stroke();
                ctx.shadowBlur = 0;
            });

            // Draw Wiring Drag
            if (WIRING) {
                ctx.strokeStyle = '#fff'; ctx.setLineDash([5, 5]);
                ctx.beginPath(); ctx.moveTo(WIRING.x, WIRING.y);
                // To Mouse (need mouse pos globally? hack using stored)
                // ... Simplification: skip visual line for now
                ctx.stroke(); ctx.setLineDash([]);
            }

            // Draw Nodes
            NODES.forEach(n => {
                ctx.fillStyle = '#1f2937';
                if (n.state && (n.type === 'LIGHT' || n.type === 'SWITCH')) {
                    ctx.fillStyle = n.type === 'LIGHT' ? '#10b981' : '#059669';
                    ctx.shadowBlur = 20; ctx.shadowColor = '#10b981';
                }

                ctx.strokeStyle = '#4b5563'; ctx.lineWidth = 2;
                ctx.fillRect(n.x, n.y, n.w, n.h);
                ctx.strokeRect(n.x, n.y, n.w, n.h);
                ctx.shadowBlur = 0;

                // Label
                ctx.fillStyle = '#fff'; ctx.font = '14px monospace'; ctx.textAlign = 'center';
                ctx.fillText(n.type, n.x + n.w / 2, n.y + n.h / 2 + 5);

                // Pins
                const pins = getPins(n);
                ctx.fillStyle = '#9ca3af';
                [...pins.in, ...pins.out].forEach(p => {
                    ctx.beginPath(); ctx.arc(p.x, p.y, 4, 0, Math.PI * 2); ctx.fill();
                });
            });

            requestAnimationFrame(loop);
        }
        loop();

    </script>
</body>

</html>