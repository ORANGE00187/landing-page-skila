<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Skila.ai | Optical Lab</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
            font-family: 'Orbitron', sans-serif;
        }

        #canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        .toolbar {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px;
            border: 1px solid #333;
            border-radius: 10px;
        }

        .tool {
            width: 60px;
            height: 60px;
            border: 1px solid #555;
            color: #fff;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 24px;
        }

        .tool:hover {
            border-color: #f0f;
            box-shadow: 0 0 10px #f0f;
        }

        .success {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #0f0;
            font-size: 50px;
            display: none;
            text-shadow: 0 0 20px #0f0;
        }
    </style>
</head>

<body>
    <canvas id="canvas"></canvas>

    <div class="toolbar">
        <div class="tool" onclick="setTool('mirror')">üî≤</div>
        <div class="tool" onclick="setTool('glass')">üü¶</div>
        <div class="tool" onclick="clearAll()">‚ùå</div>
    </div>

    <div class="success" id="win-msg">TARGET HIT!</div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const msg = document.getElementById('win-msg');

        let width, height;
        let RAYS = [];
        let OBJECTS = []; // { type: 'mirror'|'glass', x, y, user: true, rot: 0 }
        let CUR_TOOL = 'mirror';

        // Level Setup
        const SOURCE = { x: 50, y: 300, dir: 0 };
        const TARGET = { x: 800, y: 200, w: 20, h: 60, hit: false };

        function resize() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
            TARGET.x = width - 100;
        }
        window.addEventListener('resize', resize);
        resize();

        window.setTool = (t) => CUR_TOOL = t;
        window.clearAll = () => OBJECTS = [];

        // Input
        let MOUSE = { x: 0, y: 0, down: false, drag: null };

        canvas.addEventListener('mousedown', e => {
            const mx = e.clientX; const my = e.clientY;
            // Check hit object
            for (let o of OBJECTS) {
                if (Math.hypot(mx - o.x, my - o.y) < 30) {
                    MOUSE.drag = o; return;
                }
            }
            // Create new
            if (CUR_TOOL) {
                const o = { type: CUR_TOOL, x: mx, y: my, rot: Math.PI / 4 };
                OBJECTS.push(o);
                MOUSE.drag = o;
            }
        });

        canvas.addEventListener('mousemove', e => {
            if (MOUSE.drag) {
                MOUSE.drag.x = e.clientX; MOUSE.drag.y = e.clientY;
            }
        });

        // Rotate on wheel
        canvas.addEventListener('wheel', e => {
            if (MOUSE.drag) {
                MOUSE.drag.rot += (e.deltaY > 0 ? 0.1 : -0.1);
            }
        });

        window.addEventListener('mouseup', () => MOUSE.drag = null);

        // Raycasting Logic
        function trace() {
            RAYS = [];
            let r = { x: SOURCE.x, y: SOURCE.y, ang: SOURCE.dir, color: '#f00' };
            // Max 5 bounces
            for (let i = 0; i < 10; i++) {
                // Find closest intersection
                let closest = { dist: 2000, obj: null, norm: 0, pt: null };

                // Check Target
                // Target is AABB
                // Check intersection with line segment from r.x, r.y

                // Simplified Raymarching step
                let hitO = null;
                let endPt = { x: r.x + Math.cos(r.ang) * 2000, y: r.y + Math.sin(r.ang) * 2000 };

                // Intersect with Objects (Lines for Mirrors, Boxes for Glass)
                OBJECTS.forEach(o => {
                    // Assume Mirror is a Line Segment length 60
                    // Glass is box 40x40

                    let dist = 9999;
                    let pt = null;
                    let norm = 0;

                    if (o.type === 'mirror') {
                        // Line segment
                        const l = 30;
                        const x1 = o.x + Math.cos(o.rot) * l;
                        const y1 = o.y + Math.sin(o.rot) * l;
                        const x2 = o.x - Math.cos(o.rot) * l;
                        const y2 = o.y - Math.sin(o.rot) * l;

                        const res = lineIntersect(r.x, r.y, endPt.x, endPt.y, x1, y1, x2, y2);
                        if (res) {
                            // Hit
                            let d = Math.hypot(res.x - r.x, res.y - r.y);
                            if (d < closest.dist && d > 1) { // d>1 to avoid self intersect
                                closest.dist = d;
                                closest.pt = res;
                                closest.obj = o;
                                // Normal vector: perpendicular to line
                                closest.norm = o.rot + Math.PI / 2;
                            }
                        }
                    }
                });

                // Target Check
                const tx = TARGET.x; const ty = TARGET.y;
                // Simple AABB vs Line
                // Check dist to center?

                // Finalize Ray Segment
                let finalX = r.x + Math.cos(r.ang) * closest.dist;
                let finalY = r.y + Math.sin(r.ang) * closest.dist;

                // Check if this segment hit target
                // Target is line (tx, ty-30) to (tx, ty+30)
                const tres = lineIntersect(r.x, r.y, finalX, finalY, tx, ty - 30, tx, ty + 30);
                if (tres) {
                    TARGET.hit = true;
                    // Stop ray at target
                    RAYS.push({ x1: r.x, y1: r.y, x2: tres.x, y2: tres.y });
                    break;
                }

                RAYS.push({ x1: r.x, y1: r.y, x2: finalX, y2: finalY });

                if (closest.obj) {
                    if (closest.obj.type === 'mirror') {
                        // Reflect
                        // AngleIn = r.ang
                        // Normal = closest.norm
                        // R = I - 2(N.I)N
                        // Or easier: OutAng = 2*Normal - InAng - PI
                        let newAng = 2 * closest.norm - r.ang - Math.PI;
                        r = { x: finalX, y: finalY, ang: newAng };
                    }
                } else {
                    break; // Hit wall (infinity)
                }
            }
        }

        function lineIntersect(x1, y1, x2, y2, x3, y3, x4, y4) {
            const denom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);
            if (denom === 0) return null;
            const ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / denom;
            const ub = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / denom;
            if (ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1) {
                return { x: x1 + ua * (x2 - x1), y: y1 + ua * (y2 - y1) };
            }
            return null;
        }

        function loop() {
            TARGET.hit = false;
            trace();
            msg.style.display = TARGET.hit ? 'block' : 'none';

            // Draw
            ctx.fillStyle = '#000'; ctx.fillRect(0, 0, width, height);

            // Draw Target
            if (TARGET.hit) {
                ctx.shadowBlur = 20; ctx.shadowColor = '#0f0';
                ctx.fillStyle = '#0f0';
                // Fire particles?
            } else {
                ctx.shadowBlur = 0; ctx.fillStyle = '#333';
            }
            ctx.fillRect(TARGET.x, TARGET.y - 30, 20, 60);
            ctx.shadowBlur = 0;

            // Draw Objects
            OBJECTS.forEach(o => {
                ctx.save(); ctx.translate(o.x, o.y); ctx.rotate(o.rot);
                if (o.type === 'mirror') {
                    ctx.strokeStyle = '#fff'; ctx.lineWidth = 4;
                    ctx.beginPath(); ctx.moveTo(-30, 0); ctx.lineTo(30, 0); ctx.stroke();
                }
                ctx.restore();
            });

            // Draw Rays
            ctx.strokeStyle = '#f00'; ctx.lineWidth = 2;
            ctx.shadowBlur = 10; ctx.shadowColor = '#f00';
            RAYS.forEach(r => {
                ctx.beginPath(); ctx.moveTo(r.x1, r.y1); ctx.lineTo(r.x2, r.y2); ctx.stroke();
            });
            ctx.shadowBlur = 0;

            // Source
            ctx.fillStyle = '#f00'; ctx.fillRect(SOURCE.x - 10, SOURCE.y - 10, 20, 20);

            requestAnimationFrame(loop);
        }
        loop();

    </script>
</body>

</html>