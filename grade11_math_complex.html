<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Skila.ai | Complex Plane Radar</title>
    <link href="https://fonts.googleapis.com/css2?family=Share+Tech+Mono&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #0c0a15;
            font-family: 'Share Tech Mono', monospace;
            color: #a5b4fc;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        /* RADAR HUD */
        .hud-panel {
            pointer-events: auto;
            position: absolute;
            background: rgba(16, 16, 30, 0.9);
            border: 1px solid #4f46e5;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 0 20px rgba(79, 70, 229, 0.2);
        }

        #top-bar {
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 600px;
            display: flex;
            justify-content: space-around;
            text-align: center;
        }

        .val-big {
            font-size: 32px;
            color: #fff;
            text-shadow: 0 0 10px #818cf8;
        }

        .val-sub {
            font-size: 14px;
            color: #6366f1;
        }

        /* Operations Deck */
        #ops-deck {
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 20px;
        }

        .op-btn {
            background: #1e1b4b;
            color: #a5b4fc;
            border: 1px solid #4f46e5;
            padding: 15px 30px;
            font-family: 'Share Tech Mono';
            font-size: 18px;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
            overflow: hidden;
        }

        .op-btn:hover {
            background: #312e81;
            color: #fff;
            box-shadow: 0 0 15px #4f46e5;
        }

        .op-btn:active {
            transform: scale(0.95);
        }

        .op-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
            transition: left 0.5s;
        }

        .op-btn:hover::before {
            left: 100%;
        }

        #history-log {
            position: absolute;
            top: 100px;
            right: 20px;
            width: 250px;
            height: 400px;
            overflow-y: auto;
            font-size: 12px;
            opacity: 0.8;
        }

        .hist-entry {
            margin-bottom: 5px;
            border-bottom: 1px dashed #333;
            padding-bottom: 2px;
        }

        /* Floating Message */
        #floater {
            position: absolute;
            font-size: 24px;
            color: #fff;
            pointer-events: none;
            opacity: 0;
            text-shadow: 0 0 10px white;
        }
    </style>
</head>

<body>
    <canvas id="canvas"></canvas>

    <div id="ui-layer">
        <div class="hud-panel" id="top-bar">
            <div>
                <div class="val-sub">RECTANGULAR FORM</div>
                <div class="val-big" id="disp-rect">0 + 0i</div>
            </div>
            <div style="width:1px; background:#333;"></div>
            <div>
                <div class="val-sub">POLAR FORM</div>
                <div class="val-big" id="disp-polar">0 ∠ 0°</div>
            </div>
        </div>

        <div class="hud-panel" id="ops-deck">
            <button class="op-btn" onclick="opMultiplyI()">× i (Rotate 90°)</button>
            <button class="op-btn" onclick="opSquare()">z² (Square)</button>
            <button class="op-btn" onclick="opReset()">RESET</button>
        </div>

        <div class="hud-panel" id="history-log">
            <div style="color:#6366f1; margin-bottom:10px;">> OPERATION LOG</div>
            <div id="log-content"></div>
        </div>

        <div id="floater"></div>
    </div>

    <script>
        /**
         * COMPLEX PLANE RADAR
         * Visualizing Complex Numbers as Geometric Transformations.
         * z = x + iy
         * z = r(cos θ + i sin θ)
         */

        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const dispRect = document.getElementById('disp-rect');
        const dispPolar = document.getElementById('disp-polar');
        const logContent = document.getElementById('log-content');
        const floater = document.getElementById('floater');

        let W, H, CX, CY;
        const SCALE = 50; // Pixels per unit

        // State
        let Z = { x: 3, y: 2 }; // Current Complex Number
        let TARGET_Z = { x: 3, y: 2 }; // For animation
        let IS_ANIMATING = false;

        // Interaction
        let DRAG = false;

        // Sonar Animation
        let SCAN_ANGLE = 0;

        function init() {
            resize();
            window.addEventListener('resize', resize);

            // Mouse Interaction
            canvas.addEventListener('mousedown', e => {
                const m = getMousePos(e);
                // Check dist to Z
                const dx = m.px - (CX + Z.x * SCALE);
                const dy = m.py - (CY - Z.y * SCALE); // Y is inverted in complex plane vs canvas
                if (Math.hypot(dx, dy) < 20) {
                    DRAG = true;
                    if (IS_ANIMATING) finishAnim(); // Snap to end if interrupting
                }
            });
            window.addEventListener('mousemove', e => {
                if (DRAG) {
                    const m = getMousePos(e);
                    // Snap to grid? Optional.
                    // Raw
                    let nx = (m.px - CX) / SCALE;
                    let ny = -(m.py - CY) / SCALE;

                    // Soft snap to integers
                    if (Math.abs(nx - Math.round(nx)) < 0.1) nx = Math.round(nx);
                    if (Math.abs(ny - Math.round(ny)) < 0.1) ny = Math.round(ny);

                    Z.x = nx; Z.y = ny;
                    TARGET_Z = { ...Z };
                    updateHUD();
                }
            });
            window.addEventListener('mouseup', () => DRAG = false);

            updateHUD();
            loop();
        }

        function resize() {
            W = canvas.width = window.innerWidth;
            H = canvas.height = window.innerHeight;
            CX = W / 2;
            CY = H / 2;
        }

        function getMousePos(e) {
            const r = canvas.getBoundingClientRect();
            return { px: e.clientX - r.left, py: e.clientY - r.top };
        }

        // --- OPERATIONS ---
        window.opReset = () => {
            animateTo(2, 1);
            addLog("Reset System");
        };

        window.opMultiplyI = () => {
            // z * i = (x + iy) * i = ix - y = -y + ix
            // Rotate 90 deg CCW
            addLog(`Multiply: (${fmt(Z)}) × i`);
            animateTo(-Z.y, Z.x);
        };

        window.opSquare = () => {
            // z^2 = (x + iy)^2 = x^2 - y^2 + 2xyi
            // Polar: r^2 ∠ 2θ
            const nx = Z.x * Z.x - Z.y * Z.y;
            const ny = 2 * Z.x * Z.y;
            addLog(`Square: (${fmt(Z)})²`);
            animateTo(nx, ny);
        };

        function animateTo(tx, ty) {
            TARGET_Z = { x: tx, y: ty };
            IS_ANIMATING = true;
        }

        function finishAnim() {
            IS_ANIMATING = false;
            Z = { ...TARGET_Z };
            updateHUD();
        }

        function updateHUD() {
            if (IS_ANIMATING) return; // Wait loop to update

            // Rect
            const sx = Math.abs(Z.x) < 0.01 ? 0 : Z.x.toFixed(1);
            const sy = Math.abs(Z.y) < 0.01 ? 0 : Math.abs(Z.y).toFixed(1);
            const sign = Z.y >= 0 ? '+' : '-';
            dispRect.innerText = `${sx} ${sign} ${sy}i`;

            // Polar
            const r = Math.hypot(Z.x, Z.y);
            let theta = Math.atan2(Z.y, Z.x) * 180 / Math.PI;
            if (theta < 0) theta += 360;
            dispPolar.innerText = `${r.toFixed(1)} ∠ ${theta.toFixed(0)}°`;
        }

        function fmt(z) {
            return `${z.x.toFixed(1)}${z.y >= 0 ? '+' : ''}${z.y.toFixed(1)}i`;
        }

        function addLog(msg) {
            const d = document.createElement('div');
            d.className = 'hist-entry';
            d.innerText = `> ${msg}`;
            logContent.prepend(d);
        }

        // --- RENDER LOOP ---
        function loop() {
            // Animation Interp
            if (IS_ANIMATING) {
                // Lerp
                Z.x += (TARGET_Z.x - Z.x) * 0.1;
                Z.y += (TARGET_Z.y - Z.y) * 0.1;

                if (Math.hypot(TARGET_Z.x - Z.x, TARGET_Z.y - Z.y) < 0.01) {
                    finishAnim();
                }
                updateHUD();
            }

            // Scan Line
            SCAN_ANGLE += 0.02;

            render();
            requestAnimationFrame(loop);
        }

        function render() {
            ctx.fillStyle = '#0c0a15';
            ctx.fillRect(0, 0, W, H);

            // 1. RADAR GRID
            ctx.strokeStyle = '#1e1b4b';
            ctx.lineWidth = 1;

            // Circles
            for (let r = SCALE; r < Math.max(W, H); r += SCALE) {
                ctx.beginPath(); ctx.arc(CX, CY, r, 0, Math.PI * 2); ctx.stroke();
            }
            // Lines (Polar)
            for (let a = 0; a < Math.PI * 2; a += Math.PI / 6) {
                ctx.beginPath();
                ctx.moveTo(CX, CY);
                ctx.lineTo(CX + Math.cos(a) * W, CY + Math.sin(a) * W);
                ctx.stroke();
            }

            // Axes (Real / Imaginary)
            ctx.strokeStyle = '#4f46e5'; ctx.lineWidth = 2;
            ctx.beginPath(); ctx.moveTo(0, CY); ctx.lineTo(W, CY); ctx.stroke(); // Real (X)
            ctx.beginPath(); ctx.moveTo(CX, 0); ctx.lineTo(CX, H); ctx.stroke(); // Imag (Y)

            // Labels
            ctx.fillStyle = '#6366f1'; font = '12px monospace';
            ctx.fillText("REAL (Re)", W - 80, CY + 20);
            ctx.fillText("IMAGINARY (Im)", CX + 10, 20);

            // 2. SCANNER (Visual fluff)
            ctx.fillStyle = `rgba(79, 70, 229, 0.1)`;
            ctx.beginPath();
            ctx.moveTo(CX, CY);
            ctx.arc(CX, CY, Math.max(W, H), SCAN_ANGLE, SCAN_ANGLE + 0.5);
            ctx.lineTo(CX, CY);
            ctx.fill();

            // 3. THE VECTOR (Z)
            const zpx = CX + Z.x * SCALE;
            const zpy = CY - Z.y * SCALE; // Invert Y

            // Line from Origin
            ctx.strokeStyle = '#fff'; ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.beginPath(); ctx.moveTo(CX, CY); ctx.lineTo(zpx, zpy); ctx.stroke();
            ctx.setLineDash([]);

            // Blip Point
            ctx.shadowBlur = 20; ctx.shadowColor = '#fff';
            ctx.fillStyle = '#fff';
            ctx.beginPath(); ctx.arc(zpx, zpy, 6, 0, Math.PI * 2); ctx.fill();

            // Pulse Ring
            ctx.strokeStyle = '#fff'; ctx.lineWidth = 1;
            const pulse = (Date.now() % 1000) / 1000;
            ctx.beginPath(); ctx.arc(zpx, zpy, 6 + pulse * 20, 0, Math.PI * 2);
            ctx.globalAlpha = 1 - pulse;
            ctx.stroke();
            ctx.globalAlpha = 1;
            ctx.shadowBlur = 0;

            // Coordinates Label
            ctx.fillStyle = '#a5b4fc'; font = '14px monospace';
            ctx.fillText(fmt(Z), zpx + 15, zpy - 15);

            // Components (Projections)
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
            ctx.setLineDash([2, 2]);
            // Re proj
            ctx.beginPath(); ctx.moveTo(zpx, zpy); ctx.lineTo(zpx, CY); ctx.stroke();
            // Im proj
            ctx.beginPath(); ctx.moveTo(zpx, zpy); ctx.lineTo(CX, zpy); ctx.stroke();
            ctx.setLineDash([]);

        }

        init();
    </script>
</body>

</html>